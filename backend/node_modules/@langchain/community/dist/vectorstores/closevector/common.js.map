{"version":3,"file":"common.js","names":["embeddings: EmbeddingsInterface","args: {\n      space: \"l2\" | \"ip\" | \"cosine\";\n      numDimensions?: number;\n      maxElements?: number;\n    }","credentials?: CloseVectorCredentials","instance: CloseVectorHNSWImplementation","documents: Document[]","directory: string","vectors: number[][]","query: number[]","k: number","filter?: this[\"FilterType\"]","x: { pageContent: string; metadata: Record<string, unknown> }","mapped: [Document<Record<string, unknown>>, number][]","params: { directory: string }","texts: string[]","metadatas: object[] | object","docs: Document[]"],"sources":["../../../src/vectorstores/closevector/common.ts"],"sourcesContent":["import type { CloseVectorSaveableVectorStore } from \"closevector-common\";\n\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { Document } from \"@langchain/core/documents\";\nimport { SaveableVectorStore } from \"@langchain/core/vectorstores\";\n\ntype CloseVectorCredentials = {\n  key?: string;\n  secret?: string;\n};\n\n/**\n * package closevector is largely based on hnswlib.ts in the current folder with the following exceptions:\n * 1. It uses a modified version of hnswlib-node to ensure the generated index can be loaded by closevector_web.ts.\n * 2. It adds features to upload and download the index to/from the CDN provided by CloseVector.\n *\n * For more information, check out https://closevector-docs.getmegaportal.com/\n */\n\n/**\n * Class that implements a vector store using Hierarchical Navigable Small\n * World (HNSW) graphs. It extends the SaveableVectorStore class and\n * provides methods for adding documents and vectors, performing\n * similarity searches, and saving and loading the vector store.\n */\nexport abstract class CloseVector<\n  CloseVectorHNSWImplementation extends CloseVectorSaveableVectorStore,\n> extends SaveableVectorStore {\n  declare FilterType: (doc: Document) => boolean;\n\n  _instance?: CloseVectorHNSWImplementation;\n\n  // credentials will not be saved to disk\n  credentials?: CloseVectorCredentials;\n\n  _vectorstoreType(): string {\n    return \"closevector\";\n  }\n\n  constructor(\n    embeddings: EmbeddingsInterface,\n    args: {\n      space: \"l2\" | \"ip\" | \"cosine\";\n      numDimensions?: number;\n      maxElements?: number;\n    },\n    credentials?: CloseVectorCredentials\n  ) {\n    super(embeddings, args);\n    this.credentials = credentials;\n  }\n\n  public get instance(): CloseVectorHNSWImplementation {\n    if (!this._instance) {\n      throw new Error(\n        \"Vector store not initialised yet. Try calling `addTexts` first.\"\n      );\n    }\n    return this._instance;\n  }\n\n  protected set instance(instance: CloseVectorHNSWImplementation) {\n    this._instance = instance;\n  }\n\n  /**\n   * Method to add documents to the vector store. It first converts the\n   * documents to vectors using the embeddings, then adds the vectors to the\n   * vector store.\n   * @param documents The documents to be added to the vector store.\n   * @returns A Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[]): Promise<void> {\n    await this.instance.addDocuments(documents);\n  }\n\n  abstract saveToCloud(_options: Record<string, unknown>): Promise<void>;\n\n  /**\n   * Method to save the vector store to a directory. It saves the HNSW\n   * index, the arguments, and the document store to the directory.\n   * @param directory The directory to which to save the vector store. In CloseVector, we use IndexedDB to mock the file system. Therefore, this parameter is can be treated as a key to the contents stored.\n   * @returns A Promise that resolves when the vector store has been saved.\n   */\n  async save(directory: string): Promise<void> {\n    await this.instance.save(directory);\n  }\n\n  /**\n   * Method to add vectors to the vector store. It first initializes the\n   * index if it hasn't been initialized yet, then adds the vectors to the\n   * index and the documents to the document store.\n   * @param vectors The vectors to be added to the vector store.\n   * @param documents The documents corresponding to the vectors.\n   * @returns A Promise that resolves when the vectors and documents have been added.\n   */\n  async addVectors(vectors: number[][], documents: Document[]) {\n    await this.instance.addVectors(vectors, documents);\n  }\n\n  /**\n   * Method to perform a similarity search in the vector store using a query\n   * vector. It returns the k most similar documents along with their\n   * similarity scores. An optional filter function can be provided to\n   * filter the documents.\n   * @param query The query vector.\n   * @param k The number of most similar documents to return.\n   * @param filter An optional filter function to filter the documents.\n   * @returns A Promise that resolves to an array of tuples, where each tuple contains a document and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ) {\n    const resp = await this.instance.similaritySearchVectorWithScore(\n      query,\n      k,\n      filter\n        ? (x: { pageContent: string; metadata: Record<string, unknown> }) =>\n            filter?.({\n              pageContent: x.pageContent,\n              metadata: x.metadata || {},\n            }) || false\n        : undefined\n    );\n    const mapped: [Document<Record<string, unknown>>, number][] = resp.map(\n      (x) => [\n        new Document({\n          pageContent: x[0].pageContent,\n          metadata: x[0].metadata || {},\n        }),\n        1 - x[1],\n      ]\n    );\n    return mapped;\n  }\n\n  /**\n   * Method to delete the vector store from a directory. It deletes the\n   * hnswlib.index file, the docstore.json file, and the args.json file from\n   * the directory.\n   * @param params An object with a directory property that specifies the directory from which to delete the vector store.\n   * @returns A Promise that resolves when the vector store has been deleted.\n   */\n  async delete(params: { directory: string }) {\n    return await this.instance.delete(params);\n  }\n\n  static textsToDocuments(texts: string[], metadatas: object[] | object) {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return docs;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AAyBA,IAAsB,cAAtB,cAEU,oBAAoB;CAG5B;CAGA;CAEA,mBAA2B;AACzB,SAAO;CACR;CAED,YACEA,YACAC,MAKAC,aACA;EACA,MAAM,YAAY,KAAK;EACvB,KAAK,cAAc;CACpB;CAED,IAAW,WAA0C;AACnD,MAAI,CAAC,KAAK,UACR,OAAM,IAAI,MACR;AAGJ,SAAO,KAAK;CACb;CAED,IAAc,SAASC,UAAyC;EAC9D,KAAK,YAAY;CAClB;;;;;;;;CASD,MAAM,aAAaC,WAAsC;EACvD,MAAM,KAAK,SAAS,aAAa,UAAU;CAC5C;;;;;;;CAUD,MAAM,KAAKC,WAAkC;EAC3C,MAAM,KAAK,SAAS,KAAK,UAAU;CACpC;;;;;;;;;CAUD,MAAM,WAAWC,SAAqBF,WAAuB;EAC3D,MAAM,KAAK,SAAS,WAAW,SAAS,UAAU;CACnD;;;;;;;;;;;CAYD,MAAM,gCACJG,OACAC,GACAC,QACA;EACA,MAAM,OAAO,MAAM,KAAK,SAAS,gCAC/B,OACA,GACA,SACI,CAACC,MACC,SAAS;GACP,aAAa,EAAE;GACf,UAAU,EAAE,YAAY,CAAE;EAC3B,EAAC,IAAI,QACR,OACL;EACD,MAAMC,SAAwD,KAAK,IACjE,CAAC,MAAM,CACL,IAAI,SAAS;GACX,aAAa,EAAE,GAAG;GAClB,UAAU,EAAE,GAAG,YAAY,CAAE;EAC9B,IACD,IAAI,EAAE,EACP,EACF;AACD,SAAO;CACR;;;;;;;;CASD,MAAM,OAAOC,QAA+B;AAC1C,SAAO,MAAM,KAAK,SAAS,OAAO,OAAO;CAC1C;CAED,OAAO,iBAAiBC,OAAiBC,WAA8B;EACrE,MAAMC,OAAmB,CAAE;AAC3B,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;GACxC,MAAM,WAAW,MAAM,QAAQ,UAAU,GAAG,UAAU,KAAK;GAC3D,MAAM,SAAS,IAAI,SAAS;IAC1B,aAAa,MAAM;IACnB;GACD;GACD,KAAK,KAAK,OAAO;EAClB;AACD,SAAO;CACR;AACF"}