{"version":3,"file":"regex.cjs","names":["BaseOutputParser","fields: string | RegExp | RegexParserFields","outputKeys?: string[]","defaultOutputKey?: string","text: string","OutputParserException"],"sources":["../../src/output_parsers/regex.ts"],"sourcesContent":["import {\n  BaseOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\n\nexport interface RegExpFields {\n  pattern: string;\n  flags?: string;\n}\n\n/**\n * Interface for the fields required to create a RegexParser instance.\n */\nexport interface RegexParserFields {\n  regex: string | RegExp | RegExpFields;\n  outputKeys: string[];\n  defaultOutputKey?: string;\n}\n\n/**\n * Class to parse the output of an LLM call into a dictionary.\n * @augments BaseOutputParser\n */\nexport class RegexParser extends BaseOutputParser<Record<string, string>> {\n  static lc_name() {\n    return \"RegexParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"regex\"];\n\n  lc_serializable = true;\n\n  get lc_attributes(): SerializedFields | undefined {\n    return {\n      regex: this.lc_kwargs.regex,\n    };\n  }\n\n  regex: string | RegExp;\n\n  outputKeys: string[];\n\n  defaultOutputKey?: string;\n\n  constructor(fields: RegexParserFields);\n\n  constructor(\n    regex: string | RegExp,\n    outputKeys: string[],\n    defaultOutputKey?: string\n  );\n\n  constructor(\n    fields: string | RegExp | RegexParserFields,\n    outputKeys?: string[],\n    defaultOutputKey?: string\n  ) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (typeof fields === \"string\" || fields instanceof RegExp) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { regex: fields, outputKeys: outputKeys!, defaultOutputKey };\n    }\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields.regex instanceof RegExp) {\n      fields.regex = {\n        pattern: fields.regex.source,\n        flags: fields.regex.flags,\n      };\n    }\n    super(fields);\n    this.regex =\n      typeof fields.regex === \"string\"\n        ? new RegExp(fields.regex)\n        : \"pattern\" in fields.regex\n          ? new RegExp(fields.regex.pattern, fields.regex.flags)\n          : fields.regex;\n    this.outputKeys = fields.outputKeys;\n    this.defaultOutputKey = fields.defaultOutputKey;\n  }\n\n  _type() {\n    return \"regex_parser\";\n  }\n\n  /**\n   * Parses the given text using the regex pattern and returns a dictionary\n   * with the parsed output. If the regex pattern does not match the text\n   * and no defaultOutputKey is provided, throws an OutputParserException.\n   * @param text The text to be parsed.\n   * @returns A dictionary with the parsed output.\n   */\n  async parse(text: string): Promise<Record<string, string>> {\n    const match = text.match(this.regex);\n    if (match) {\n      return this.outputKeys.reduce(\n        (acc, key, index) => {\n          acc[key] = match[index + 1];\n          return acc;\n        },\n        {} as Record<string, string>\n      );\n    }\n\n    if (this.defaultOutputKey === undefined) {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n\n    return this.outputKeys.reduce(\n      (acc, key) => {\n        acc[key] = key === this.defaultOutputKey ? text : \"\";\n        return acc;\n      },\n      {} as Record<string, string>\n    );\n  }\n\n  /**\n   * Returns a string with instructions on how the LLM output should be\n   * formatted to match the regex pattern.\n   * @returns A string with formatting instructions.\n   */\n  getFormatInstructions(): string {\n    return `Your response should match the following regex: ${this.regex}`;\n  }\n}\n"],"mappings":";;;;;;;;AAwBA,IAAa,cAAb,cAAiCA,iDAAyC;CACxE,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAkB;CAAQ;CAEvD,kBAAkB;CAElB,IAAI,gBAA8C;AAChD,SAAO,EACL,OAAO,KAAK,UAAU,MACvB;CACF;CAED;CAEA;CAEA;CAUA,YACEC,QACAC,YACAC,kBACA;AAEA,MAAI,OAAO,WAAW,YAAY,kBAAkB,QAElD,SAAS;GAAE,OAAO;GAAoB;GAAa;EAAkB;AAGvE,MAAI,OAAO,iBAAiB,QAC1B,OAAO,QAAQ;GACb,SAAS,OAAO,MAAM;GACtB,OAAO,OAAO,MAAM;EACrB;EAEH,MAAM,OAAO;EACb,KAAK,QACH,OAAO,OAAO,UAAU,WACpB,IAAI,OAAO,OAAO,SAClB,aAAa,OAAO,QAClB,IAAI,OAAO,OAAO,MAAM,SAAS,OAAO,MAAM,SAC9C,OAAO;EACf,KAAK,aAAa,OAAO;EACzB,KAAK,mBAAmB,OAAO;CAChC;CAED,QAAQ;AACN,SAAO;CACR;;;;;;;;CASD,MAAM,MAAMC,MAA+C;EACzD,MAAM,QAAQ,KAAK,MAAM,KAAK,MAAM;AACpC,MAAI,MACF,QAAO,KAAK,WAAW,OACrB,CAAC,KAAK,KAAK,UAAU;GACnB,IAAI,OAAO,MAAM,QAAQ;AACzB,UAAO;EACR,GACD,CAAE,EACH;AAGH,MAAI,KAAK,qBAAqB,OAC5B,OAAM,IAAIC,sDAAsB,CAAC,wBAAwB,EAAE,MAAM,EAAE;AAGrE,SAAO,KAAK,WAAW,OACrB,CAAC,KAAK,QAAQ;GACZ,IAAI,OAAO,QAAQ,KAAK,mBAAmB,OAAO;AAClD,UAAO;EACR,GACD,CAAE,EACH;CACF;;;;;;CAOD,wBAAgC;AAC9B,SAAO,CAAC,gDAAgD,EAAE,KAAK,OAAO;CACvE;AACF"}