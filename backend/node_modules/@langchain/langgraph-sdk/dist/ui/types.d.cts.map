{"version":3,"file":"types.d.cts","names":["InferInteropZodInput","Client","ClientConfig","ThreadState","Config","Checkpoint","Metadata","Interrupt","Command","MultitaskStrategy","OnCompletionBehavior","DisconnectMode","Durability","UpdatesStreamEvent","CustomStreamEvent","MetadataStreamEvent","EventsStreamEvent","DebugStreamEvent","CheckpointsStreamEvent","TasksStreamEvent","StreamMode","DefaultToolCall","AIMessage","Message","ToolCallWithResult","BagTemplate","SubagentToolCall","SubagentStatus","DefaultSubagentStates","Record","StreamBase","StateType","ToolCall","InterruptType","SubagentStates","SubagentStream","Map","TName","Date","AgentTypeConfigLike","IsAgentLike","T","ExtractAgentConfig","AgentMiddlewareLike","TSchema","TContextSchema","TFullContext","TTools","InferMiddlewareState","S","IsAny","InferMiddlewareStatesFromArray","First","Rest","U","BaseAgentState","InferAgentState","InferAgentToolCalls","RunOutput","InferToolInput","Args","IsLiteralString","ToolCallFromAgentTool","N","Tool","SubAgentLike","CompiledSubAgentLike","DeepAgentTypeConfigLike","IsDeepAgentLike","ExtractDeepAgentConfig","ExtractSubAgentMiddleware","M","InferDeepAgentSubagents","InferSubagentByName","SA","BaseSubagentState","InferSubagentState","InferSubagentNames","SubagentStateMap","K","ExtractToolCallFromMessageUnion","TC","ExtractToolCallsFromState","Messages","MessageMetadata","GetUpdateType","Bag","Partial","GetConfigurableType","GetInterruptType","GetCustomEventType","GetToolCallsType","RunCallbackMeta","UseStreamThread","Promise","UseStreamOptions","RunMetadataStorage","AnyStreamOptions","ConfigWithConfigurable","ConfigurableType","SubmitOptions","ContextType","Omit","Array","UseStreamTransport","AbortSignal","AsyncGenerator","UseStreamCustomOptions","Pick","AnyStreamCustomOptions","CustomSubmitOptions"],"sources":["../../src/ui/types.d.ts"],"sourcesContent":["import type { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { Client, ClientConfig } from \"../client.js\";\nimport type { ThreadState, Config, Checkpoint, Metadata, Interrupt } from \"../schema.js\";\nimport type { Command, MultitaskStrategy, OnCompletionBehavior, DisconnectMode, Durability } from \"../types.js\";\nimport type { UpdatesStreamEvent, CustomStreamEvent, MetadataStreamEvent, EventsStreamEvent, DebugStreamEvent, CheckpointsStreamEvent, TasksStreamEvent, StreamMode } from \"../types.stream.js\";\nimport type { DefaultToolCall, AIMessage, Message, ToolCallWithResult } from \"../types.messages.js\";\nimport type { BagTemplate } from \"../types.template.js\";\n/**\n * Represents a tool call that initiated a subagent.\n */\nexport interface SubagentToolCall {\n    /** The tool call ID */\n    id: string;\n    /** The name of the tool (typically \"task\") */\n    name: string;\n    /** The arguments passed to the tool */\n    args: {\n        /** The task description for the subagent */\n        description?: string;\n        /** The type of subagent to use */\n        subagent_type?: string;\n        /** Additional custom arguments */\n        [key: string]: unknown;\n    };\n}\n/**\n * The execution status of a subagent.\n *\n * - `\"pending\"` - The subagent has been invoked but hasn't started processing yet.\n *   This is the initial state when a tool call is detected but before any\n *   streaming events are received from the subgraph.\n *\n * - `\"running\"` - The subagent is actively executing and streaming updates.\n *   The subagent transitions to this state when the first update event is\n *   received from its namespace.\n *\n * - `\"complete\"` - The subagent has finished execution successfully.\n *   A tool message with the result has been received, and the `result`\n *   property contains the final output.\n *\n * - `\"error\"` - The subagent encountered an error during execution.\n *   The `error` property on the SubagentStream contains error details.\n */\nexport type SubagentStatus = \"pending\" | \"running\" | \"complete\" | \"error\";\n/**\n * Default subagent state map used when no specific subagent types are provided.\n * Maps any string key to Record<string, unknown>.\n */\nexport type DefaultSubagentStates = Record<string, Record<string, unknown>>;\n/**\n * Base interface for stream-like objects.\n * Contains common properties shared between UseStream and SubagentStream.\n *\n * @template StateType - The type of the stream's state values.\n * @template ToolCall - The type of tool calls in messages.\n * @template InterruptType - The type of interrupt values.\n * @template SubagentStates - A map of subagent names to their state types.\n *   Use `SubagentStateMap<typeof agent>` to infer from a DeepAgent.\n */\nexport interface StreamBase<StateType = Record<string, unknown>, ToolCall = DefaultToolCall, InterruptType = unknown, SubagentStates extends Record<string, unknown> = DefaultSubagentStates> {\n    /**\n     * The current state values of the stream.\n     */\n    values: StateType;\n    /**\n     * Last seen error from the stream.\n     */\n    error: unknown;\n    /**\n     * Whether the stream is currently running.\n     */\n    isLoading: boolean;\n    /**\n     * Messages accumulated during the stream.\n     */\n    messages: Message<ToolCall>[];\n    /**\n     * Tool calls paired with their results.\n     * Useful for rendering tool invocations and their outputs together.\n     */\n    toolCalls: ToolCallWithResult<ToolCall>[];\n    /**\n     * Get tool calls for a specific AI message.\n     *\n     * @param message - The AI message to get tool calls for.\n     * @returns Array of tool calls initiated by the message.\n     */\n    getToolCalls: (message: AIMessage<ToolCall>) => ToolCallWithResult<ToolCall>[];\n    /**\n     * Get the interrupt value for the stream if interrupted.\n     */\n    interrupt: Interrupt<InterruptType> | undefined;\n    /**\n     * All currently active and completed subagent streams.\n     * Keyed by tool call ID for easy lookup.\n     */\n    subagents: Map<string, SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>>;\n    /**\n     * Currently active subagents (where status === \"running\").\n     */\n    activeSubagents: SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>[];\n    /**\n     * Get subagent stream by tool call ID.\n     *\n     * @param toolCallId - The tool call ID that initiated the subagent.\n     * @returns The subagent stream, or undefined if not found.\n     */\n    getSubagent: (toolCallId: string) => SubagentStream<SubagentStates[keyof SubagentStates], ToolCall> | undefined;\n    /**\n     * Get all subagents of a specific type.\n     * When called with a literal type name that matches a key in SubagentStates,\n     * returns streams with properly inferred state types.\n     *\n     * @param type - The subagent_type to filter by.\n     * @returns Array of matching subagent streams with inferred state types.\n     *\n     * @example\n     * ```ts\n     * // With DeepAgent type inference\n     * const stream = useStream<typeof agent>(...);\n     * const researchers = stream.getSubagentsByType(\"researcher\");\n     * // researchers[0].values is typed with ResearcherMiddleware state\n     * ```\n     */\n    getSubagentsByType: {\n        <TName extends keyof SubagentStates & string>(type: TName): SubagentStream<SubagentStates[TName], ToolCall>[];\n        (type: string): SubagentStream<Record<string, unknown>, ToolCall>[];\n    };\n    /**\n     * Get all subagents triggered by a specific AI message.\n     *\n     * Useful for rendering subagent activities grouped by the AI message\n     * (and therefore conversation turn) that spawned them.\n     *\n     * @param messageId - The ID of the AI message that triggered the subagents.\n     * @returns Array of subagent streams triggered by that message.\n     *\n     * @example\n     * ```tsx\n     * // Render subagents after each AI message that triggered them\n     * {stream.messages.map((msg) => (\n     *   <div key={msg.id}>\n     *     <MessageBubble message={msg} />\n     *     {msg.type === \"ai\" && \"tool_calls\" in msg && (\n     *       <SubagentPipeline\n     *         subagents={stream.getSubagentsByMessage(msg.id)}\n     *       />\n     *     )}\n     *   </div>\n     * ))}\n     * ```\n     */\n    getSubagentsByMessage: (messageId: string) => SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>[];\n}\n/**\n * Represents a single subagent stream.\n * Tracks the lifecycle of a subagent from invocation to completion.\n *\n * Extends StreamBase to share common properties with UseStream,\n * allowing subagents to be treated similarly to the main stream.\n *\n * @template StateType - The state type of the subagent. Defaults to Record<string, unknown>\n *   since different subagents may have different state types. Can be narrowed using\n *   DeepAgent type helpers like `InferSubagentByName` when the specific subagent is known.\n * @template ToolCall - The type of tool calls in messages.\n *\n * @example\n * ```typescript\n * // Default usage with unknown state\n * const subagent: SubagentStream = stream.getSubagent(\"call_123\");\n *\n * // Narrowed state type when subagent type is known\n * type ResearcherState = { research_notes: string };\n * const researcher = stream.getSubagent(\"call_123\") as SubagentStream<ResearcherState>;\n * console.log(researcher.values.research_notes);\n * ```\n */\nexport interface SubagentStream<StateType = Record<string, unknown>, ToolCall = DefaultToolCall> extends StreamBase<StateType, ToolCall> {\n    /** Unique identifier (the tool call ID) */\n    id: string;\n    /** The tool call that invoked this subagent */\n    toolCall: SubagentToolCall;\n    /** Current execution status */\n    status: SubagentStatus;\n    /** Final result content (when complete) */\n    result: string | null;\n    /** Namespace path for this subagent execution */\n    namespace: string[];\n    /** Tool call ID of parent subagent (for nested subagents) */\n    parentId: string | null;\n    /** Nesting depth (0 = called by main agent, 1 = called by subagent, etc.) */\n    depth: number;\n    /** When the subagent started */\n    startedAt: Date | null;\n    /** When the subagent completed */\n    completedAt: Date | null;\n}\n/**\n * Minimal interface matching the structure of AgentTypeConfig from @langchain/langgraph.\n * This allows type inference from ReactAgent without requiring the langchain dependency.\n */\nexport interface AgentTypeConfigLike {\n    Response: unknown;\n    State: unknown;\n    Context: unknown;\n    Middleware: unknown;\n    Tools: unknown;\n}\n/**\n * Check if a type is agent-like (has `~agentTypes` phantom property).\n * This property is present on `ReactAgent` instances created with `createAgent`.\n */\nexport type IsAgentLike<T> = T extends {\n    \"~agentTypes\": AgentTypeConfigLike;\n} ? true : false;\n/**\n * Extract the AgentTypeConfig from an agent-like type.\n *\n * @example\n * ```ts\n * const agent = createAgent({ ... });\n * type Config = ExtractAgentConfig<typeof agent>;\n * // Config is the AgentTypeConfig with Response, State, Context, Middleware, Tools\n * ```\n */\nexport type ExtractAgentConfig<T> = T extends {\n    \"~agentTypes\": infer Config;\n} ? Config extends AgentTypeConfigLike ? Config : never : never;\n/**\n * Minimal interface to structurally match AgentMiddleware from langchain.\n * We can't import AgentMiddleware due to circular dependencies, so we match\n * against its structure to extract type information.\n */\nexport interface AgentMiddlewareLike<TSchema = unknown, TContextSchema = unknown, TFullContext = unknown, TTools = unknown> {\n    name: string;\n    stateSchema?: TSchema;\n    \"~middlewareTypes\"?: {\n        Schema: TSchema;\n        ContextSchema: TContextSchema;\n        FullContext: TFullContext;\n        Tools: TTools;\n    };\n}\n/**\n * Helper type to extract state from a single middleware instance.\n * Uses structural matching against AgentMiddleware to extract the state schema\n * type parameter, similar to how langchain's InferMiddlewareState works.\n */\ntype InferMiddlewareState<T> = T extends AgentMiddlewareLike<infer TSchema, unknown, unknown, unknown> ? TSchema extends Record<string, any> ? InferInteropZodInput<TSchema> : {} : T extends {\n    stateSchema: infer S;\n} ? InferInteropZodInput<S> : {};\n/**\n * Helper type to detect if a type is `any`.\n * Uses the fact that `any` is both a subtype and supertype of all types.\n */\ntype IsAny<T> = 0 extends 1 & T ? true : false;\n/**\n * Helper type to extract and merge states from an array of middleware.\n * Recursively processes each middleware and intersects their state types.\n *\n * Handles both readonly and mutable arrays/tuples explicitly.\n *\n * @example\n * ```ts\n * type States = InferMiddlewareStatesFromArray<typeof middlewareArray>;\n * // Returns intersection of all middleware state types\n * ```\n */\nexport type InferMiddlewareStatesFromArray<T> = IsAny<T> extends true ? {} : T extends undefined | null ? {} : T extends readonly [] ? {} : T extends [] ? {} : T extends readonly [infer First, ...infer Rest extends readonly unknown[]] ? InferMiddlewareState<First> & InferMiddlewareStatesFromArray<Rest> : T extends [infer First, ...infer Rest extends unknown[]] ? InferMiddlewareState<First> & InferMiddlewareStatesFromArray<Rest> : T extends readonly (infer U)[] ? InferMiddlewareState<U> : T extends (infer U)[] ? InferMiddlewareState<U> : {};\n/**\n * Infer the complete merged state from an agent, including:\n * - The agent's own state schema (via State)\n * - All middleware states (via Middleware)\n *\n * This is the SDK equivalent of langchain's `InferAgentState` type.\n *\n * @example\n * ```ts\n * const agent = createAgent({\n *   middleware: [todoListMiddleware()],\n *   // ...\n * });\n *\n * type State = InferAgentState<typeof agent>;\n * // State includes { todos: Todo[], ... }\n * ```\n */\n/**\n * Base agent state that all agents have by default.\n * This includes the messages array which is fundamental to agent operation.\n * The ToolCall type parameter allows proper typing of tool calls in messages.\n */\ntype BaseAgentState<ToolCall = DefaultToolCall> = {\n    messages: Message<ToolCall>[];\n};\nexport type InferAgentState<T> = T extends {\n    \"~agentTypes\": unknown;\n} ? ExtractAgentConfig<T> extends never ? {} : BaseAgentState<InferAgentToolCalls<T>> & (ExtractAgentConfig<T>[\"State\"] extends undefined ? {} : InferInteropZodInput<ExtractAgentConfig<T>[\"State\"]>) & InferMiddlewareStatesFromArray<ExtractAgentConfig<T>[\"Middleware\"]> : T extends {\n    \"~RunOutput\": infer RunOutput;\n} ? RunOutput : T extends {\n    messages: unknown;\n} ? T : {};\n/**\n * Helper type to extract the input type from a DynamicStructuredTool's _call method.\n * This is more reliable than trying to infer from the schema directly because\n * DynamicStructuredTool has the input type baked into its _call signature.\n */\ntype InferToolInput<T> = T extends {\n    _call: (arg: infer Args, ...rest: any[]) => any;\n} ? Args : T extends {\n    schema: infer S;\n} ? InferInteropZodInput<S> : never;\n/**\n * Helper type to check if a type is a literal string (not generic `string`).\n * Returns true only for literal types like \"get_weather\", false for `string`.\n */\ntype IsLiteralString<T> = string extends T ? false : T extends string ? true : false;\n/**\n * Extract a tool call type from a single tool.\n * Works with tools created via `tool()` from `@langchain/core/tools`.\n *\n * This extracts the literal name type from DynamicStructuredTool's NameT parameter\n * and the args type from the _call method or schema's input property.\n *\n * Note: Only tools with literal string names (e.g., \"get_weather\") are included.\n * Tools with generic `name: string` are filtered out to ensure discriminated\n * union narrowing works correctly in TypeScript.\n */\ntype ToolCallFromAgentTool<T> = T extends {\n    name: infer N;\n} ? N extends string ? IsLiteralString<N> extends true ? InferToolInput<T> extends infer Args ? Args extends never ? never : Args extends Record<string, any> ? {\n    name: N;\n    args: Args;\n    id?: string;\n    type?: \"tool_call\";\n} : never : never : never : never : never;\n/**\n * Extract tool calls type from an agent's tools.\n * Converts the tools array to a discriminated union of tool calls.\n *\n * This handles both tuple types (e.g., `readonly [Tool1, Tool2]`) and\n * array-of-union types (e.g., `readonly (Tool1 | Tool2)[]`) which is how\n * `createAgent` captures tool types.\n *\n * @example\n * ```ts\n * const agent = createAgent({ tools: [getWeather, search], ... });\n * type ToolCalls = InferAgentToolCalls<typeof agent>;\n * // ToolCalls is:\n * // | { name: \"get_weather\"; args: { location: string }; id?: string }\n * // | { name: \"search\"; args: { query: string }; id?: string }\n * ```\n */\nexport type InferAgentToolCalls<T> = ExtractAgentConfig<T>[\"Tools\"] extends readonly (infer Tool)[] ? ToolCallFromAgentTool<Tool> extends never ? DefaultToolCall : ToolCallFromAgentTool<Tool> : DefaultToolCall;\n/**\n * Minimal interface matching the structure of a SubAgent from deepagents.\n * Used for structural type matching without importing deepagents.\n */\nexport interface SubAgentLike {\n    name: string;\n    description: string;\n    middleware?: readonly AgentMiddlewareLike[];\n}\n/**\n * Minimal interface matching the structure of a CompiledSubAgent from deepagents.\n * Used for structural type matching without importing deepagents.\n */\nexport interface CompiledSubAgentLike {\n    name: string;\n    description: string;\n    runnable: unknown;\n}\n/**\n * Minimal interface matching the structure of DeepAgentTypeConfig from deepagents.\n * Extends AgentTypeConfigLike to include subagent type information.\n */\nexport interface DeepAgentTypeConfigLike extends AgentTypeConfigLike {\n    Subagents: unknown;\n}\n/**\n * Check if a type is a DeepAgent (has `~deepAgentTypes` phantom property).\n * This property is present on DeepAgent instances created with `createDeepAgent`.\n */\nexport type IsDeepAgentLike<T> = T extends {\n    \"~deepAgentTypes\": DeepAgentTypeConfigLike;\n} ? true : false;\n/**\n * Extract the DeepAgentTypeConfig from a DeepAgent-like type.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({ subagents: [...] });\n * type Config = ExtractDeepAgentConfig<typeof agent>;\n * // Config includes { Subagents: [...] }\n * ```\n */\nexport type ExtractDeepAgentConfig<T> = T extends {\n    \"~deepAgentTypes\": infer Config;\n} ? Config extends DeepAgentTypeConfigLike ? Config : never : never;\n/**\n * Helper type to extract middleware from a SubAgent definition.\n * Handles both mutable and readonly middleware arrays.\n */\nexport type ExtractSubAgentMiddleware<T> = T extends {\n    middleware?: infer M;\n} ? M extends readonly AgentMiddlewareLike[] ? M : M extends AgentMiddlewareLike[] ? M : readonly [] : readonly [];\n/**\n * Extract the Subagents array type from a DeepAgent.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({ subagents: [researcher, writer] as const });\n * type Subagents = InferDeepAgentSubagents<typeof agent>;\n * // Subagents is the readonly tuple of subagent definitions\n * ```\n */\nexport type InferDeepAgentSubagents<T> = ExtractDeepAgentConfig<T> extends never ? never : ExtractDeepAgentConfig<T>[\"Subagents\"];\n/**\n * Helper type to extract a subagent by name from a DeepAgent.\n *\n * @typeParam T - The DeepAgent to extract from\n * @typeParam TName - The name of the subagent to extract\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", description: \"...\", middleware: [ResearchMiddleware] }\n *   ] as const,\n * });\n *\n * type Researcher = InferSubagentByName<typeof agent, \"researcher\">;\n * ```\n */\nexport type InferSubagentByName<T, TName extends string> = InferDeepAgentSubagents<T> extends readonly (infer SA)[] ? SA extends {\n    name: TName;\n} ? SA : never : never;\n/**\n * Base state type for subagents.\n * All subagents have at least a messages array, similar to the main agent.\n *\n * @template ToolCall - The tool call type for messages. Defaults to DefaultToolCall.\n */\nexport type BaseSubagentState<ToolCall = DefaultToolCall> = {\n    messages: Message<ToolCall>[];\n};\n/**\n * Infer the state type for a specific subagent by extracting and merging\n * its middleware state schemas, plus the base agent state (messages).\n *\n * @typeParam T - The DeepAgent to extract from\n * @typeParam TName - The name of the subagent\n * @typeParam ToolCall - The tool call type for messages. Defaults to DefaultToolCall.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", middleware: [ResearchMiddleware] }\n *   ] as const,\n * });\n *\n * type ResearcherState = InferSubagentState<typeof agent, \"researcher\">;\n * // ResearcherState includes { messages: Message<ToolCall>[], ...ResearchMiddleware state }\n * ```\n */\nexport type InferSubagentState<T, TName extends string, ToolCall = DefaultToolCall> = InferSubagentByName<T, TName> extends never ? Record<string, unknown> : InferSubagentByName<T, TName> extends infer SA ? BaseSubagentState<ToolCall> & InferMiddlewareStatesFromArray<ExtractSubAgentMiddleware<SA>> : Record<string, unknown>;\n/**\n * Extract all subagent names as a string union from a DeepAgent.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", ... },\n *     { name: \"writer\", ... }\n *   ] as const,\n * });\n *\n * type SubagentNames = InferSubagentNames<typeof agent>;\n * // SubagentNames = \"researcher\" | \"writer\"\n * ```\n */\nexport type InferSubagentNames<T> = InferDeepAgentSubagents<T> extends readonly (infer SA)[] ? SA extends {\n    name: infer N;\n} ? N extends string ? N : never : never : never;\n/**\n * Create a map of subagent names to their state types.\n * This is useful for type-safe `getSubagentsByType` calls.\n *\n * @typeParam T - The DeepAgent to extract from\n * @typeParam ToolCall - The tool call type for messages. Defaults to DefaultToolCall.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", middleware: [ResearchMiddleware] },\n *     { name: \"writer\", middleware: [WriterMiddleware] }\n *   ] as const,\n * });\n *\n * type StateMap = SubagentStateMap<typeof agent>;\n * // StateMap = { researcher: ResearchState; writer: WriterState }\n * ```\n */\nexport type SubagentStateMap<T, ToolCall = DefaultToolCall> = {\n    [K in InferSubagentNames<T>]: InferSubagentState<T, K, ToolCall>;\n};\n/**\n * Extract the tool call type parameter from an AIMessage in a message union.\n * Returns `never` if the message is not an AIMessage or uses DefaultToolCall.\n *\n * The key distinction: custom tool calls have literal `name` types (e.g., \"get_weather\"),\n * while DefaultToolCall has `name: string`. We check if `string extends TC[\"name\"]` -\n * if true, it's DefaultToolCall; if false, it's a custom type with literal names.\n */\ntype ExtractToolCallFromMessageUnion<M> = M extends AIMessage<infer TC> ? TC extends {\n    name: infer N;\n} ? string extends N ? never : TC : never : never;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the primary way to specify tool call types when using useStream.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // ExtractToolCallsFromState<MyState> = MyToolCalls\n * ```\n */\nexport type ExtractToolCallsFromState<StateType extends Record<string, unknown>> = StateType extends {\n    messages: infer Messages;\n} ? Messages extends readonly (infer M)[] ? ExtractToolCallFromMessageUnion<M> : Messages extends (infer M)[] ? ExtractToolCallFromMessageUnion<M> : never : never;\nexport type MessageMetadata<StateType extends Record<string, unknown>> = {\n    /**\n     * The ID of the message used.\n     */\n    messageId: string;\n    /**\n     * The first thread state the message was seen in.\n     */\n    firstSeenState: ThreadState<StateType> | undefined;\n    /**\n     * The branch of the message.\n     */\n    branch: string | undefined;\n    /**\n     * The list of branches this message is part of.\n     * This is useful for displaying branching controls.\n     */\n    branchOptions: string[] | undefined;\n    /**\n     * Metadata sent alongside the message during run streaming.\n     * @remarks This metadata only exists temporarily in browser memory during streaming and is not persisted after completion.\n     */\n    streamMetadata: Record<string, unknown> | undefined;\n};\nexport type GetUpdateType<Bag extends BagTemplate, StateType extends Record<string, unknown>> = Bag extends {\n    UpdateType: unknown;\n} ? Bag[\"UpdateType\"] : Partial<StateType>;\nexport type GetConfigurableType<Bag extends BagTemplate> = Bag extends {\n    ConfigurableType: Record<string, unknown>;\n} ? Bag[\"ConfigurableType\"] : Record<string, unknown>;\nexport type GetInterruptType<Bag extends BagTemplate> = Bag extends {\n    InterruptType: unknown;\n} ? Bag[\"InterruptType\"] : unknown;\nexport type GetCustomEventType<Bag extends BagTemplate> = Bag extends {\n    CustomEventType: unknown;\n} ? Bag[\"CustomEventType\"] : unknown;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the canonical way to get typed tool calls in useStream.\n *\n * Tool call types are now extracted from the messages property of StateType,\n * rather than being specified separately in the Bag.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // GetToolCallsType<MyState> = MyToolCalls\n * ```\n */\nexport type GetToolCallsType<StateType extends Record<string, unknown>> = ExtractToolCallsFromState<StateType> extends never ? DefaultToolCall : ExtractToolCallsFromState<StateType>;\nexport interface RunCallbackMeta {\n    run_id: string;\n    thread_id: string;\n}\nexport interface UseStreamThread<StateType extends Record<string, unknown>> {\n    data: ThreadState<StateType>[] | null | undefined;\n    error: unknown;\n    isLoading: boolean;\n    mutate: (mutateId?: string) => Promise<ThreadState<StateType>[] | null | undefined>;\n}\nexport interface UseStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    /**\n     * The ID of the assistant to use.\n     */\n    assistantId: string;\n    /**\n     * Client used to send requests.\n     */\n    client?: Client;\n    /**\n     * The URL of the API to use.\n     */\n    apiUrl?: ClientConfig[\"apiUrl\"];\n    /**\n     * The API key to use.\n     */\n    apiKey?: ClientConfig[\"apiKey\"];\n    /**\n     * Custom call options, such as custom fetch implementation.\n     */\n    callerOptions?: ClientConfig[\"callerOptions\"];\n    /**\n     * Default headers to send with requests.\n     */\n    defaultHeaders?: ClientConfig[\"defaultHeaders\"];\n    /**\n     * Specify the key within the state that contains messages.\n     * Defaults to \"messages\".\n     *\n     * @default \"messages\"\n     */\n    messagesKey?: string;\n    /**\n     * Callback that is called when an error occurs.\n     */\n    onError?: (error: unknown, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when the stream is finished.\n     */\n    onFinish?: (state: ThreadState<StateType>, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when a new stream is created.\n     */\n    onCreated?: (run: RunCallbackMeta) => void;\n    /**\n     * Callback that is called when an update event is received.\n     */\n    onUpdateEvent?: (data: UpdatesStreamEvent<GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a custom event is received.\n     */\n    onCustomEvent?: (data: CustomStreamEvent<GetCustomEventType<Bag>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a metadata event is received.\n     */\n    onMetadataEvent?: (data: MetadataStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a LangChain event is received.\n     * @see https://langchain-ai.github.io/langgraph/cloud/how-tos/stream_events/#stream-graph-in-events-mode for more details.\n     */\n    onLangChainEvent?: (data: EventsStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a debug event is received.\n     * @internal This API is experimental and subject to change.\n     */\n    onDebugEvent?: (data: DebugStreamEvent[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a checkpoints event is received.\n     */\n    onCheckpointEvent?: (data: CheckpointsStreamEvent<StateType>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a tasks event is received.\n     */\n    onTaskEvent?: (data: TasksStreamEvent<StateType, GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when the stream is stopped by the user.\n     * Provides a mutate function to update the stream state immediately\n     * without requiring a server roundtrip.\n     *\n     * @example\n     * ```typescript\n     * onStop: ({ mutate }) => {\n     *   mutate((prev) => ({\n     *     ...prev,\n     *     ui: prev.ui?.map(component =>\n     *       component.props.isLoading\n     *         ? { ...component, props: { ...component.props, stopped: true, isLoading: false }}\n     *         : component\n     *     )\n     *   }));\n     * }\n     * ```\n     */\n    onStop?: (options: {\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * The ID of the thread to fetch history and current values from.\n     */\n    threadId?: string | null;\n    /**\n     * Callback that is called when the thread ID is updated (ie when a new thread is created).\n     */\n    onThreadId?: (threadId: string) => void;\n    /** Will reconnect the stream on mount */\n    reconnectOnMount?: boolean | (() => RunMetadataStorage);\n    /**\n     * Initial values to display immediately when loading a thread.\n     * Useful for displaying cached thread data while official history loads.\n     * These values will be replaced when official thread data is fetched.\n     *\n     * Note: UI components from initialValues will render immediately if they're\n     * predefined in LoadExternalComponent's components prop, providing instant\n     * cached UI display without server fetches.\n     */\n    initialValues?: StateType | null;\n    /**\n     * Whether to fetch the history of the thread.\n     * If true, the history will be fetched from the server. Defaults to 10 entries.\n     * If false, only the last state will be fetched from the server.\n     * @default true\n     */\n    fetchStateHistory?: boolean | {\n        limit: number;\n    };\n    /**\n     * Manage the thread state externally.\n     */\n    thread?: UseStreamThread<StateType>;\n    /**\n     * Throttle the stream.\n     * If a number is provided, the stream will be throttled to the given number of milliseconds.\n     * If `true`, updates are batched in a single macrotask.\n     * If `false`, updates are not throttled or batched.\n     * @default true\n     */\n    throttle?: number | boolean;\n}\n/**\n * Union of all stream options types.\n *\n * Used internally by the implementation to accept any options type.\n * This allows the implementation functions to handle options from\n * any agent type while maintaining type safety at the public API level.\n *\n * @internal\n */\nexport type AnyStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = UseStreamOptions<StateType, Bag> & {\n    subagentToolNames?: string[];\n    filterSubagentMessages?: boolean;\n};\ninterface RunMetadataStorage {\n    getItem(key: `lg:stream:${string}`): string | null;\n    setItem(key: `lg:stream:${string}`, value: string): void;\n    removeItem(key: `lg:stream:${string}`): void;\n}\ntype ConfigWithConfigurable<ConfigurableType extends Record<string, unknown>> = Config & {\n    configurable?: ConfigurableType;\n};\nexport interface SubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ContextType extends Record<string, unknown> = Record<string, unknown>> {\n    config?: ConfigWithConfigurable<ContextType>;\n    context?: ContextType;\n    checkpoint?: Omit<Checkpoint, \"thread_id\"> | null;\n    command?: Command;\n    interruptBefore?: \"*\" | string[];\n    interruptAfter?: \"*\" | string[];\n    metadata?: Metadata;\n    multitaskStrategy?: MultitaskStrategy;\n    onCompletion?: OnCompletionBehavior;\n    onDisconnect?: DisconnectMode;\n    feedbackKeys?: string[];\n    streamMode?: Array<StreamMode>;\n    runId?: string;\n    optimisticValues?: Partial<StateType> | ((prev: StateType) => Partial<StateType>);\n    /**\n     * Whether or not to stream the nodes of any subgraphs called\n     * by the assistant.\n     * @default false\n     */\n    streamSubgraphs?: boolean;\n    /**\n     * Mark the stream as resumable. All events emitted during the run will be temporarily persisted\n     * in order to be re-emitted if the stream is re-joined.\n     * @default false\n     */\n    streamResumable?: boolean;\n    /**\n     * Whether to checkpoint during the run (or only at the end/interruption).\n     * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n     * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n     * - `\"exit\"`: Save checkpoint only when the graph exits.\n     * @default \"async\"\n     */\n    durability?: Durability;\n    /**\n     * The ID to use when creating a new thread. When provided, this ID will be used\n     * for thread creation when threadId is `null` or `undefined`.\n     * This enables optimistic UI updates where you know the thread ID\n     * before the thread is actually created.\n     */\n    threadId?: string;\n}\n/**\n * Transport used to stream the thread.\n * Only applicable for custom endpoints using `toLangGraphEventStream` or `toLangGraphEventStreamResponse`.\n */\nexport interface UseStreamTransport<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    stream: (payload: {\n        input: GetUpdateType<Bag, StateType> | null | undefined;\n        context: GetConfigurableType<Bag> | undefined;\n        command: Command | undefined;\n        config: ConfigWithConfigurable<GetConfigurableType<Bag>> | undefined;\n        signal: AbortSignal;\n    }) => Promise<AsyncGenerator<{\n        id?: string;\n        event: string;\n        data: unknown;\n    }>>;\n}\nexport type UseStreamCustomOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = Pick<UseStreamOptions<StateType, Bag>, \"messagesKey\" | \"threadId\" | \"onThreadId\" | \"onError\" | \"onCreated\" | \"onUpdateEvent\" | \"onCustomEvent\" | \"onMetadataEvent\" | \"onLangChainEvent\" | \"onDebugEvent\" | \"onCheckpointEvent\" | \"onTaskEvent\" | \"onStop\" | \"initialValues\" | \"throttle\"> & {\n    transport: UseStreamTransport<StateType, Bag>;\n};\n/**\n * Union of all custom stream options types.\n *\n * Used internally by the implementation to accept any custom options type.\n * This allows the implementation functions to handle options from\n * any agent type while maintaining type safety at the public API level.\n *\n * @internal\n */\nexport type AnyStreamCustomOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = UseStreamCustomOptions<StateType, Bag> & {\n    subagentToolNames?: string[];\n    filterSubagentMessages?: boolean;\n};\nexport type CustomSubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ConfigurableType extends Record<string, unknown> = Record<string, unknown>> = Pick<SubmitOptions<StateType, ConfigurableType>, \"optimisticValues\" | \"context\" | \"command\" | \"config\">;\nexport {};\n"],"mappings":"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"}