{"version":3,"file":"parent_document.d.cts","names":["VectorStoreInterface","VectorStoreRetrieverInterface","Document","TextSplitter","TextSplitterChunkHeaderOptions","BaseDocumentCompressor","MultiVectorRetriever","MultiVectorRetrieverInput","SubDocs","Record","ParentDocumentRetrieverFields","ParentDocumentRetriever","Promise"],"sources":["../../src/retrievers/parent_document.d.ts"],"sourcesContent":["import { type VectorStoreInterface, type VectorStoreRetrieverInterface } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { TextSplitter, TextSplitterChunkHeaderOptions } from \"@langchain/textsplitters\";\nimport type { BaseDocumentCompressor } from \"./document_compressors/index.js\";\nimport { MultiVectorRetriever, type MultiVectorRetrieverInput } from \"./multi_vector.js\";\nexport type SubDocs = Document<Record<string, any>>[];\n/**\n * Interface for the fields required to initialize a\n * ParentDocumentRetriever instance.\n */\nexport type ParentDocumentRetrieverFields = MultiVectorRetrieverInput & {\n    childSplitter: TextSplitter;\n    parentSplitter?: TextSplitter;\n    /**\n     * A custom retriever to use when retrieving instead of\n     * the `.similaritySearch` method of the vectorstore.\n     */\n    childDocumentRetriever?: VectorStoreRetrieverInterface<VectorStoreInterface>;\n    documentCompressor?: BaseDocumentCompressor | undefined;\n    documentCompressorFilteringFn?: (docs: SubDocs) => SubDocs;\n};\n/**\n * A type of document retriever that splits input documents into smaller chunks\n * while separately storing and preserving the original documents.\n * The small chunks are embedded, then on retrieval, the original\n * \"parent\" documents are retrieved.\n *\n * This strikes a balance between better targeted retrieval with small documents\n * and the more context-rich larger documents.\n * @example\n * ```typescript\n * const retriever = new ParentDocumentRetriever({\n *   vectorstore: new MemoryVectorStore(new OpenAIEmbeddings()),\n *   byteStore: new InMemoryStore<Uint8Array>(),\n *   parentSplitter: new RecursiveCharacterTextSplitter({\n *     chunkOverlap: 0,\n *     chunkSize: 500,\n *   }),\n *   childSplitter: new RecursiveCharacterTextSplitter({\n *     chunkOverlap: 0,\n *     chunkSize: 50,\n *   }),\n *   childK: 20,\n *   parentK: 5,\n * });\n *\n * const parentDocuments = await getDocuments();\n * await retriever.addDocuments(parentDocuments);\n * const retrievedDocs = await retriever.invoke(\"justice breyer\");\n * ```\n */\nexport declare class ParentDocumentRetriever extends MultiVectorRetriever {\n    static lc_name(): string;\n    lc_namespace: string[];\n    vectorstore: VectorStoreInterface;\n    protected childSplitter: TextSplitter;\n    protected parentSplitter?: TextSplitter;\n    protected idKey: string;\n    protected childK?: number;\n    protected parentK?: number;\n    childDocumentRetriever: VectorStoreRetrieverInterface<VectorStoreInterface> | undefined;\n    documentCompressor: BaseDocumentCompressor | undefined;\n    documentCompressorFilteringFn?: ParentDocumentRetrieverFields[\"documentCompressorFilteringFn\"];\n    constructor(fields: ParentDocumentRetrieverFields);\n    _getRelevantDocuments(query: string): Promise<Document[]>;\n    _storeDocuments(parentDoc: Record<string, Document>, childDocs: Document[], addToDocstore: boolean): Promise<void>;\n    /**\n     * Adds documents to the docstore and vectorstores.\n     * If a retriever is provided, it will be used to add documents instead of the vectorstore.\n     * @param docs The documents to add\n     * @param config.ids Optional list of ids for documents. If provided should be the same\n     *   length as the list of documents. Can provided if parent documents\n     *   are already in the document store and you don't want to re-add\n     *   to the docstore. If not provided, random UUIDs will be used as ids.\n     * @param config.addToDocstore Boolean of whether to add documents to docstore.\n     * This can be false if and only if `ids` are provided. You may want\n     *   to set this to False if the documents are already in the docstore\n     *   and you don't want to re-add them.\n     * @param config.chunkHeaderOptions Object with options for adding Contextual chunk headers\n     */\n    addDocuments(docs: Document[], config?: {\n        ids?: string[];\n        addToDocstore?: boolean;\n        childDocChunkHeaderOptions?: TextSplitterChunkHeaderOptions;\n    }): Promise<void>;\n}\n//# sourceMappingURL=parent_document.d.ts.map"],"mappings":";;;;;;;KAKYQ,OAAAA,GAAUN,SAASO;;AAA/B;AAKA;;AACmBN,KADPO,6BAAAA,GAAgCH,yBACzBJ,GAAAA;EACEA,aAAAA,EADFA,YACEA;EAKsCH,cAAAA,CAAAA,EALtCG,YAKsCH;EAA9BC;;;;EAEiC,sBAAA,CAAA,EAFjCA,6BAEiC,CAFHD,oBAEG,CAAA;EAgCzCW,kBAAAA,CAAAA,EAjCIN,sBAiCmB,GAAA,SAAA;EAG3BL,6BAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAnC0BQ,OAmC1BR,EAAAA,GAnCsCQ,OAmCtCR;CACYG;;;;;;;;;;;;;;;;;AAJ4C;;;;;;;;;;;;;;cAApDQ,uBAAAA,SAAgCL,oBAAAA;;;eAGpCN;2BACYG;6BACEA;;;;0BAIHF,8BAA8BD;sBAClCK;kCACYK;sBACZA;wCACkBE,QAAQV;6BACnBO,eAAeP,sBAAsBA,qCAAqCU;;;;;;;;;;;;;;;qBAelFV;;;iCAGcE;MAC7BQ"}