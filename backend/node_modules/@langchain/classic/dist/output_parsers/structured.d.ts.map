{"version":3,"file":"structured.d.ts","names":["z","BaseOutputParser","FormatInstructionsOptions","InferInteropZodOutput","InteropZodType","JsonMarkdownStructuredOutputParserInput","JsonMarkdownFormatInstructionsOptions","StructuredOutputParser","T","S","_langchain_core_load_serializable0","SerializedNotImplemented","ZodString","ZodTypeAny","ZodObject","Promise","JsonMarkdownStructuredOutputParser","AsymmetricStructuredOutputParserFields","AsymmetricStructuredOutputParser","Y","inputSchema"],"sources":["../../src/output_parsers/structured.d.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { BaseOutputParser, FormatInstructionsOptions } from \"@langchain/core/output_parsers\";\nimport { type InferInteropZodOutput, type InteropZodType } from \"@langchain/core/utils/types\";\nexport type JsonMarkdownStructuredOutputParserInput = {\n    interpolationDepth?: number;\n};\nexport interface JsonMarkdownFormatInstructionsOptions extends FormatInstructionsOptions {\n    interpolationDepth?: number;\n}\nexport declare class StructuredOutputParser<T extends InteropZodType> extends BaseOutputParser<InferInteropZodOutput<T>> {\n    schema: T;\n    static lc_name(): string;\n    lc_namespace: string[];\n    toJSON(): import(\"@langchain/core/load/serializable\").SerializedNotImplemented;\n    constructor(schema: T);\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema<T extends InteropZodType>(schema: T): StructuredOutputParser<T>;\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions<S extends {\n        [key: string]: string;\n    }>(schemas: S): StructuredOutputParser<z.ZodObject<{\n        [k: string]: z.ZodString;\n    }, \"strip\", z.ZodTypeAny, {\n        [x: string]: string;\n    }, {\n        [x: string]: string;\n    }>>;\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions(): string;\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    parse(text: string): Promise<InferInteropZodOutput<T>>;\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport declare class JsonMarkdownStructuredOutputParser<T extends InteropZodType> extends StructuredOutputParser<T> {\n    static lc_name(): string;\n    getFormatInstructions(options?: JsonMarkdownFormatInstructionsOptions): string;\n    private _schemaToInstruction;\n    static fromZodSchema<T extends InteropZodType>(schema: T): JsonMarkdownStructuredOutputParser<T>;\n    static fromNamesAndDescriptions<S extends {\n        [key: string]: string;\n    }>(schemas: S): JsonMarkdownStructuredOutputParser<z.ZodObject<{\n        [k: string]: z.ZodString;\n    }, \"strip\", z.ZodTypeAny, {\n        [x: string]: string;\n    }, {\n        [x: string]: string;\n    }>>;\n}\nexport interface AsymmetricStructuredOutputParserFields<T extends InteropZodType> {\n    inputSchema: T;\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport declare abstract class AsymmetricStructuredOutputParser<T extends InteropZodType, Y = unknown> extends BaseOutputParser<Y> {\n    private structuredInputParser;\n    constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>);\n    /**\n     * Processes the parsed input into the desired output format. Must be\n     * implemented by subclasses.\n     * @param input The parsed input\n     * @returns The processed output.\n     */\n    abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n    parse(text: string): Promise<Y>;\n    getFormatInstructions(): string;\n}\n//# sourceMappingURL=structured.d.ts.map"],"mappings":";;;;;;KAGYK,uCAAAA;;;AAAAA,UAGKC,qCAAAA,SAA8CJ,yBAHZ,CAAA;EAGlCI,kBAAAA,CAAAA,EAAAA,MAAAA;AAGjB;AAAsDF,cAAjCG,sBAAiCH,CAAAA,UAAAA,cAAAA,CAAAA,SAAwBH,gBAAxBG,CAAyCD,qBAAzCC,CAA+DI,CAA/DJ,CAAAA,CAAAA,CAAAA;EAA+DI,MAAAA,EACzGA,CADyGA;EAAtBL,OAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EACnFK,YAAAA,EAAAA,MAAAA,EAAAA;EAACE,MAAAA,CAAAA,CAAAA,EAAAA,kCAAAA,CAG6CC,wBAAAA;EAClCH,WAAAA,CAAAA,MAAAA,EAAAA,CAAAA;EAMWJ;;;;;EAUZQ,OAAAA,aAAAA,CAAAA,UAVYR,cAUZQ,CAAAA,CAAAA,MAAAA,EAVoCJ,CAUpCI,CAAAA,EAVwCL,sBAUxCK,CAV+DJ,CAU/DI,CAAAA;EACLC;;;;;;EAtB4DZ,OAAAA,wBAAAA,CAAAA,UAAAA;IAAgB,CAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA;EA6CzEe,CAAAA,CAAAA,CAAAA,OAAAA,EAzBLP,CAyBKO,CAAAA,EAzBDT,sBAyBmC,CAzBZP,CAAAA,CAAEc,SAyBUL,CAAAA;IAAWL,CAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAxB7CJ,CAAAA,CAAEY,SAwB2CR;EAA+CI,CAAAA,EAAAA,OAAAA,EAvBjGR,CAAAA,CAAEa,UAuB+FL,EAAAA;IAE7EF,CAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA;EAEDF,CAAAA,EAAAA;IAAwBI,CAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA;EAAuCA,CAAAA,CAAAA,CAAAA;EAAnCQ;;;;;;EAJ2BT,qBAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAAsB;AAehH;AAOA;;;EAEkBa,KAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAAAA,EA9BOL,OA8BPK,CA9BejB,qBA8BfiB,CA9BqCZ,CA8BrCY,CAAAA,CAAAA;;;;;;AAO6CL,cA/B1CC,kCA+B0CD,CAAAA,UA/BGX,cA+BHW,CAAAA,SA/B2BR,sBA+B3BQ,CA/BkDP,CA+BlDO,CAAAA,CAAAA;EAC9BI,OAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAARJ,qBAAAA,CAAAA,OAAAA,CAAAA,EA9BWT,qCA8BXS,CAAAA,EAAAA,MAAAA;EAVqFd,QAAAA,oBAAAA;EAAgB,OAAA,aAAA,CAAA,UAlB3FG,cAkB2F,CAAA,CAAA,MAAA,EAlBnEI,CAkBmE,CAAA,EAlB/DQ,kCAkB+D,CAlB5BR,CAkB4B,CAAA;;;cAf9GC,IAAIO,mCAAmChB,CAAAA,CAAEc;iBACpCd,CAAAA,CAAEY;cACPZ,CAAAA,CAAEa;;;;;;UAMDI,iDAAiDb;eACjDI;;;;;;uBAMaU,2CAA2Cd,qCAAqCH,iBAAiBkB;;;;KAE9FF,uCAAuCT;;;;;;;kCAOpCL,sBAAsBK,KAAKO,QAAQI;uBAC9CJ,QAAQI"}