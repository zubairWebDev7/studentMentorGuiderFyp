{"version":3,"file":"vectara.cjs","names":["value: Value","BaseTranslator","Operators","Comparators","func: Operator | Comparator","operation: Operation","comparison: Comparison","query: StructuredQuery","defaultFilter: VectaraFilter | undefined","generatedFilter: VectaraFilter | undefined"],"sources":["../../src/structured_query/vectara.ts"],"sourcesContent":["import {\n  BaseTranslator,\n  isFilterEmpty,\n  Comparator,\n  Comparators,\n  Comparison,\n  NOT,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n} from \"@langchain/core/structured_query\";\nimport { VectaraFilter, VectaraStore } from \"../vectorstores/vectara.js\";\n\ntype AllowedOperator = Exclude<Operator, NOT>;\n\nexport type VectaraVisitorResult =\n  | VectaraOperationResult\n  | VectaraComparisonResult\n  | VectaraVisitorStructuredQueryResult;\nexport type VectaraOperationResult = String;\nexport type VectaraComparisonResult = String;\nexport type VectaraVisitorStructuredQueryResult = {\n  filter?: { filter?: VectaraOperationResult | VectaraComparisonResult };\n};\n\ntype Value = number | string;\nfunction processValue(value: Value): string {\n  /** Convert a value to a string and add single quotes if it is a string. */\n  if (typeof value === \"string\") {\n    return `'${value}'`;\n  } else {\n    return String(value);\n  }\n}\n\nexport class VectaraTranslator<\n  T extends VectaraStore,\n> extends BaseTranslator<T> {\n  declare VisitOperationOutput: VectaraOperationResult;\n\n  declare VisitComparisonOutput: VectaraComparisonResult;\n\n  allowedOperators: Operator[] = [Operators.and, Operators.or];\n\n  allowedComparators: Comparator[] = [\n    Comparators.eq,\n    Comparators.ne,\n    Comparators.lt,\n    Comparators.lte,\n    Comparators.gt,\n    Comparators.gte,\n  ];\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed operators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n\n    const mapDict = {\n      and: \" and \",\n      or: \" or \",\n      eq: \"=\",\n      ne: \"!=\",\n      lt: \"<\",\n      lte: \"<=\",\n      gt: \">\",\n      gte: \">=\",\n    };\n    return mapDict[func as Comparator | AllowedOperator];\n  }\n\n  /**\n   * Visits an operation and returns a VectaraOperationResult. The\n   * operation's arguments are visited and the operator is formatted.\n   * @param operation The operation to visit.\n   * @returns A VectaraOperationResult.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) =>\n      arg.accept(this as Visitor)\n    ) as VectaraVisitorResult[];\n    const operator = this.formatFunction(operation.operator);\n    return `( ${args.join(operator)} )`;\n  }\n\n  /**\n   * Visits a comparison and returns a VectaraComparisonResult. The\n   * comparison's value is checked for type and the comparator is formatted.\n   * Throws an error if the value type is not supported.\n   * @param comparison The comparison to visit.\n   * @returns A VectaraComparisonResult.\n   */\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    const comparator = this.formatFunction(comparison.comparator);\n    return `( doc.${comparison.attribute} ${comparator} ${processValue(\n      comparison.value\n    )} )`;\n  }\n\n  /**\n   * Visits a structured query and returns a VectaraStructuredQueryResult.\n   * If the query has a filter, it is visited.\n   * @param query The structured query to visit.\n   * @returns A VectaraStructuredQueryResult.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {};\n    if (query.filter) {\n      nextArg = {\n        filter: { filter: query.filter.accept(this as Visitor) },\n      };\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: VectaraFilter | undefined,\n    generatedFilter: VectaraFilter | undefined,\n    mergeType = \"and\",\n    forceDefaultFilter = false\n  ): VectaraFilter | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n\n    if (mergeType === \"and\") {\n      return {\n        filter: `${defaultFilter} and ${generatedFilter}`,\n      } as VectaraFilter;\n    } else if (mergeType === \"or\") {\n      return {\n        filter: `${defaultFilter} or ${generatedFilter}`,\n      };\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n"],"mappings":";;;;;;AA4BA,SAAS,aAAaA,OAAsB;;AAE1C,KAAI,OAAO,UAAU,SACnB,QAAO,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;KAEnB,QAAO,OAAO,MAAM;AAEvB;AAED,IAAa,oBAAb,cAEUC,iDAAkB;CAK1B,mBAA+B,CAACC,4CAAU,KAAKA,4CAAU,EAAG;CAE5D,qBAAmC;EACjCC,8CAAY;EACZA,8CAAY;EACZA,8CAAY;EACZA,8CAAY;EACZA,8CAAY;EACZA,8CAAY;CACb;CAED,eAAeC,MAAqC;AAClD,MAAI,QAAQD,+CACV;OACE,KAAK,mBAAmB,SAAS,KACjC,KAAK,mBAAmB,QAAQ,KAAmB,KAAK,GAExD,OAAM,IAAI,MACR,CAAC,WAAW,EAAE,KAAK,iCAAiC,EAAE,KAAK,mBAAmB,KAC5E,KACD,EAAE;EAEN,WACQ,QAAQD,6CACjB;OACE,KAAK,iBAAiB,SAAS,KAC/B,KAAK,iBAAiB,QAAQ,KAAiB,KAAK,GAEpD,OAAM,IAAI,MACR,CAAC,SAAS,EAAE,KAAK,iCAAiC,EAAE,KAAK,iBAAiB,KACxE,KACD,EAAE;EAEN,MAED,OAAM,IAAI,MAAM;EAGlB,MAAM,UAAU;GACd,KAAK;GACL,IAAI;GACJ,IAAI;GACJ,IAAI;GACJ,IAAI;GACJ,KAAK;GACL,IAAI;GACJ,KAAK;EACN;AACD,SAAO,QAAQ;CAChB;;;;;;;CAQD,eAAeG,WAAoD;EACjE,MAAM,OAAO,UAAU,MAAM,IAAI,CAAC,QAChC,IAAI,OAAO,KAAgB,CAC5B;EACD,MAAM,WAAW,KAAK,eAAe,UAAU,SAAS;AACxD,SAAO,CAAC,EAAE,EAAE,KAAK,KAAK,SAAS,CAAC,EAAE,CAAC;CACpC;;;;;;;;CASD,gBAAgBC,YAAuD;EACrE,MAAM,aAAa,KAAK,eAAe,WAAW,WAAW;AAC7D,SAAO,CAAC,MAAM,EAAE,WAAW,UAAU,CAAC,EAAE,WAAW,CAAC,EAAE,aACpD,WAAW,MACZ,CAAC,EAAE,CAAC;CACN;;;;;;;CAQD,qBACEC,OACoC;EACpC,IAAI,UAAU,CAAE;AAChB,MAAI,MAAM,QACR,UAAU,EACR,QAAQ,EAAE,QAAQ,MAAM,OAAO,OAAO,KAAgB,CAAE,EACzD;AAEH,SAAO;CACR;CAED,aACEC,eACAC,iBACA,YAAY,OACZ,qBAAqB,OACM;AAC3B,2DAAkB,cAAc,yDAAkB,gBAAgB,CAChE,QAAO;AAET,2DAAkB,cAAc,IAAI,cAAc,WAAW;AAC3D,4DAAkB,gBAAgB,CAChC,QAAO;AAET,UAAO;EACR;AACD,2DAAkB,gBAAgB,EAAE;AAClC,OAAI,mBACF,QAAO;AAET,OAAI,cAAc,MAChB,QAAO;AAET,UAAO;EACR;AAED,MAAI,cAAc,MAChB,QAAO,EACL,QAAQ,GAAG,cAAc,KAAK,EAAE,iBAAiB,CAClD;WACQ,cAAc,KACvB,QAAO,EACL,QAAQ,GAAG,cAAc,IAAI,EAAE,iBAAiB,CACjD;MAED,OAAM,IAAI,MAAM;CAEnB;AACF"}