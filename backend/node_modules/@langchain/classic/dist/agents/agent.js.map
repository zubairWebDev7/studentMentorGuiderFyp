{"version":3,"file":"agent.js","names":["msg: string","output: string","earlyStoppingMethod: StoppingMethod","_steps: AgentStep[]","_inputs: ChainValues","_callbackManager?: CallbackManager","_returnValues: AgentFinish[\"returnValues\"]","input: unknown","x: BaseAgent","config: { singleAction: boolean; streamRunnable?: boolean; name?: string }","x: Runnable","fields: RunnableSingleActionAgentInput","steps: AgentStep[]","inputs: ChainValues","callbackManager?: CallbackManager","config?: RunnableConfig","finalOutput: AgentAction | AgentFinish | undefined","fields: RunnableMultiActionAgentInput","finalOutput: AgentAction | AgentFinish | AgentAction[] | undefined","input: LLMSingleActionAgentInput","input: AgentInput","_fields?: OutputParserArgs","_tools: StructuredToolInterface[]","_fields?: Record<string, any>","_llm: BaseLanguageModelInterface","_args?: AgentArgs","suffix?: string","newInputs: ChainValues","data: SerializedAgent & {\n      llm?: BaseLanguageModelInterface;\n      tools?: ToolInterface[];\n    }"],"sources":["../../src/agents/agent.ts"],"sourcesContent":["import type {\n  StructuredToolInterface,\n  ToolInterface,\n} from \"@langchain/core/tools\";\nimport type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { CallbackManager, Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { AgentAction, AgentFinish, AgentStep } from \"@langchain/core/agents\";\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport {\n  Runnable,\n  patchConfig,\n  type RunnableConfig,\n  RunnableSequence,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport type {\n  AgentActionOutputParser,\n  AgentInput,\n  RunnableMultiActionAgentInput,\n  RunnableSingleActionAgentInput,\n  SerializedAgent,\n  StoppingMethod,\n} from \"./types.js\";\n\n/**\n * Record type for arguments passed to output parsers.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type OutputParserArgs = Record<string, any>;\n\n/**\n * Error class for parse errors in LangChain. Contains information about\n * the error message and the output that caused the error.\n */\nclass ParseError extends Error {\n  output: string;\n\n  constructor(msg: string, output: string) {\n    super(msg);\n    this.output = output;\n  }\n}\n\n/**\n * Abstract base class for agents in LangChain. Provides common\n * functionality for agents, such as handling inputs and outputs.\n */\nexport abstract class BaseAgent extends Serializable {\n  declare ToolType: StructuredToolInterface;\n\n  abstract get inputKeys(): string[];\n\n  get returnValues(): string[] {\n    return [\"output\"];\n  }\n\n  get allowedTools(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * Return the string type key uniquely identifying this class of agent.\n   */\n  _agentType(): string {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Return the string type key uniquely identifying multi or single action agents.\n   */\n  abstract _agentActionType(): string;\n\n  /**\n   * Return response when agent has been stopped due to max iterations\n   */\n  returnStoppedResponse(\n    earlyStoppingMethod: StoppingMethod,\n    _steps: AgentStep[],\n    _inputs: ChainValues,\n    _callbackManager?: CallbackManager\n  ): Promise<AgentFinish> {\n    if (earlyStoppingMethod === \"force\") {\n      return Promise.resolve({\n        returnValues: { output: \"Agent stopped due to max iterations.\" },\n        log: \"\",\n      });\n    }\n\n    throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n  }\n\n  /**\n   * Prepare the agent for output, if needed\n   */\n  async prepareForOutput(\n    _returnValues: AgentFinish[\"returnValues\"],\n    _steps: AgentStep[]\n  ): Promise<AgentFinish[\"returnValues\"]> {\n    return {};\n  }\n}\n\n/**\n * Abstract base class for single action agents in LangChain. Extends the\n * BaseAgent class and provides additional functionality specific to\n * single action agents.\n */\nexport abstract class BaseSingleActionAgent extends BaseAgent {\n  _agentActionType(): string {\n    return \"single\" as const;\n  }\n\n  /**\n   * Decide what to do, given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  abstract plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction | AgentFinish>;\n}\n\n/**\n * Abstract base class for multi-action agents in LangChain. Extends the\n * BaseAgent class and provides additional functionality specific to\n * multi-action agents.\n */\nexport abstract class BaseMultiActionAgent extends BaseAgent {\n  _agentActionType(): string {\n    return \"multi\" as const;\n  }\n\n  /**\n   * Decide what to do, given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager.\n   *\n   * @returns Actions specifying what tools to use.\n   */\n  abstract plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction[] | AgentFinish>;\n}\n\nfunction isAgentAction(input: unknown): input is AgentAction {\n  return !Array.isArray(input) && (input as AgentAction)?.tool !== undefined;\n}\n\nexport function isRunnableAgent(x: BaseAgent) {\n  return (\n    (x as RunnableMultiActionAgent | RunnableSingleActionAgent).runnable !==\n    undefined\n  );\n}\n\n// TODO: Remove in the future. Only for backwards compatibility.\n// Allows for the creation of runnables with properties that will\n// be passed to the agent executor constructor.\nexport class AgentRunnableSequence<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n> extends RunnableSequence<RunInput, RunOutput> {\n  streamRunnable?: boolean;\n\n  singleAction: boolean;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromRunnables<RunInput = any, RunOutput = any>(\n    [first, ...runnables]: [\n      RunnableLike<RunInput>,\n      ...RunnableLike[],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      RunnableLike<any, RunOutput>,\n    ],\n    config: { singleAction: boolean; streamRunnable?: boolean; name?: string }\n  ): AgentRunnableSequence<RunInput, Exclude<RunOutput, Error>> {\n    const sequence = RunnableSequence.from(\n      [first, ...runnables],\n      config.name\n    ) as AgentRunnableSequence<RunInput, Exclude<RunOutput, Error>>;\n    sequence.singleAction = config.singleAction;\n    sequence.streamRunnable = config.streamRunnable;\n    return sequence;\n  }\n\n  static isAgentRunnableSequence(x: Runnable): x is AgentRunnableSequence {\n    return typeof (x as AgentRunnableSequence).singleAction === \"boolean\";\n  }\n}\n\n/**\n * Class representing a single-action agent powered by runnables.\n * Extends the BaseSingleActionAgent class and provides methods for\n * planning agent actions with runnables.\n */\nexport class RunnableSingleActionAgent extends BaseSingleActionAgent {\n  lc_namespace = [\"langchain\", \"agents\", \"runnable\"];\n\n  runnable: Runnable<\n    ChainValues & { steps: AgentStep[] },\n    AgentAction | AgentFinish\n  >;\n\n  get inputKeys(): string[] {\n    return [];\n  }\n\n  /**\n   * Whether to stream from the runnable or not.\n   * If true, the underlying LLM is invoked in a streaming fashion to make it\n   * possible to get access to the individual LLM tokens when using\n   * `streamLog` with the Agent Executor. If false then LLM is invoked in a\n   * non-streaming fashion and individual LLM tokens will not be available\n   * in `streamLog`.\n   *\n   * Note that the runnable should still only stream a single action or\n   * finish chunk.\n   */\n  streamRunnable = true;\n\n  defaultRunName = \"RunnableAgent\";\n\n  constructor(fields: RunnableSingleActionAgentInput) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.defaultRunName =\n      fields.defaultRunName ?? this.runnable.name ?? this.defaultRunName;\n    this.streamRunnable = fields.streamRunnable ?? this.streamRunnable;\n  }\n\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction | AgentFinish> {\n    const combinedInput = { ...inputs, steps };\n    const combinedConfig = patchConfig(config, {\n      callbacks: callbackManager,\n      runName: this.defaultRunName,\n    });\n    if (this.streamRunnable) {\n      const stream = await this.runnable.stream(combinedInput, combinedConfig);\n      let finalOutput: AgentAction | AgentFinish | undefined;\n      for await (const chunk of stream) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          throw new Error(\n            [\n              `Multiple agent actions/finishes received in streamed agent output.`,\n              `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n            ].join(\"\\n\")\n          );\n        }\n      }\n      if (finalOutput === undefined) {\n        throw new Error(\n          [\n            \"No streaming output received from underlying runnable.\",\n            `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n          ].join(\"\\n\")\n        );\n      }\n      return finalOutput;\n    } else {\n      return this.runnable.invoke(combinedInput, combinedConfig);\n    }\n  }\n}\n\n/**\n * Class representing a multi-action agent powered by runnables.\n * Extends the BaseMultiActionAgent class and provides methods for\n * planning agent actions with runnables.\n */\nexport class RunnableMultiActionAgent extends BaseMultiActionAgent {\n  lc_namespace = [\"langchain\", \"agents\", \"runnable\"];\n\n  // TODO: Rename input to \"intermediate_steps\"\n  runnable: Runnable<\n    ChainValues & { steps: AgentStep[] },\n    AgentAction[] | AgentAction | AgentFinish\n  >;\n\n  defaultRunName = \"RunnableAgent\";\n\n  stop?: string[];\n\n  streamRunnable = true;\n\n  get inputKeys(): string[] {\n    return [];\n  }\n\n  constructor(fields: RunnableMultiActionAgentInput) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.stop = fields.stop;\n    this.defaultRunName =\n      fields.defaultRunName ?? this.runnable.name ?? this.defaultRunName;\n    this.streamRunnable = fields.streamRunnable ?? this.streamRunnable;\n  }\n\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction[] | AgentFinish> {\n    const combinedInput = { ...inputs, steps };\n    const combinedConfig = patchConfig(config, {\n      callbacks: callbackManager,\n      runName: this.defaultRunName,\n    });\n    let output;\n    if (this.streamRunnable) {\n      const stream = await this.runnable.stream(combinedInput, combinedConfig);\n      let finalOutput: AgentAction | AgentFinish | AgentAction[] | undefined;\n      for await (const chunk of stream) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          throw new Error(\n            [\n              `Multiple agent actions/finishes received in streamed agent output.`,\n              `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n            ].join(\"\\n\")\n          );\n        }\n      }\n      if (finalOutput === undefined) {\n        throw new Error(\n          [\n            \"No streaming output received from underlying runnable.\",\n            `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n          ].join(\"\\n\")\n        );\n      }\n      output = finalOutput;\n    } else {\n      output = await this.runnable.invoke(combinedInput, combinedConfig);\n    }\n\n    if (isAgentAction(output)) {\n      return [output];\n    }\n\n    return output;\n  }\n}\n\nexport class RunnableAgent extends RunnableMultiActionAgent {}\n\n/**\n * Interface for input data for creating a LLMSingleActionAgent.\n */\nexport interface LLMSingleActionAgentInput {\n  llmChain: LLMChain;\n  outputParser: AgentActionOutputParser;\n  stop?: string[];\n}\n\n/**\n * Class representing a single action agent using a LLMChain in LangChain.\n * Extends the BaseSingleActionAgent class and provides methods for\n * planning agent actions based on LLMChain outputs.\n * @example\n * ```typescript\n * const customPromptTemplate = new CustomPromptTemplate({\n *   tools: [new Calculator()],\n *   inputVariables: [\"input\", \"agent_scratchpad\"],\n * });\n * const customOutputParser = new CustomOutputParser();\n * const agent = new LLMSingleActionAgent({\n *   llmChain: new LLMChain({\n *     prompt: customPromptTemplate,\n *     llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0 }),\n *   }),\n *   outputParser: customOutputParser,\n *   stop: [\"\\nObservation\"],\n * });\n * const executor = new AgentExecutor({\n *   agent,\n *   tools: [new Calculator()],\n * });\n * const result = await executor.invoke({\n *   input:\n *     \"Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?\",\n * });\n * ```\n */\nexport class LLMSingleActionAgent extends BaseSingleActionAgent {\n  lc_namespace = [\"langchain\", \"agents\"];\n\n  llmChain: LLMChain;\n\n  outputParser: AgentActionOutputParser;\n\n  stop?: string[];\n\n  constructor(input: LLMSingleActionAgentInput) {\n    super(input);\n    this.stop = input.stop;\n    this.llmChain = input.llmChain;\n    this.outputParser = input.outputParser;\n  }\n\n  get inputKeys(): string[] {\n    return this.llmChain.inputKeys;\n  }\n\n  /**\n   * Decide what to do given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    const output = await this.llmChain.call(\n      {\n        intermediate_steps: steps,\n        stop: this.stop,\n        ...inputs,\n      },\n      callbackManager\n    );\n    return this.outputParser.parse(\n      output[this.llmChain.outputKey],\n      callbackManager\n    );\n  }\n}\n\n/**\n * Interface for arguments used to create an agent in LangChain.\n */\nexport interface AgentArgs {\n  outputParser?: AgentActionOutputParser;\n\n  callbacks?: Callbacks;\n\n  /**\n   * @deprecated Use `callbacks` instead.\n   */\n  callbackManager?: CallbackManager;\n}\n\n/**\n * Class responsible for calling a language model and deciding an action.\n *\n * @remarks This is driven by an LLMChain. The prompt in the LLMChain *must*\n * include a variable called \"agent_scratchpad\" where the agent can put its\n * intermediary work.\n */\nexport abstract class Agent extends BaseSingleActionAgent {\n  llmChain: LLMChain;\n\n  outputParser: AgentActionOutputParser | undefined;\n\n  private _allowedTools?: string[] = undefined;\n\n  get allowedTools(): string[] | undefined {\n    return this._allowedTools;\n  }\n\n  get inputKeys(): string[] {\n    return this.llmChain.inputKeys.filter((k) => k !== \"agent_scratchpad\");\n  }\n\n  constructor(input: AgentInput) {\n    super(input);\n\n    this.llmChain = input.llmChain;\n    this._allowedTools = input.allowedTools;\n    this.outputParser = input.outputParser;\n  }\n\n  /**\n   * Prefix to append the observation with.\n   */\n  abstract observationPrefix(): string;\n\n  /**\n   * Prefix to append the LLM call with.\n   */\n  abstract llmPrefix(): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of agent.\n   */\n  abstract _agentType(): string;\n\n  /**\n   * Get the default output parser for this agent.\n   */\n  static getDefaultOutputParser(\n    _fields?: OutputParserArgs\n  ): AgentActionOutputParser {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Create a prompt for this class\n   *\n   * @param _tools - List of tools the agent will have access to, used to format the prompt.\n   * @param _fields - Additional fields used to format the prompt.\n   *\n   * @returns A PromptTemplate assembled from the given tools and fields.\n   * */\n  static createPrompt(\n    _tools: StructuredToolInterface[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _fields?: Record<string, any>\n  ): BasePromptTemplate {\n    throw new Error(\"Not implemented\");\n  }\n\n  /** Construct an agent from an LLM and a list of tools */\n  static fromLLMAndTools(\n    _llm: BaseLanguageModelInterface,\n    _tools: StructuredToolInterface[],\n\n    _args?: AgentArgs\n  ): Agent {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Validate that appropriate tools are passed in\n   */\n  static validateTools(_tools: StructuredToolInterface[]): void {}\n\n  _stop(): string[] {\n    return [`\\n${this.observationPrefix()}`];\n  }\n\n  /**\n   * Name of tool to use to terminate the chain.\n   */\n  finishToolName(): string {\n    return \"Final Answer\";\n  }\n\n  /**\n   * Construct a scratchpad to let the agent continue its thought process\n   */\n  async constructScratchPad(\n    steps: AgentStep[]\n  ): Promise<string | BaseMessage[]> {\n    return steps.reduce(\n      (thoughts, { action, observation }) =>\n        thoughts +\n        [\n          action.log,\n          `${this.observationPrefix()}${observation}`,\n          this.llmPrefix(),\n        ].join(\"\\n\"),\n      \"\"\n    );\n  }\n\n  private async _plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    suffix?: string,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    const thoughts = await this.constructScratchPad(steps);\n    const newInputs: ChainValues = {\n      ...inputs,\n      agent_scratchpad: suffix ? `${thoughts}${suffix}` : thoughts,\n    };\n\n    if (this._stop().length !== 0) {\n      newInputs.stop = this._stop();\n    }\n\n    const output = await this.llmChain.predict(newInputs, callbackManager);\n    if (!this.outputParser) {\n      throw new Error(\"Output parser not set\");\n    }\n    return this.outputParser.parse(output, callbackManager);\n  }\n\n  /**\n   * Decide what to do given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager to use for this call.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    return this._plan(steps, inputs, undefined, callbackManager);\n  }\n\n  /**\n   * Return response when agent has been stopped due to max iterations\n   */\n  async returnStoppedResponse(\n    earlyStoppingMethod: StoppingMethod,\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentFinish> {\n    if (earlyStoppingMethod === \"force\") {\n      return {\n        returnValues: { output: \"Agent stopped due to max iterations.\" },\n        log: \"\",\n      };\n    }\n\n    if (earlyStoppingMethod === \"generate\") {\n      try {\n        const action = await this._plan(\n          steps,\n          inputs,\n          \"\\n\\nI now need to return a final answer based on the previous steps:\",\n          callbackManager\n        );\n        if (\"returnValues\" in action) {\n          return action;\n        }\n\n        return { returnValues: { output: action.log }, log: action.log };\n      } catch (err) {\n        // fine to use instanceof because we're in the same module\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!(err instanceof ParseError)) {\n          throw err;\n        }\n        return { returnValues: { output: err.output }, log: err.output };\n      }\n    }\n\n    throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n  }\n\n  /**\n   * Load an agent from a json-like object describing it.\n   */\n  static async deserialize(\n    data: SerializedAgent & {\n      llm?: BaseLanguageModelInterface;\n      tools?: ToolInterface[];\n    }\n  ): Promise<Agent> {\n    switch (data._type) {\n      case \"zero-shot-react-description\": {\n        const { ZeroShotAgent } = await import(\"./mrkl/index.js\");\n        return ZeroShotAgent.deserialize(data);\n      }\n      default:\n        throw new Error(\"Unknown agent type\");\n    }\n  }\n}\n"],"mappings":";;;;;;;;AAsCA,IAAM,aAAN,cAAyB,MAAM;CAC7B;CAEA,YAAYA,KAAaC,QAAgB;EACvC,MAAM,IAAI;EACV,KAAK,SAAS;CACf;AACF;;;;;AAMD,IAAsB,YAAtB,cAAwC,aAAa;CAKnD,IAAI,eAAyB;AAC3B,SAAO,CAAC,QAAS;CAClB;CAED,IAAI,eAAqC;AACvC,SAAO;CACR;;;;CAKD,aAAqB;AACnB,QAAM,IAAI,MAAM;CACjB;;;;CAUD,sBACEC,qBACAC,QACAC,SACAC,kBACsB;AACtB,MAAI,wBAAwB,QAC1B,QAAO,QAAQ,QAAQ;GACrB,cAAc,EAAE,QAAQ,uCAAwC;GAChE,KAAK;EACN,EAAC;AAGJ,QAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,qBAAqB;CAClE;;;;CAKD,MAAM,iBACJC,eACAH,QACsC;AACtC,SAAO,CAAE;CACV;AACF;;;;;;AAOD,IAAsB,wBAAtB,cAAoD,UAAU;CAC5D,mBAA2B;AACzB,SAAO;CACR;AAiBF;;;;;;AAOD,IAAsB,uBAAtB,cAAmD,UAAU;CAC3D,mBAA2B;AACzB,SAAO;CACR;AAiBF;AAED,SAAS,cAAcI,OAAsC;AAC3D,QAAO,CAAC,MAAM,QAAQ,MAAM,IAAK,OAAuB,SAAS;AAClE;AAED,SAAgB,gBAAgBC,GAAc;AAC5C,QACG,EAA2D,aAC5D;AAEH;AAKD,IAAa,wBAAb,cAKU,iBAAsC;CAC9C;CAEA;CAGA,OAAO,cACL,CAAC,OAAO,GAAG,UAKV,EACDC,QAC4D;EAC5D,MAAM,WAAW,iBAAiB,KAChC,CAAC,OAAO,GAAG,SAAU,GACrB,OAAO,KACR;EACD,SAAS,eAAe,OAAO;EAC/B,SAAS,iBAAiB,OAAO;AACjC,SAAO;CACR;CAED,OAAO,wBAAwBC,GAAyC;AACtE,SAAO,OAAQ,EAA4B,iBAAiB;CAC7D;AACF;;;;;;AAOD,IAAa,4BAAb,cAA+C,sBAAsB;CACnE,eAAe;EAAC;EAAa;EAAU;CAAW;CAElD;CAKA,IAAI,YAAsB;AACxB,SAAO,CAAE;CACV;;;;;;;;;;;;CAaD,iBAAiB;CAEjB,iBAAiB;CAEjB,YAAYC,QAAwC;EAClD,MAAM,OAAO;EACb,KAAK,WAAW,OAAO;EACvB,KAAK,iBACH,OAAO,kBAAkB,KAAK,SAAS,QAAQ,KAAK;EACtD,KAAK,iBAAiB,OAAO,kBAAkB,KAAK;CACrD;CAED,MAAM,KACJC,OACAC,QACAC,iBACAC,QACoC;EACpC,MAAM,gBAAgB;GAAE,GAAG;GAAQ;EAAO;EAC1C,MAAM,iBAAiB,YAAY,QAAQ;GACzC,WAAW;GACX,SAAS,KAAK;EACf,EAAC;AACF,MAAI,KAAK,gBAAgB;GACvB,MAAM,SAAS,MAAM,KAAK,SAAS,OAAO,eAAe,eAAe;GACxE,IAAIC;AACJ,cAAW,MAAM,SAAS,OACxB,KAAI,gBAAgB,QAClB,cAAc;OAEd,OAAM,IAAI,MACR,CACE,CAAC,kEAAkE,CAAC,EACpE,CAAC,mGAAmG,CAAC,AACtG,EAAC,KAAK,KAAK;AAIlB,OAAI,gBAAgB,OAClB,OAAM,IAAI,MACR,CACE,0DACA,CAAC,mGAAmG,CAAC,AACtG,EAAC,KAAK,KAAK;AAGhB,UAAO;EACR,MACC,QAAO,KAAK,SAAS,OAAO,eAAe,eAAe;CAE7D;AACF;;;;;;AAOD,IAAa,2BAAb,cAA8C,qBAAqB;CACjE,eAAe;EAAC;EAAa;EAAU;CAAW;CAGlD;CAKA,iBAAiB;CAEjB;CAEA,iBAAiB;CAEjB,IAAI,YAAsB;AACxB,SAAO,CAAE;CACV;CAED,YAAYC,QAAuC;EACjD,MAAM,OAAO;EACb,KAAK,WAAW,OAAO;EACvB,KAAK,OAAO,OAAO;EACnB,KAAK,iBACH,OAAO,kBAAkB,KAAK,SAAS,QAAQ,KAAK;EACtD,KAAK,iBAAiB,OAAO,kBAAkB,KAAK;CACrD;CAED,MAAM,KACJL,OACAC,QACAC,iBACAC,QACsC;EACtC,MAAM,gBAAgB;GAAE,GAAG;GAAQ;EAAO;EAC1C,MAAM,iBAAiB,YAAY,QAAQ;GACzC,WAAW;GACX,SAAS,KAAK;EACf,EAAC;EACF,IAAI;AACJ,MAAI,KAAK,gBAAgB;GACvB,MAAM,SAAS,MAAM,KAAK,SAAS,OAAO,eAAe,eAAe;GACxE,IAAIG;AACJ,cAAW,MAAM,SAAS,OACxB,KAAI,gBAAgB,QAClB,cAAc;OAEd,OAAM,IAAI,MACR,CACE,CAAC,kEAAkE,CAAC,EACpE,CAAC,mGAAmG,CAAC,AACtG,EAAC,KAAK,KAAK;AAIlB,OAAI,gBAAgB,OAClB,OAAM,IAAI,MACR,CACE,0DACA,CAAC,mGAAmG,CAAC,AACtG,EAAC,KAAK,KAAK;GAGhB,SAAS;EACV,OACC,SAAS,MAAM,KAAK,SAAS,OAAO,eAAe,eAAe;AAGpE,MAAI,cAAc,OAAO,CACvB,QAAO,CAAC,MAAO;AAGjB,SAAO;CACR;AACF;AAED,IAAa,gBAAb,cAAmC,yBAAyB,CAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwC9D,IAAa,uBAAb,cAA0C,sBAAsB;CAC9D,eAAe,CAAC,aAAa,QAAS;CAEtC;CAEA;CAEA;CAEA,YAAYC,OAAkC;EAC5C,MAAM,MAAM;EACZ,KAAK,OAAO,MAAM;EAClB,KAAK,WAAW,MAAM;EACtB,KAAK,eAAe,MAAM;CAC3B;CAED,IAAI,YAAsB;AACxB,SAAO,KAAK,SAAS;CACtB;;;;;;;;;;CAWD,MAAM,KACJP,OACAC,QACAC,iBACoC;EACpC,MAAM,SAAS,MAAM,KAAK,SAAS,KACjC;GACE,oBAAoB;GACpB,MAAM,KAAK;GACX,GAAG;EACJ,GACD,gBACD;AACD,SAAO,KAAK,aAAa,MACvB,OAAO,KAAK,SAAS,YACrB,gBACD;CACF;AACF;;;;;;;;AAuBD,IAAsB,QAAtB,cAAoC,sBAAsB;CACxD;CAEA;CAEA,AAAQ,gBAA2B;CAEnC,IAAI,eAAqC;AACvC,SAAO,KAAK;CACb;CAED,IAAI,YAAsB;AACxB,SAAO,KAAK,SAAS,UAAU,OAAO,CAAC,MAAM,MAAM,mBAAmB;CACvE;CAED,YAAYM,OAAmB;EAC7B,MAAM,MAAM;EAEZ,KAAK,WAAW,MAAM;EACtB,KAAK,gBAAgB,MAAM;EAC3B,KAAK,eAAe,MAAM;CAC3B;;;;CAoBD,OAAO,uBACLC,SACyB;AACzB,QAAM,IAAI,MAAM;CACjB;;;;;;;;;CAUD,OAAO,aACLC,QAEAC,SACoB;AACpB,QAAM,IAAI,MAAM;CACjB;;CAGD,OAAO,gBACLC,MACAF,QAEAG,OACO;AACP,QAAM,IAAI,MAAM;CACjB;;;;CAKD,OAAO,cAAcH,QAAyC,CAAE;CAEhE,QAAkB;AAChB,SAAO,CAAC,CAAC,EAAE,EAAE,KAAK,mBAAmB,EAAE,AAAC;CACzC;;;;CAKD,iBAAyB;AACvB,SAAO;CACR;;;;CAKD,MAAM,oBACJV,OACiC;AACjC,SAAO,MAAM,OACX,CAAC,UAAU,EAAE,QAAQ,aAAa,KAChC,WACA;GACE,OAAO;GACP,GAAG,KAAK,mBAAmB,GAAG,aAAa;GAC3C,KAAK,WAAW;EACjB,EAAC,KAAK,KAAK,EACd,GACD;CACF;CAED,MAAc,MACZA,OACAC,QACAa,QACAZ,iBACoC;EACpC,MAAM,WAAW,MAAM,KAAK,oBAAoB,MAAM;EACtD,MAAMa,YAAyB;GAC7B,GAAG;GACH,kBAAkB,SAAS,GAAG,WAAW,QAAQ,GAAG;EACrD;AAED,MAAI,KAAK,OAAO,CAAC,WAAW,GAC1B,UAAU,OAAO,KAAK,OAAO;EAG/B,MAAM,SAAS,MAAM,KAAK,SAAS,QAAQ,WAAW,gBAAgB;AACtE,MAAI,CAAC,KAAK,aACR,OAAM,IAAI,MAAM;AAElB,SAAO,KAAK,aAAa,MAAM,QAAQ,gBAAgB;CACxD;;;;;;;;;;CAWD,KACEf,OACAC,QACAC,iBACoC;AACpC,SAAO,KAAK,MAAM,OAAO,QAAQ,QAAW,gBAAgB;CAC7D;;;;CAKD,MAAM,sBACJZ,qBACAU,OACAC,QACAC,iBACsB;AACtB,MAAI,wBAAwB,QAC1B,QAAO;GACL,cAAc,EAAE,QAAQ,uCAAwC;GAChE,KAAK;EACN;AAGH,MAAI,wBAAwB,WAC1B,KAAI;GACF,MAAM,SAAS,MAAM,KAAK,MACxB,OACA,QACA,wEACA,gBACD;AACD,OAAI,kBAAkB,OACpB,QAAO;AAGT,UAAO;IAAE,cAAc,EAAE,QAAQ,OAAO,IAAK;IAAE,KAAK,OAAO;GAAK;EACjE,SAAQ,KAAK;AAGZ,OAAI,EAAE,eAAe,YACnB,OAAM;AAER,UAAO;IAAE,cAAc,EAAE,QAAQ,IAAI,OAAQ;IAAE,KAAK,IAAI;GAAQ;EACjE;AAGH,QAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,qBAAqB;CAClE;;;;CAKD,aAAa,YACXc,MAIgB;AAChB,UAAQ,KAAK,OAAb;GACE,KAAK,+BAA+B;IAClC,MAAM,EAAE,eAAe,GAAG,MAAM,OAAO;AACvC,WAAO,cAAc,YAAY,KAAK;GACvC;GACD,QACE,OAAM,IAAI,MAAM;EACnB;CACF;AACF"}