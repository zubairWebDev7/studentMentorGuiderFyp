{"version":3,"file":"openapi.cjs","names":["schema: OpenAPIV3_1.SchemaObject","url: string","pathParams: Record<string, string>","newParams: Record<string, string>","params: OpenAPIV3_1.ParameterObject[]","spec: OpenAPISpec","jsonSchema: JsonSchema7ObjectType","nameToCallMap: Record<string, { method: string; url: string }>","operationParams: Record<string, OpenAPIV3_1.ParameterObject[]>","paramLocationToRequestArgNameMap: Record<string, string>","requestArgsSchema: Record<string, JsonSchema7ObjectType> & {\n        data?:\n          | JsonSchema7ObjectType\n          | {\n              anyOf?: JsonSchema7ObjectType[];\n            };\n      }","requestBodySchemas: Record<string, JsonSchema7ObjectType>","openAIFunction: OpenAIClient.Chat.ChatCompletionCreateParams.Function","OpenAPISpec","name: string","requestArgs: Record<string, any>","options?: {\n        headers?: Record<string, string>;\n        params?: Record<string, string>;\n      }","filteredArgs: Record<string, any>","headers: Record<string, string>","BaseChain","config: { requestMethod: SimpleRequestChainExecutionMethod }","values: ChainValues","_runManager?: CallbackManagerForChainRun","spec: OpenAPIV3_1.Document | string","options: OpenAPIChainOptions","ChatPromptTemplate","HumanMessagePromptTemplate","LLMChain","JsonOutputFunctionsParser","SequentialChain"],"sources":["../../../src/chains/openai_functions/openapi.ts"],"sourcesContent":["import type { OpenAIClient } from \"@langchain/openai\";\nimport {\n  type JsonSchema7ObjectType,\n  type JsonSchema7ArrayType,\n  type JsonSchema7Type,\n} from \"@langchain/core/utils/json_schema\";\nimport type { OpenAPIV3_1 } from \"openapi-types\";\n\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\nimport { BaseFunctionCallOptions } from \"@langchain/core/language_models/base\";\nimport {\n  ChatPromptTemplate,\n  HumanMessagePromptTemplate,\n  BasePromptTemplate,\n} from \"@langchain/core/prompts\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { OpenAPISpec } from \"../../util/openapi.js\";\nimport { BaseChain } from \"../base.js\";\nimport { LLMChain, LLMChainInput } from \"../llm_chain.js\";\nimport { SequentialChain } from \"../sequential_chain.js\";\nimport { JsonOutputFunctionsParser } from \"../../output_parsers/openai_functions.js\";\n\n/**\n * Type representing a function for executing OpenAPI requests.\n */\ntype OpenAPIExecutionMethod = (\n  name: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  requestArgs: Record<string, any>,\n  options?: {\n    headers?: Record<string, string>;\n    params?: Record<string, string>;\n  }\n) => Promise<string>;\n\n/**\n * Type representing the composition types of a schema.\n */\ntype CompositionType = \"anyOf\" | \"allOf\" | \"oneOf\";\n\n/**\n * Gets the composition type of a schema if it exists.\n * @param schema\n * @returns The composition type of the schema if it exists.\n */\nfunction getCompositionType(\n  schema: OpenAPIV3_1.SchemaObject\n): CompositionType | undefined {\n  if (schema.anyOf !== undefined) {\n    return \"anyOf\";\n  }\n  if (schema.allOf !== undefined) {\n    return \"allOf\";\n  }\n  if (schema.oneOf !== undefined) {\n    return \"oneOf\";\n  }\n  return undefined;\n}\n\n/**\n * Formats a URL by replacing path parameters with their corresponding\n * values.\n * @param url The URL to format.\n * @param pathParams The path parameters to replace in the URL.\n * @returns The formatted URL.\n */\nfunction formatURL(url: string, pathParams: Record<string, string>): string {\n  const expectedPathParamNames = [...url.matchAll(/{(.*?)}/g)].map(\n    (match) => match[1]\n  );\n  const newParams: Record<string, string> = {};\n  for (const paramName of expectedPathParamNames) {\n    const cleanParamName = paramName.replace(/^\\.;/, \"\").replace(/\\*$/, \"\");\n    const value = pathParams[cleanParamName];\n    let formattedValue;\n    if (Array.isArray(value)) {\n      if (paramName.startsWith(\".\")) {\n        const separator = paramName.endsWith(\"*\") ? \".\" : \",\";\n        formattedValue = `.${value.join(separator)}`;\n      } else if (paramName.startsWith(\",\")) {\n        const separator = paramName.endsWith(\"*\") ? `${cleanParamName}=` : \",\";\n        formattedValue = `${cleanParamName}=${value.join(separator)}`;\n      } else {\n        formattedValue = value.join(\",\");\n      }\n    } else if (typeof value === \"object\") {\n      const kvSeparator = paramName.endsWith(\"*\") ? \"=\" : \",\";\n      const kvStrings = Object.entries(value).map(\n        ([k, v]) => k + kvSeparator + v\n      );\n      let entrySeparator;\n      if (paramName.startsWith(\".\")) {\n        entrySeparator = \".\";\n        formattedValue = \".\";\n      } else if (paramName.startsWith(\";\")) {\n        entrySeparator = \";\";\n        formattedValue = \";\";\n      } else {\n        entrySeparator = \",\";\n        formattedValue = \"\";\n      }\n      formattedValue += kvStrings.join(entrySeparator);\n    } else {\n      if (paramName.startsWith(\".\")) {\n        formattedValue = `.${value}`;\n      } else if (paramName.startsWith(\";\")) {\n        formattedValue = `;${cleanParamName}=${value}`;\n      } else {\n        formattedValue = value;\n      }\n    }\n    newParams[paramName] = formattedValue;\n  }\n  let formattedUrl = url;\n  for (const [key, newValue] of Object.entries(newParams)) {\n    formattedUrl = formattedUrl.replace(`{${key}}`, newValue);\n  }\n  return formattedUrl;\n}\n\n/**\n * Converts OpenAPI parameters to JSON schema format.\n * @param params The OpenAPI parameters to convert.\n * @param spec The OpenAPI specification that contains the parameters.\n * @returns The JSON schema representation of the OpenAPI parameters.\n */\nfunction convertOpenAPIParamsToJSONSchema(\n  params: OpenAPIV3_1.ParameterObject[],\n  spec: OpenAPISpec\n) {\n  return params.reduce(\n    (jsonSchema: JsonSchema7ObjectType, param) => {\n      let schema;\n      if (param.schema) {\n        schema = spec.getSchema(param.schema);\n        jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(\n          schema,\n          spec\n        );\n      } else if (param.content) {\n        const mediaTypeSchema = Object.values(param.content)[0].schema;\n        if (mediaTypeSchema) {\n          schema = spec.getSchema(mediaTypeSchema);\n        }\n        if (!schema) {\n          return jsonSchema;\n        }\n        if (schema.description === undefined) {\n          schema.description = param.description ?? \"\";\n        }\n        jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(\n          schema,\n          spec\n        );\n      } else {\n        return jsonSchema;\n      }\n      if (param.required && Array.isArray(jsonSchema.required)) {\n        jsonSchema.required.push(param.name);\n      }\n      return jsonSchema;\n    },\n    {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: {},\n    }\n  );\n}\n\n// OpenAI throws errors on extraneous schema properties, e.g. if \"required\" is set on individual ones\n/**\n * Converts OpenAPI schemas to JSON schema format.\n * @param schema The OpenAPI schema to convert.\n * @param spec The OpenAPI specification that contains the schema.\n * @returns The JSON schema representation of the OpenAPI schema.\n */\nexport function convertOpenAPISchemaToJSONSchema(\n  schema: OpenAPIV3_1.SchemaObject,\n  spec: OpenAPISpec\n): JsonSchema7Type {\n  const compositionType = getCompositionType(schema);\n  if (compositionType !== undefined && schema[compositionType] !== undefined) {\n    return {\n      [compositionType]: schema[compositionType].map((s) =>\n        convertOpenAPISchemaToJSONSchema(spec.getSchema(s), spec)\n      ),\n    } as JsonSchema7Type;\n  }\n\n  if (schema.type === \"object\") {\n    return Object.keys(schema.properties ?? {}).reduce(\n      (jsonSchema: JsonSchema7ObjectType, propertyName) => {\n        if (!schema.properties) {\n          return jsonSchema;\n        }\n        const openAPIProperty = spec.getSchema(schema.properties[propertyName]);\n        if (openAPIProperty.type === undefined) {\n          return jsonSchema;\n        }\n        jsonSchema.properties[propertyName] = convertOpenAPISchemaToJSONSchema(\n          openAPIProperty,\n          spec\n        );\n        if (\n          schema.required?.includes(propertyName) &&\n          jsonSchema.required !== undefined\n        ) {\n          jsonSchema.required.push(propertyName);\n        }\n        return jsonSchema;\n      },\n      {\n        type: \"object\",\n        properties: {},\n        required: [],\n        additionalProperties: {},\n      }\n    );\n  }\n\n  if (schema.type === \"array\") {\n    const openAPIItems = spec.getSchema(schema.items ?? {});\n    return {\n      type: \"array\",\n      items: convertOpenAPISchemaToJSONSchema(openAPIItems, spec),\n      minItems: schema.minItems,\n      maxItems: schema.maxItems,\n    } as JsonSchema7ArrayType;\n  }\n  return {\n    type: schema.type ?? \"string\",\n  } as JsonSchema7Type;\n}\n\n/**\n * Converts an OpenAPI specification to OpenAI functions.\n * @param spec The OpenAPI specification to convert.\n * @returns An object containing the OpenAI functions derived from the OpenAPI specification and a default execution method.\n */\nexport function convertOpenAPISpecToOpenAIFunctions(spec: OpenAPISpec): {\n  openAIFunctions: OpenAIClient.Chat.ChatCompletionCreateParams.Function[];\n  defaultExecutionMethod?: OpenAPIExecutionMethod;\n} {\n  if (!spec.document.paths) {\n    return { openAIFunctions: [] };\n  }\n  const openAIFunctions = [];\n  const nameToCallMap: Record<string, { method: string; url: string }> = {};\n  for (const path of Object.keys(spec.document.paths)) {\n    const pathParameters = spec.getParametersForPath(path);\n    for (const method of spec.getMethodsForPath(path)) {\n      const operation = spec.getOperation(path, method);\n      if (!operation) {\n        return { openAIFunctions: [] };\n      }\n      const operationParametersByLocation = pathParameters\n        .concat(spec.getParametersForOperation(operation))\n        .reduce(\n          (\n            operationParams: Record<string, OpenAPIV3_1.ParameterObject[]>,\n            param\n          ) => {\n            if (!operationParams[param.in]) {\n              operationParams[param.in] = [];\n            }\n            operationParams[param.in].push(param);\n            return operationParams;\n          },\n          {}\n        );\n      const paramLocationToRequestArgNameMap: Record<string, string> = {\n        query: \"params\",\n        header: \"headers\",\n        cookie: \"cookies\",\n        path: \"path_params\",\n      };\n      const requestArgsSchema: Record<string, JsonSchema7ObjectType> & {\n        data?:\n          | JsonSchema7ObjectType\n          | {\n              anyOf?: JsonSchema7ObjectType[];\n            };\n      } = {};\n      for (const paramLocation of Object.keys(\n        paramLocationToRequestArgNameMap\n      )) {\n        if (operationParametersByLocation[paramLocation]) {\n          requestArgsSchema[paramLocationToRequestArgNameMap[paramLocation]] =\n            convertOpenAPIParamsToJSONSchema(\n              operationParametersByLocation[paramLocation],\n              spec\n            );\n        }\n      }\n      const requestBody = spec.getRequestBodyForOperation(operation);\n      if (requestBody?.content !== undefined) {\n        const requestBodySchemas: Record<string, JsonSchema7ObjectType> = {};\n        for (const [mediaType, mediaTypeObject] of Object.entries(\n          requestBody.content\n        )) {\n          if (mediaTypeObject.schema !== undefined) {\n            const schema = spec.getSchema(mediaTypeObject.schema);\n            requestBodySchemas[mediaType] = convertOpenAPISchemaToJSONSchema(\n              schema,\n              spec\n            ) as JsonSchema7ObjectType;\n          }\n        }\n        const mediaTypes = Object.keys(requestBodySchemas);\n        if (mediaTypes.length === 1) {\n          requestArgsSchema.data = requestBodySchemas[mediaTypes[0]];\n        } else if (mediaTypes.length > 1) {\n          requestArgsSchema.data = {\n            anyOf: Object.values(requestBodySchemas),\n          };\n        }\n      }\n      const openAIFunction: OpenAIClient.Chat.ChatCompletionCreateParams.Function =\n        {\n          name: OpenAPISpec.getCleanedOperationId(operation, path, method),\n          description: operation.description ?? operation.summary ?? \"\",\n          parameters: {\n            type: \"object\",\n            properties: requestArgsSchema,\n            // All remaining top-level parameters are required\n            required: Object.keys(requestArgsSchema),\n          },\n        };\n\n      openAIFunctions.push(openAIFunction);\n      const baseUrl = (spec.baseUrl ?? \"\").endsWith(\"/\")\n        ? (spec.baseUrl ?? \"\").slice(0, -1)\n        : (spec.baseUrl ?? \"\");\n      nameToCallMap[openAIFunction.name] = {\n        method,\n        url: baseUrl + path,\n      };\n    }\n  }\n  return {\n    openAIFunctions,\n    defaultExecutionMethod: async (\n      name: string,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      requestArgs: Record<string, any>,\n      options?: {\n        headers?: Record<string, string>;\n        params?: Record<string, string>;\n      }\n    ) => {\n      const {\n        headers: customHeaders,\n        params: customParams,\n        ...rest\n      } = options ?? {};\n      const { method, url } = nameToCallMap[name];\n      const requestParams = requestArgs.params ?? {};\n      const nonEmptyParams = Object.keys(requestParams).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (filteredArgs: Record<string, any>, argName) => {\n          if (\n            requestParams[argName] !== \"\" &&\n            requestParams[argName] !== null &&\n            requestParams[argName] !== undefined\n          ) {\n            filteredArgs[argName] = requestParams[argName];\n          }\n          return filteredArgs;\n        },\n        {}\n      );\n      const queryString = new URLSearchParams({\n        ...nonEmptyParams,\n        ...customParams,\n      }).toString();\n      const pathParams = requestArgs.path_params;\n      const formattedUrl =\n        formatURL(url, pathParams) +\n        (queryString.length ? `?${queryString}` : \"\");\n      const headers: Record<string, string> = {};\n      let body;\n      if (requestArgs.data !== undefined) {\n        let contentType = \"text/plain\";\n        if (typeof requestArgs.data !== \"string\") {\n          if (typeof requestArgs.data === \"object\") {\n            contentType = \"application/json\";\n          }\n          body = JSON.stringify(requestArgs.data);\n        } else {\n          body = requestArgs.data;\n        }\n        headers[\"content-type\"] = contentType;\n      }\n      const response = await fetch(formattedUrl, {\n        ...requestArgs,\n        method,\n        headers: {\n          ...headers,\n          ...requestArgs.headers,\n          ...customHeaders,\n        },\n        body,\n        ...rest,\n      });\n      let output;\n      if (response.status < 200 || response.status > 299) {\n        output = `${response.status}: ${\n          response.statusText\n        } for ${name} called with ${JSON.stringify(queryString)}`;\n      } else {\n        output = await response.text();\n      }\n      return output;\n    },\n  };\n}\n\n/**\n * Type representing a function for executing simple requests.\n */\ntype SimpleRequestChainExecutionMethod = (\n  name: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  requestArgs: Record<string, any>\n) => Promise<string>;\n\n/**\n * A chain for making simple API requests.\n */\nclass SimpleRequestChain extends BaseChain {\n  static lc_name() {\n    return \"SimpleRequestChain\";\n  }\n\n  private requestMethod: SimpleRequestChainExecutionMethod;\n\n  inputKey = \"function\";\n\n  outputKey = \"response\";\n\n  constructor(config: { requestMethod: SimpleRequestChainExecutionMethod }) {\n    super();\n    this.requestMethod = config.requestMethod;\n  }\n\n  get inputKeys() {\n    return [this.inputKey];\n  }\n\n  get outputKeys() {\n    return [this.outputKey];\n  }\n\n  _chainType() {\n    return \"simple_request_chain\" as const;\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    _runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    const inputKeyValue = values[this.inputKey];\n    const methodName = inputKeyValue.name;\n    const args = inputKeyValue.arguments;\n    const response = await this.requestMethod(methodName, args);\n    return { [this.outputKey]: response };\n  }\n}\n\n/**\n * Type representing the options for creating an OpenAPI chain.\n */\nexport type OpenAPIChainOptions = {\n  llm?: BaseChatModel<BaseFunctionCallOptions>;\n  prompt?: BasePromptTemplate;\n  requestChain?: BaseChain;\n  llmChainInputs?: LLMChainInput;\n  headers?: Record<string, string>;\n  params?: Record<string, string>;\n  verbose?: boolean;\n};\n\n/**\n * Create a chain for querying an API from a OpenAPI spec.\n * @param spec OpenAPISpec or url/file/text string corresponding to one.\n * @param options Custom options passed into the chain\n * @returns OpenAPIChain\n */\nexport async function createOpenAPIChain(\n  spec: OpenAPIV3_1.Document | string,\n  options: OpenAPIChainOptions = {}\n) {\n  let convertedSpec;\n  if (typeof spec === \"string\") {\n    try {\n      convertedSpec = await OpenAPISpec.fromURL(spec);\n    } catch {\n      try {\n        convertedSpec = OpenAPISpec.fromString(spec);\n      } catch {\n        throw new Error(`Unable to parse spec from source ${spec}.`);\n      }\n    }\n  } else {\n    convertedSpec = OpenAPISpec.fromObject(spec);\n  }\n  const { openAIFunctions, defaultExecutionMethod } =\n    convertOpenAPISpecToOpenAIFunctions(convertedSpec);\n  if (defaultExecutionMethod === undefined) {\n    throw new Error(\n      `Could not parse any valid operations from the provided spec.`\n    );\n  }\n\n  if (!options.llm) {\n    throw new Error(\"`llm` option is required\");\n  }\n\n  const {\n    llm = options.llm,\n    prompt = ChatPromptTemplate.fromMessages([\n      HumanMessagePromptTemplate.fromTemplate(\n        \"Use the provided API's to respond to this user query:\\n\\n{query}\"\n      ),\n    ]),\n    requestChain = new SimpleRequestChain({\n      requestMethod: async (name, args) =>\n        defaultExecutionMethod(name, args, {\n          headers: options.headers,\n          params: options.params,\n        }),\n    }),\n    llmChainInputs = {},\n    verbose,\n    ...rest\n  } = options;\n  const formatChain = new LLMChain({\n    llm,\n    prompt,\n    outputParser: new JsonOutputFunctionsParser({ argsOnly: false }),\n    outputKey: \"function\",\n    llmKwargs: { functions: openAIFunctions },\n    ...llmChainInputs,\n  });\n  return new SequentialChain({\n    chains: [formatChain, requestChain],\n    outputVariables: [\"response\"],\n    inputVariables: formatChain.inputKeys,\n    verbose,\n    ...rest,\n  });\n}\n"],"mappings":"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"}