{"version":3,"file":"cassandra.js","names":["options: CassandraChatMessageHistoryOptions","storedMessages: StoredMessage[]","message: BaseMessage"],"sources":["../../../src/stores/message/cassandra.ts"],"sourcesContent":["import { BaseListChatMessageHistory } from \"@langchain/core/chat_history\";\nimport {\n  BaseMessage,\n  StoredMessage,\n  mapChatMessagesToStoredMessages,\n  mapStoredMessagesToChatMessages,\n} from \"@langchain/core/messages\";\n\nimport {\n  Column,\n  CassandraTable,\n  CassandraClientArgs,\n} from \"../../utils/cassandra.js\";\n\nexport interface CassandraChatMessageHistoryOptions extends CassandraClientArgs {\n  keyspace: string;\n  table: string;\n  sessionId: string;\n}\n\n/**\n * Class for storing chat message history within Cassandra. It extends the\n * BaseListChatMessageHistory class and provides methods to get, add, and\n * clear messages.\n * @example\n * ```typescript\n * const chatHistory = new CassandraChatMessageHistory({\n *   cloud: {\n *     secureConnectBundle: \"<path to your secure bundle>\",\n *   },\n *   credentials: {\n *     username: \"token\",\n *     password: \"<your Cassandra access token>\",\n *   },\n *   keyspace: \"langchain\",\n *   table: \"message_history\",\n *   sessionId: \"<some unique session identifier>\",\n * });\n *\n * const chain = new ConversationChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   memory: chatHistory,\n * });\n *\n * const response = await chain.invoke({\n *   input: \"What did I just say my name was?\",\n * });\n * console.log({ response });\n * ```\n */\nexport class CassandraChatMessageHistory extends BaseListChatMessageHistory {\n  lc_namespace = [\"langchain\", \"stores\", \"message\", \"cassandra\"];\n\n  private cassandraTable: CassandraTable;\n\n  private sessionId: string;\n\n  private options: CassandraChatMessageHistoryOptions;\n\n  private colSessionId: Column;\n\n  private colMessageTs: Column;\n\n  private colMessageType: Column;\n\n  private colData: Column;\n\n  constructor(options: CassandraChatMessageHistoryOptions) {\n    super();\n    this.sessionId = options.sessionId;\n    this.options = options;\n\n    this.colSessionId = { name: \"session_id\", type: \"text\", partition: true };\n    this.colMessageTs = { name: \"message_ts\", type: \"timestamp\" };\n    this.colMessageType = { name: \"message_type\", type: \"text\" };\n    this.colData = { name: \"data\", type: \"text\" };\n  }\n\n  /**\n   * Method to get all the messages stored in the Cassandra database.\n   * @returns Array of stored BaseMessage instances.\n   */\n  public async getMessages(): Promise<BaseMessage[]> {\n    await this.ensureTable();\n\n    const resultSet = await this.cassandraTable.select(\n      [this.colMessageType, this.colData],\n      [{ name: \"session_id\", value: this.sessionId }]\n    );\n\n    const storedMessages: StoredMessage[] = resultSet.rows.map((row) => ({\n      type: row.message_type,\n      data: JSON.parse(row.data),\n    }));\n\n    const baseMessages = mapStoredMessagesToChatMessages(storedMessages);\n    return baseMessages;\n  }\n\n  /**\n   * Method to add a new message to the Cassandra database.\n   * @param message The BaseMessage instance to add.\n   * @returns A promise that resolves when the message has been added.\n   */\n  public async addMessage(message: BaseMessage): Promise<void> {\n    await this.ensureTable();\n    const messages = mapChatMessagesToStoredMessages([message]);\n    const { type, data } = messages[0];\n\n    return this.cassandraTable\n      .upsert(\n        [[this.sessionId, type, Date.now(), JSON.stringify(data)]],\n        [\n          this.colSessionId,\n          this.colMessageType,\n          this.colMessageTs,\n          this.colData,\n        ]\n      )\n      .then(() => {});\n  }\n\n  /**\n   * Method to clear all the messages from the Cassandra database.\n   * @returns A promise that resolves when all messages have been cleared.\n   */\n  public async clear(): Promise<void> {\n    await this.ensureTable();\n    return this.cassandraTable\n      .delete({ name: this.colSessionId.name, value: this.sessionId })\n      .then(() => {});\n  }\n\n  /**\n   * Method to initialize the Cassandra database.\n   * @returns Promise that resolves when the database has been initialized.\n   */\n  private async ensureTable(): Promise<void> {\n    if (this.cassandraTable) {\n      return;\n    }\n\n    const tableConfig = {\n      ...this.options,\n      primaryKey: [this.colSessionId, this.colMessageTs],\n      nonKeyColumns: [this.colMessageType, this.colData],\n    };\n\n    this.cassandraTable = await new CassandraTable(tableConfig);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,IAAa,8BAAb,cAAiD,2BAA2B;CAC1E,eAAe;EAAC;EAAa;EAAU;EAAW;CAAY;CAE9D,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,YAAYA,SAA6C;EACvD,OAAO;EACP,KAAK,YAAY,QAAQ;EACzB,KAAK,UAAU;EAEf,KAAK,eAAe;GAAE,MAAM;GAAc,MAAM;GAAQ,WAAW;EAAM;EACzE,KAAK,eAAe;GAAE,MAAM;GAAc,MAAM;EAAa;EAC7D,KAAK,iBAAiB;GAAE,MAAM;GAAgB,MAAM;EAAQ;EAC5D,KAAK,UAAU;GAAE,MAAM;GAAQ,MAAM;EAAQ;CAC9C;;;;;CAMD,MAAa,cAAsC;EACjD,MAAM,KAAK,aAAa;EAExB,MAAM,YAAY,MAAM,KAAK,eAAe,OAC1C,CAAC,KAAK,gBAAgB,KAAK,OAAQ,GACnC,CAAC;GAAE,MAAM;GAAc,OAAO,KAAK;EAAW,CAAC,EAChD;EAED,MAAMC,iBAAkC,UAAU,KAAK,IAAI,CAAC,SAAS;GACnE,MAAM,IAAI;GACV,MAAM,KAAK,MAAM,IAAI,KAAK;EAC3B,GAAE;EAEH,MAAM,eAAe,gCAAgC,eAAe;AACpE,SAAO;CACR;;;;;;CAOD,MAAa,WAAWC,SAAqC;EAC3D,MAAM,KAAK,aAAa;EACxB,MAAM,WAAW,gCAAgC,CAAC,OAAQ,EAAC;EAC3D,MAAM,EAAE,MAAM,MAAM,GAAG,SAAS;AAEhC,SAAO,KAAK,eACT,OACC,CAAC;GAAC,KAAK;GAAW;GAAM,KAAK,KAAK;GAAE,KAAK,UAAU,KAAK;EAAC,CAAC,GAC1D;GACE,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;EACN,EACF,CACA,KAAK,MAAM,CAAE,EAAC;CAClB;;;;;CAMD,MAAa,QAAuB;EAClC,MAAM,KAAK,aAAa;AACxB,SAAO,KAAK,eACT,OAAO;GAAE,MAAM,KAAK,aAAa;GAAM,OAAO,KAAK;EAAW,EAAC,CAC/D,KAAK,MAAM,CAAE,EAAC;CAClB;;;;;CAMD,MAAc,cAA6B;AACzC,MAAI,KAAK,eACP;EAGF,MAAM,cAAc;GAClB,GAAG,KAAK;GACR,YAAY,CAAC,KAAK,cAAc,KAAK,YAAa;GAClD,eAAe,CAAC,KAAK,gBAAgB,KAAK,OAAQ;EACnD;EAED,KAAK,iBAAiB,MAAM,IAAI,eAAe;CAChD;AACF"}