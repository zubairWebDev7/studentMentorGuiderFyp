{"version":3,"file":"deep-agent.d.cts","names":["DefaultToolCall","BagTemplate","SubagentStream","DefaultSubagentStates","UseAgentStream","UseAgentStreamOptions","UseDeepAgentStream","Record","StateType","ToolCall","Bag","SubagentStates","Map","TName","UseDeepAgentStreamOptions"],"sources":["../../../src/ui/stream/deep-agent.d.ts"],"sourcesContent":["/**\n * Stream types for DeepAgent instances created with `createDeepAgent`.\n *\n * This module provides the stream interface that adds subagent streaming\n * capabilities on top of agent streaming functionality.\n *\n * @module\n */\nimport type { DefaultToolCall } from \"../../types.messages.js\";\nimport type { BagTemplate } from \"../../types.template.js\";\nimport type { SubagentStream, DefaultSubagentStates } from \"../types.js\";\nimport type { UseAgentStream, UseAgentStreamOptions } from \"./agent.js\";\n/**\n * Stream interface for DeepAgent instances created with `createDeepAgent`.\n *\n * Extends {@link UseAgentStream} with subagent streaming capabilities. Subagent\n * streams are automatically typed based on the agent's subagent configuration,\n * enabling type-safe access to subagent state and messages.\n *\n * Use this interface when streaming from an agent created with `createDeepAgent`\n * that orchestrates multiple specialized subagents.\n *\n * @experimental This interface is subject to change.\n *\n * @template StateType - The agent's state type\n * @template ToolCall - Tool call type from agent's tools\n * @template SubagentStates - Map of subagent names to their state types\n * @template Bag - Type configuration bag\n *\n * @example\n * ```typescript\n * import { createDeepAgent } from \"deepagents\";\n * import { useStream } from \"@langchain/langgraph-sdk/react\";\n *\n * // Define subagents with typed middleware\n * const agent = createDeepAgent({\n *   subagents: [\n *     {\n *       name: \"researcher\",\n *       description: \"Research specialist\",\n *       middleware: [ResearchMiddleware],\n *     },\n *     {\n *       name: \"writer\",\n *       description: \"Content writer\",\n *       middleware: [WriterMiddleware],\n *     },\n *   ] as const, // Important: use 'as const' for type inference\n * });\n *\n * // In React component:\n * function Chat() {\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"deep-agent\",\n *     apiUrl: \"http://localhost:2024\",\n *     filterSubagentMessages: true, // Only show main agent messages\n *   });\n *\n *   // Subagent streams are typed!\n *   const researchers = stream.getSubagentsByType(\"researcher\");\n *   researchers.forEach(subagent => {\n *     // subagent.values.messages is typed as Message<ToolCall>[]\n *     // subagent.status is \"pending\" | \"running\" | \"complete\" | \"error\"\n *     console.log(\"Researcher status:\", subagent.status);\n *   });\n *\n *   // Track all active subagents\n *   stream.activeSubagents.forEach(subagent => {\n *     console.log(`${subagent.toolCall.args.subagent_type} is running...`);\n *   });\n * }\n * ```\n *\n * @remarks\n * This interface adds subagent streaming on top of {@link UseAgentStream}:\n * - `subagents` - Map of all subagent streams by tool call ID\n * - `activeSubagents` - Array of currently running subagents\n * - `getSubagent(id)` - Get a specific subagent by tool call ID\n * - `getSubagentsByType(type)` - Get all subagents of a specific type with typed state\n * - `getSubagentsByMessage(messageId)` - Get all subagents triggered by a specific AI message\n *\n * It also enables the `filterSubagentMessages` option to exclude subagent\n * messages from the main `messages` array.\n */\nexport interface UseDeepAgentStream<StateType extends Record<string, unknown> = Record<string, unknown>, ToolCall = DefaultToolCall, SubagentStates extends Record<string, unknown> = DefaultSubagentStates, Bag extends BagTemplate = BagTemplate> extends UseAgentStream<StateType, ToolCall, Bag> {\n    /**\n     * All currently active and completed subagent streams.\n     *\n     * Keyed by tool call ID for easy lookup. Includes subagents in all states:\n     * pending, running, complete, and error.\n     *\n     * @example\n     * ```typescript\n     * // Iterate over all subagents\n     * stream.subagents.forEach((subagent, toolCallId) => {\n     *   console.log(`Subagent ${toolCallId}: ${subagent.status}`);\n     * });\n     *\n     * // Get a specific subagent\n     * const specific = stream.subagents.get(\"call_abc123\");\n     * ```\n     */\n    subagents: Map<string, SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>>;\n    /**\n     * Currently active subagents (where status === \"running\").\n     *\n     * Use this to track and display subagents that are actively executing.\n     * Completed or errored subagents are not included.\n     *\n     * @example\n     * ```typescript\n     * // Show loading indicators for active subagents\n     * stream.activeSubagents.map(subagent => (\n     *   <SubagentCard\n     *     key={subagent.id}\n     *     type={subagent.toolCall.args.subagent_type}\n     *     isLoading={true}\n     *   />\n     * ));\n     * ```\n     */\n    activeSubagents: SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>[];\n    /**\n     * Get subagent stream by tool call ID.\n     *\n     * Use this when you have a specific tool call ID and need to access\n     * its corresponding subagent stream.\n     *\n     * @param toolCallId - The tool call ID that initiated the subagent\n     * @returns The subagent stream, or undefined if not found\n     *\n     * @example\n     * ```typescript\n     * // In a tool call component\n     * const subagent = stream.getSubagent(toolCall.id);\n     * if (subagent) {\n     *   return <SubagentProgress subagent={subagent} />;\n     * }\n     * ```\n     */\n    getSubagent: (toolCallId: string) => SubagentStream<SubagentStates[keyof SubagentStates], ToolCall> | undefined;\n    /**\n     * Get all subagents of a specific type.\n     *\n     * Returns streams with properly inferred state types based on subagent name.\n     * When called with a literal string that matches a subagent name, TypeScript\n     * will infer the correct state type for that subagent.\n     *\n     * @param type - The subagent_type to filter by\n     * @returns Array of matching subagent streams with inferred state types\n     *\n     * @example\n     * ```typescript\n     * // Get all researcher subagents with typed state\n     * const researchers = stream.getSubagentsByType(\"researcher\");\n     *\n     * researchers.forEach(researcher => {\n     *   // researcher.values is typed based on ResearchMiddleware\n     *   console.log(\"Research messages:\", researcher.values.messages.length);\n     *   console.log(\"Status:\", researcher.status);\n     * });\n     *\n     * // Get all writer subagents\n     * const writers = stream.getSubagentsByType(\"writer\");\n     * // writers have different state type based on WriterMiddleware\n     * ```\n     */\n    getSubagentsByType: {\n        /**\n         * Overload for known subagent names - returns typed streams.\n         * TypeScript infers the state type from SubagentStates[TName].\n         */\n        <TName extends keyof SubagentStates & string>(type: TName): SubagentStream<SubagentStates[TName], ToolCall>[];\n        /**\n         * Overload for unknown names - returns untyped streams.\n         * Used when the subagent name is not known at compile time.\n         */\n        (type: string): SubagentStream<Record<string, unknown>, ToolCall>[];\n    };\n    /**\n     * Get all subagents triggered by a specific AI message.\n     *\n     * Useful for rendering subagent activities grouped by conversation turn.\n     * Each AI message that contains subagent tool calls will have its triggered\n     * subagents returned by this method.\n     *\n     * @param messageId - The ID of the AI message that triggered the subagents\n     * @returns Array of subagent streams triggered by that message\n     *\n     * @example\n     * ```tsx\n     * // Render subagents inline after the AI message that triggered them\n     * {stream.messages.map((msg) => (\n     *   <div key={msg.id}>\n     *     <MessageBubble message={msg} />\n     *     {msg.type === \"ai\" && \"tool_calls\" in msg && (\n     *       <SubagentPipeline\n     *         subagents={stream.getSubagentsByMessage(msg.id)}\n     *       />\n     *     )}\n     *   </div>\n     * ))}\n     * ```\n     */\n    getSubagentsByMessage: (messageId: string) => SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>[];\n}\n/**\n * Options for configuring a deep agent stream.\n *\n * Use this options interface when calling `useStream` with a DeepAgent\n * created via `createDeepAgent`. Includes all agent options plus\n * subagent-specific configuration.\n *\n * @template StateType - The agent's state type\n * @template Bag - Type configuration bag\n *\n * @example\n * ```typescript\n * const stream = useStream<typeof agent>({\n *   assistantId: \"deep-agent\",\n *   apiUrl: \"http://localhost:2024\",\n *\n *   // DeepAgent-specific options\n *   subagentToolNames: [\"task\", \"delegate\"],\n *   filterSubagentMessages: true,\n *\n *   onError: (error) => console.error(error),\n * });\n * ```\n */\nexport interface UseDeepAgentStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> extends UseAgentStreamOptions<StateType, Bag> {\n    /**\n     * Tool names that indicate subagent invocation.\n     *\n     * When an AI message contains tool calls with these names, they are\n     * automatically tracked as subagent executions. This enables the\n     * `subagents`, `activeSubagents`, `getSubagent()`, `getSubagentsByType()`, and `getSubagentsByMessage()`\n     * properties on the stream.\n     *\n     * @default [\"task\"]\n     *\n     * @example\n     * ```typescript\n     * const stream = useStream<typeof agent>({\n     *   assistantId: \"deep-agent\",\n     *   // Track both \"task\" and \"delegate\" as subagent tools\n     *   subagentToolNames: [\"task\", \"delegate\", \"spawn_agent\"],\n     * });\n     *\n     * // Now stream.subagents will include executions from any of these tools\n     * ```\n     */\n    subagentToolNames?: string[];\n    /**\n     * Whether to filter out messages from subagent namespaces.\n     *\n     * When `true`, only messages from the main agent are included in\n     * the `messages` array. Subagent messages are still accessible via\n     * the `subagents` map and individual subagent streams.\n     *\n     * This is useful when you want to display subagent progress separately\n     * from the main conversation, or when subagent messages would be too\n     * verbose in the main message list.\n     *\n     * @default false\n     *\n     * @example\n     * ```typescript\n     * const stream = useStream<typeof agent>({\n     *   assistantId: \"deep-agent\",\n     *   filterSubagentMessages: true,\n     * });\n     *\n     * // stream.messages only contains main agent messages\n     * // Subagent messages are in stream.getSubagentsByType(\"researcher\")[0].messages\n     * ```\n     */\n    filterSubagentMessages?: boolean;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAlJiBM,qCAAqCC,0BAA0BA,oCAAoCP,wCAAwCO,0BAA0BJ,mCAAmCF,cAAcA,qBAAqBG,eAAeI,WAAWC,UAAUC;;;;;;;;;;;;;;;;;;aAkBjRE,YAAYV,eAAeS,qBAAqBA,iBAAiBF;;;;;;;;;;;;;;;;;;;mBAmB3DP,eAAeS,qBAAqBA,iBAAiBF;;;;;;;;;;;;;;;;;;;uCAmBjCP,eAAeS,qBAAqBA,iBAAiBF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yBAgCjEE,+BAA+BE,QAAQX,eAAeS,eAAeE,QAAQJ;;;;;oBAKlFP,eAAeK,yBAAyBE;;;;;;;;;;;;;;;;;;;;;;;;;;;gDA2BdP,eAAeS,qBAAqBA,iBAAiBF;;;;;;;;;;;;;;;;;;;;;;;;;;UA0BtFK,4CAA4CP,0BAA0BA,qCAAqCN,cAAcA,qBAAqBI,sBAAsBG,WAAWE"}