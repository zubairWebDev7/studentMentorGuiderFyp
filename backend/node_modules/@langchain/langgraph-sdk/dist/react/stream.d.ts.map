{"version":3,"file":"stream.d.ts","names":["BagTemplate","UseStreamCustomOptions","ResolveStreamInterface","ResolveStreamOptions","InferBag","InferStateType","useStream","Record","T","Bag"],"sources":["../../src/react/stream.d.ts"],"sourcesContent":["import type { BagTemplate } from \"../types.template.js\";\nimport type { UseStreamCustomOptions } from \"./types.js\";\nimport type { ResolveStreamInterface, ResolveStreamOptions, InferBag, InferStateType } from \"../ui/stream/index.js\";\n/**\n * A React hook that provides seamless integration with LangGraph streaming capabilities.\n *\n * The `useStream` hook handles all the complexities of streaming, state management, and branching logic,\n * letting you focus on building great chat experiences. It provides automatic state management for\n * messages, interrupts, loading states, subagent streams, and errors.\n *\n * ## Usage with ReactAgent (recommended for createAgent users)\n *\n * When using `createAgent` from `@langchain/langgraph`, you can pass `typeof agent` as the\n * type parameter to automatically infer tool call types:\n *\n * @example\n * ```typescript\n * // In your agent file (e.g., agent.ts)\n * import { createAgent, tool } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const getWeather = tool(\n *   async ({ location }) => `Weather in ${location}`,\n *   { name: \"get_weather\", schema: z.object({ location: z.string() }) }\n * );\n *\n * export const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [getWeather],\n * });\n *\n * // In your React component\n * import { agent } from \"./agent\";\n *\n * function Chat() {\n *   // Tool calls are automatically typed from the agent's tools!\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"agent\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.toolCalls[0].call.name is typed as \"get_weather\"\n *   // stream.toolCalls[0].call.args is typed as { location: string }\n * }\n * ```\n *\n * ## Usage with StateGraph (for custom LangGraph applications)\n *\n * When building custom graphs with `StateGraph`, embed your tool call types directly\n * in your state's messages property using `Message<MyToolCalls>`:\n *\n * @example\n * ```typescript\n * import { Message } from \"@langchain/langgraph-sdk\";\n *\n * // Define your tool call types as a discriminated union\n * type MyToolCalls =\n *   | { name: \"search\"; args: { query: string }; id?: string }\n *   | { name: \"calculate\"; args: { expression: string }; id?: string };\n *\n * // Embed tool call types in your state's messages\n * interface MyGraphState {\n *   messages: Message<MyToolCalls>[];\n *   context?: string;\n * }\n *\n * function Chat() {\n *   const stream = useStream<MyGraphState>({\n *     assistantId: \"my-graph\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.values is typed as MyGraphState\n *   // stream.toolCalls[0].call.name is typed as \"search\" | \"calculate\"\n * }\n * ```\n *\n * @example\n * ```typescript\n * // With additional type configuration (interrupts, configurable)\n * interface MyGraphState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * function Chat() {\n *   const stream = useStream<MyGraphState, {\n *     InterruptType: { question: string };\n *     ConfigurableType: { userId: string };\n *   }>({\n *     assistantId: \"my-graph\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.interrupt is typed as { question: string } | undefined\n * }\n * ```\n *\n * ## Usage with Deep Agents (subagent streaming, experimental)\n *\n * For agents that spawn subagents (nested graphs), use `filterSubagentMessages`\n * to keep the main message stream clean while tracking subagent activity separately:\n *\n * @example\n * ```typescript\n * import { useStream, SubagentStream } from \"@langchain/langgraph-sdk/react\";\n * import type { agent } from \"./agent\";\n *\n * function DeepAgentChat() {\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"deepagent\",\n *     apiUrl: \"http://localhost:2024\",\n *     // Filter subagent messages from main stream\n *     filterSubagentMessages: true,\n *   });\n *\n *   const handleSubmit = (content: string) => {\n *     stream.submit(\n *       { messages: [{ content, type: \"human\" }] },\n *       { streamSubgraphs: true } // Enable subgraph streaming\n *     );\n *   };\n *\n *   // Access subagent streams via stream.subagents (Map<string, SubagentStream>)\n *   const subagentList = [...stream.subagents.values()];\n *\n *   return (\n *     <div>\n *       {stream.messages.map((msg) => <Message key={msg.id} message={msg} />)}\n *\n *       {subagentList.map((subagent) => (\n *         <SubagentCard\n *           key={subagent.id}\n *           status={subagent.status} // \"pending\" | \"running\" | \"complete\" | \"error\"\n *           messages={subagent.messages}\n *           toolCalls={subagent.toolCalls}\n *         />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n *\n * @template T Either a ReactAgent type (with `~agentTypes`) or a state type (`Record<string, unknown>`)\n * @template Bag Type configuration bag containing:\n *   - `ConfigurableType`: Type for the `config.configurable` property\n *   - `InterruptType`: Type for interrupt values\n *   - `CustomEventType`: Type for custom events\n *   - `UpdateType`: Type for the submit function updates\n *\n * @see {@link https://docs.langchain.com/langgraph-platform/use-stream-react | LangGraph React Integration Guide}\n */\nexport declare function useStream<T = Record<string, unknown>, Bag extends BagTemplate = BagTemplate>(options: ResolveStreamOptions<T, InferBag<T, Bag>>): ResolveStreamInterface<T, InferBag<T, Bag>>;\n/**\n * A React hook that provides seamless integration with LangGraph streaming capabilities.\n *\n * The `useStream` hook handles all the complexities of streaming, state management, and branching logic,\n * letting you focus on building great chat experiences. It provides automatic state management for\n * messages, interrupts, loading states, and errors.\n *\n * @template T Either a ReactAgent type (with `~agentTypes`) or a state type (`Record<string, unknown>`)\n * @template Bag Type configuration bag containing:\n *   - `ConfigurableType`: Type for the `config.configurable` property\n *   - `InterruptType`: Type for interrupt values\n *   - `CustomEventType`: Type for custom events\n *   - `UpdateType`: Type for the submit function updates\n *\n * @see {@link https://docs.langchain.com/langgraph-platform/use-stream-react | LangGraph React Integration Guide}\n */\nexport declare function useStream<T = Record<string, unknown>, Bag extends BagTemplate = BagTemplate>(options: UseStreamCustomOptions<InferStateType<T>, InferBag<T, Bag>>): ResolveStreamInterface<T, InferBag<T, Bag>>;\n"],"mappings":";;;;;;;;AAuJA;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAjBwBM,cAAcC,qCAAqCP,cAAcA,sBAAsBG,qBAAqBK,GAAGJ,SAASI,GAAGC,QAAQP,uBAAuBM,GAAGJ,SAASI,GAAGC;;;;;;;;;;;;;;;;;iBAiBzKH,cAAcC,qCAAqCP,cAAcA,sBAAsBC,uBAAuBI,eAAeG,IAAIJ,SAASI,GAAGC,QAAQP,uBAAuBM,GAAGJ,SAASI,GAAGC"}