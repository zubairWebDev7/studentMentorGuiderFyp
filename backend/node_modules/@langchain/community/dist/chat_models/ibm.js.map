{"version":3,"file":"ibm.js","names":["model: string","tool_call_id: string","tools: ChatWatsonxToolType[]","MESSAGE_TYPE_TO_ROLE_MAP: Record<MessageType, string>","role: MessageType","message: BaseMessage","model?: string","messages: BaseMessage[]","choice: TextChatResultChoice | ChatsChoice","rawDataId: string","usage?: TextChatUsage","e: unknown","additional_kwargs: Record<string, unknown>","helperIndex: { [\"value\"]: number }","delta: WatsonxDeltaStream","rawData: TextChatResponse | ChatsResponse","defaultRole?: TextChatMessagesTextChatMessageAssistant.Constants.Role","toolCallChunks: ToolCallChunk[]","toolChoice: TextChatParameterTools | string | \"auto\" | \"any\"","options: this[\"ParsedCallOptions\"]","fields: this[\"ParsedCallOptions\"] | ChatWatsonxConstructorInput","validProps: string[]","fields: ChatWatsonxConstructorInput","toolParams: Record<string, WatsonXAI.TextChatParameterTools[]>","toolChoiceParams: Record<\n      string,\n      TextChatParameterTools | string | undefined\n    >","gatewayParams: Record<string, any>","kwargs?: Partial<CallOptions>","options?: this[\"ParsedCallOptions\"]","callback: () => T","scopeId: ReturnType<ChatWatsonx[\"scopeId\"]>","params: ReturnType<ChatWatsonx[\"invocationParams\"]>","messages: ChatsMessage[]","signal?: AbortSignal","stream: S","runManager?: CallbackManagerForLLMRun","finalChunks: Record<number, ChatGenerationChunk>","tokenUsage: UsageMetadata","tokenUsages: UsageMetadata[]","generations: ChatGeneration[]","generation: ChatGeneration","_runManager?: CallbackManagerForLLMRun","usage: TextChatUsage | undefined","generationChunk","outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>","config?: StructuredOutputMethodOptions<boolean>","schema: InteropZodType<RunOutput> | Record<string, any>","outputParser: BaseLLMOutputParser<RunOutput>","llm: Runnable<BaseLanguageModelInput>","outputFormatSchema: JsonSchema7Type | undefined","openAIFunctionDefinition: FunctionDefinition","input: any","config"],"sources":["../../src/chat_models/ibm.ts"],"sourcesContent":["import {\n  AIMessage,\n  AIMessageChunk,\n  ChatMessage,\n  ChatMessageChunk,\n  FunctionMessageChunk,\n  HumanMessageChunk,\n  isAIMessage,\n  MessageType,\n  ToolMessageChunk,\n  UsageMetadata,\n  type BaseMessage,\n} from \"@langchain/core/messages\";\nimport {\n  BaseLanguageModelInput,\n  FunctionDefinition,\n  StructuredOutputMethodOptions,\n} from \"@langchain/core/language_models/base\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseChatModel,\n  BindToolsInput,\n  LangSmithParams,\n  type BaseChatModelParams,\n} from \"@langchain/core/language_models/chat_models\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { AsyncCaller } from \"@langchain/core/utils/async_caller\";\nimport {\n  DeploymentsTextChatParams,\n  RequestCallbacks,\n  TextChatMessagesTextChatMessageAssistant,\n  TextChatParameterTools,\n  TextChatParams,\n  TextChatResponse,\n  TextChatResponseFormat,\n  TextChatResultChoice,\n  TextChatResultMessage,\n  TextChatToolCall,\n  TextChatUsage,\n} from \"@ibm-cloud/watsonx-ai/dist/watsonx-ai-ml/vml_v1.js\";\nimport { WatsonXAI, Stream } from \"@ibm-cloud/watsonx-ai\";\nimport { Response } from \"@ibm-cloud/watsonx-ai/base\";\nimport {\n  convertLangChainToolCallToOpenAI,\n  makeInvalidToolCall,\n  parseToolCall,\n} from \"@langchain/core/output_parsers/openai_tools\";\nimport { ToolCallChunk } from \"@langchain/core/messages/tool\";\nimport {\n  Runnable,\n  RunnablePassthrough,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport {\n  BaseLLMOutputParser,\n  JsonOutputParser,\n  StructuredOutputParser,\n} from \"@langchain/core/output_parsers\";\nimport {\n  InteropZodType,\n  isInteropZodSchema,\n} from \"@langchain/core/utils/types\";\nimport {\n  JsonSchema7Type,\n  toJsonSchema,\n} from \"@langchain/core/utils/json_schema\";\nimport { NewTokenIndices } from \"@langchain/core/callbacks/base\";\nimport {\n  ChatObjectStream,\n  ChatsChoice,\n  ChatsMessage,\n  ChatsRequestTool,\n  ChatsResponse,\n  CreateChatCompletionsParams,\n  Gateway,\n} from \"@ibm-cloud/watsonx-ai/gateway\";\nimport { WatsonxAuth, XOR, WatsonxBaseChatParams } from \"../types/ibm.js\";\nimport {\n  _convertToolCallIdToMistralCompatible,\n  authenticateAndSetGatewayInstance,\n  authenticateAndSetInstance,\n  checkValidProps,\n  expectOneOf,\n  WatsonxToolsOutputParser,\n} from \"../utils/ibm.js\";\n\n// Ensuring back compatibility\nexport interface WatsonxCallParams extends WatsonxCallOptionsChat {}\nexport interface WatsonxCallDeployedParams extends DeploymentsTextChatParams {}\n\nexport interface WatsonxDeltaStream {\n  role?: string;\n  content?: string;\n  tool_calls?: TextChatToolCall[];\n  refusal?: string;\n}\n\n/** Project/space params */\n\nexport interface WatsonxCallOptionsChat\n  extends\n    Partial<Omit<TextChatParams, \"modelId\" | \"toolChoice\" | \"messages\">>,\n    WatsonxBaseChatParams {\n  model?: string;\n}\n\nexport interface WatsonxProjectSpaceParams extends WatsonxCallOptionsChat {\n  model: string;\n  serviceUrl: string;\n  version: string;\n}\n/** Deployed params */\nexport interface WatsonxCallOptionsDeployedChat\n  extends\n    Partial<Omit<DeploymentsTextChatParams, \"messages\">>,\n    WatsonxBaseChatParams {}\n\nexport interface WatsonxDeployedParams extends WatsonxCallOptionsDeployedChat {\n  serviceUrl: string;\n  version: string;\n}\n/** Gateway params */\nexport interface WatsonxGatewayChatKwargs extends Omit<\n  CreateChatCompletionsParams,\n  keyof TextChatParams | \"model\" | \"stream\" | \"messages\"\n> {}\nexport interface WatsonxCallOptionsGatewayChat\n  extends\n    Omit<\n      CreateChatCompletionsParams,\n      | \"stream\"\n      | \"toolChoice\"\n      | \"messages\"\n      | \"prompt\"\n      | keyof WatsonxGatewayChatKwargs\n    >,\n    WatsonxBaseChatParams {\n  /** Additional parameters usable only in model gateway */\n  modelGatewayKwargs?: WatsonxGatewayChatKwargs;\n}\n\nexport interface WatsonxGatewayChatParams extends WatsonxCallOptionsGatewayChat {\n  serviceUrl: string;\n  version: string;\n}\n\n// Chat input for different chat modes\nexport interface ChatWatsonxInput\n  extends BaseChatModelParams, WatsonxProjectSpaceParams {}\n\nexport interface ChatWatsonxDeployedInput\n  extends BaseChatModelParams, WatsonxDeployedParams {}\n\nexport interface ChatWatsonxGatewayInput\n  extends BaseChatModelParams, WatsonxGatewayChatParams {\n  /** Flag indicating weather to use Model Gateway or no */\n  modelGateway: boolean;\n}\n\n// Chat type to be extended by chat class\nexport type ChatWatsonxConstructor = BaseChatModelParams &\n  Partial<WatsonxBaseChatParams> &\n  WatsonxDeployedParams &\n  WatsonxCallParams &\n  WatsonxDeployedParams;\n\nfunction _convertToValidToolId(model: string, tool_call_id: string): string {\n  if (model.startsWith(\"mistralai\") && tool_call_id)\n    return _convertToolCallIdToMistralCompatible(tool_call_id);\n  return tool_call_id;\n}\n\ntype ChatWatsonxToolType =\n  | BindToolsInput\n  | TextChatParameterTools\n  | ChatsRequestTool;\n\nfunction _convertToolToWatsonxTool(\n  tools: ChatWatsonxToolType[]\n): WatsonXAI.TextChatParameterTools[] {\n  return tools.map((tool) => {\n    if (\"type\" in tool) {\n      return tool as WatsonXAI.TextChatParameterTools;\n    }\n    // Check if schema is a Zod schema or already a JSON schema\n    const parameters = isInteropZodSchema(tool.schema)\n      ? toJsonSchema(tool.schema)\n      : tool.schema;\n\n    return {\n      type: \"function\",\n      function: {\n        name: tool.name,\n        description: tool.description ?? `Tool: ${tool.name}`,\n        parameters,\n      },\n    };\n  });\n}\nconst MESSAGE_TYPE_TO_ROLE_MAP: Record<MessageType, string> = {\n  human: \"user\",\n  ai: \"assistant\",\n  system: \"system\",\n  tool: \"tool\",\n  function: \"function\",\n  generic: \"assistant\",\n  developer: \"developer\",\n  remove: \"function\",\n};\n\nconst getRole = (role: MessageType): string => {\n  const watsonRole = MESSAGE_TYPE_TO_ROLE_MAP[role];\n  if (!watsonRole) {\n    throw new Error(`Unknown message type: ${role}`);\n  }\n  return watsonRole;\n};\n\nconst getToolCalls = (message: BaseMessage, model?: string) => {\n  if (isAIMessage(message) && message.tool_calls?.length) {\n    return message.tool_calls\n      .map((toolCall) => ({\n        ...toolCall,\n        id: _convertToValidToolId(model ?? \"\", toolCall.id ?? \"\"),\n      }))\n      .map(convertLangChainToolCallToOpenAI);\n  }\n  return undefined;\n};\n\nfunction _convertMessagesToWatsonxMessages(\n  messages: BaseMessage[],\n  model?: string\n): TextChatResultMessage[] | ChatsMessage[] {\n  return messages.map((message) => {\n    const toolCalls = getToolCalls(message, model);\n    const content = toolCalls === undefined ? message.content : \"\";\n    if (\"tool_call_id\" in message && typeof message.tool_call_id === \"string\") {\n      return {\n        role: getRole(message.getType()),\n        content,\n        name: message.name,\n        tool_call_id: _convertToValidToolId(model ?? \"\", message.tool_call_id),\n      };\n    }\n\n    return {\n      role: getRole(message.getType()),\n      content,\n      tool_calls: toolCalls,\n    };\n  });\n}\n\nfunction _watsonxResponseToChatMessage(\n  choice: TextChatResultChoice | ChatsChoice,\n  rawDataId: string,\n  usage?: TextChatUsage\n): BaseMessage {\n  const { message } = choice;\n  if (!message) throw new Error(\"No message presented\");\n  const rawToolCalls = message.tool_calls ?? [];\n\n  switch (message.role) {\n    case \"assistant\": {\n      const toolCalls = [];\n      const invalidToolCalls = [];\n      for (const rawToolCall of rawToolCalls) {\n        try {\n          const parsed = parseToolCall(rawToolCall, { returnId: true });\n          toolCalls.push(parsed);\n        } catch (e: unknown) {\n          invalidToolCalls.push(\n            makeInvalidToolCall(rawToolCall, (e as Error).message)\n          );\n        }\n      }\n      const additional_kwargs: Record<string, unknown> = {\n        tool_calls: rawToolCalls.map((toolCall) => ({\n          ...toolCall,\n          type: \"function\",\n        })),\n        ...(\"reasoning_content\" in message\n          ? { reasoning: message?.reasoning_content }\n          : {}),\n      };\n\n      return new AIMessage({\n        id: rawDataId,\n        content: message.content ?? \"\",\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        additional_kwargs,\n        usage_metadata: usage\n          ? {\n              input_tokens: usage.prompt_tokens ?? 0,\n              output_tokens: usage.completion_tokens ?? 0,\n              total_tokens: usage.total_tokens ?? 0,\n            }\n          : undefined,\n      });\n    }\n    default:\n      return new ChatMessage(message.content ?? \"\", message.role ?? \"unknown\");\n  }\n}\n\nfunction _convertDeltaToMessageChunk(\n  helperIndex: { [\"value\"]: number },\n  delta: WatsonxDeltaStream,\n  rawData: TextChatResponse | ChatsResponse,\n  model?: string,\n  usage?: TextChatUsage,\n  defaultRole?: TextChatMessagesTextChatMessageAssistant.Constants.Role\n) {\n  if (delta.refusal) throw new Error(delta.refusal);\n\n  const rawToolCalls = delta.tool_calls?.length\n    ? delta.tool_calls?.map(\n        (\n          toolCall,\n          index\n        ): TextChatToolCall & { index: number; type: \"function\" } => {\n          const validId =\n            toolCall.id && toolCall.id !== \"\"\n              ? _convertToValidToolId(model ?? \"\", toolCall.id)\n              : undefined;\n          if (toolCall.id) helperIndex.value += 1;\n          return {\n            index:\n              delta?.tool_calls && delta?.tool_calls?.length > 1\n                ? index\n                : helperIndex.value,\n            ...toolCall,\n            ...(validId !== null && { id: validId }),\n            type: \"function\",\n          };\n        }\n      )\n    : undefined;\n\n  const role = delta.role || defaultRole || \"assistant\";\n  const content = delta.content ?? \"\";\n  const additional_kwargs = {\n    ...(rawToolCalls ? { tool_calls: rawToolCalls } : {}),\n    ...(\"reasoning_content\" in delta\n      ? { reasoning: delta?.reasoning_content }\n      : {}),\n  };\n\n  const usageMetadata = {\n    input_tokens: usage?.prompt_tokens ?? 0,\n    output_tokens: usage?.completion_tokens ?? 0,\n    total_tokens: usage?.total_tokens ?? 0,\n  };\n  switch (role) {\n    case \"user\":\n      return new HumanMessageChunk({ content });\n\n    case \"assistant\": {\n      // Extract tool call chunks creation\n      const toolCallChunks: ToolCallChunk[] = [];\n      if (rawToolCalls && rawToolCalls?.length > 0) {\n        for (const rawToolCallChunk of rawToolCalls) {\n          const toolCallName = rawToolCallChunk.function.name;\n          toolCallChunks.push({\n            name: toolCallName.length > 0 ? toolCallName : undefined,\n            args: rawToolCallChunk.function?.arguments,\n            id: rawToolCallChunk.id,\n            index: rawToolCallChunk.index,\n            type: \"tool_call_chunk\",\n          });\n        }\n      }\n\n      return new AIMessageChunk({\n        content,\n        tool_call_chunks: toolCallChunks,\n        additional_kwargs,\n        usage_metadata: usageMetadata,\n        id: rawData.id,\n      });\n    }\n\n    case \"tool\":\n      if (rawToolCalls) {\n        return new ToolMessageChunk({\n          content,\n          additional_kwargs,\n          tool_call_id: _convertToValidToolId(model ?? \"\", rawToolCalls[0].id),\n        });\n      }\n      return null;\n\n    case \"function\":\n      return new FunctionMessageChunk({\n        content,\n        additional_kwargs,\n      });\n\n    default:\n      return new ChatMessageChunk({ content, role });\n  }\n}\n\nfunction _convertToolChoiceToWatsonxToolChoice(\n  toolChoice: TextChatParameterTools | string | \"auto\" | \"any\"\n) {\n  if (typeof toolChoice === \"string\") {\n    if (toolChoice === \"any\" || toolChoice === \"required\") {\n      return { toolChoiceOption: \"required\" };\n    } else if (toolChoice === \"auto\" || toolChoice === \"none\") {\n      return { toolChoiceOption: toolChoice };\n    } else {\n      return {\n        toolChoice: {\n          type: \"function\",\n          function: { name: toolChoice },\n        },\n      };\n    }\n  } else if (\"type\" in toolChoice) return { toolChoice };\n  else\n    throw new Error(\n      `Unrecognized tool_choice type. Expected string or TextChatParameterTools. Recieved ${toolChoice}`\n    );\n}\n\n// Combined input for chat excluding each mode to not be present at the same time\nexport type ChatWatsonxConstructorInput = XOR<\n  XOR<ChatWatsonxInput, ChatWatsonxDeployedInput>,\n  ChatWatsonxGatewayInput\n> &\n  WatsonxAuth;\n\n// Helper to force type expansion\nexport type ChatWatsonxCallOptions = XOR<\n  XOR<WatsonxCallOptionsChat, WatsonxCallOptionsDeployedChat>,\n  WatsonxCallOptionsGatewayChat\n>;\n\nexport class ChatWatsonx<\n  CallOptions extends ChatWatsonxCallOptions = ChatWatsonxCallOptions,\n>\n  extends BaseChatModel<CallOptions>\n  implements ChatWatsonxConstructor\n{\n  static lc_name() {\n    return \"ChatWatsonx\";\n  }\n\n  lc_serializable = true;\n\n  get lc_secrets(): { [key: string]: string } {\n    return {\n      authenticator: \"AUTHENTICATOR\",\n      apiKey: \"WATSONX_AI_APIKEY\",\n      apikey: \"WATSONX_AI_APIKEY\",\n      watsonxAIAuthType: \"WATSONX_AI_AUTH_TYPE\",\n      watsonxAIApikey: \"WATSONX_AI_APIKEY\",\n      watsonxAIBearerToken: \"WATSONX_AI_BEARER_TOKEN\",\n      watsonxAIUsername: \"WATSONX_AI_USERNAME\",\n      watsonxAIPassword: \"WATSONX_AI_PASSWORD\",\n      watsonxAIUrl: \"WATSONX_AI_URL\",\n    };\n  }\n\n  get lc_aliases(): { [key: string]: string } {\n    return {\n      authenticator: \"authenticator\",\n      apikey: \"watsonx_ai_apikey\",\n      apiKey: \"watsonx_ai_apikey\",\n      watsonxAIAuthType: \"watsonx_ai_auth_type\",\n      watsonxAIApikey: \"watsonx_ai_apikey\",\n      watsonxAIBearerToken: \"watsonx_ai_bearer_token\",\n      watsonxAIUsername: \"watsonx_ai_username\",\n      watsonxAIPassword: \"watsonx_ai_password\",\n      watsonxAIUrl: \"watsonx_ai_url\",\n    };\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const params = this.invocationParams(options);\n    return {\n      ls_provider: \"watsonx\",\n      ls_model_name: this.model,\n      ls_model_type: \"chat\",\n      ls_temperature: params.temperature ?? undefined,\n      ls_max_tokens: params.maxTokens ?? undefined,\n    };\n  }\n\n  private checkValidProperties(\n    fields: this[\"ParsedCallOptions\"] | ChatWatsonxConstructorInput,\n    includeCommonProps = true\n  ) {\n    const PROPERTY_GROUPS = {\n      ALWAYS_ALLOWED: [\n        \"headers\",\n        \"signal\",\n        \"tool_choice\",\n        \"promptIndex\",\n        \"ls_structured_output_format\",\n        \"watsonxCallbacks\",\n        \"writer\",\n        \"interrupt\",\n      ],\n\n      AUTH: [\n        \"serviceUrl\",\n        \"watsonxAIApikey\",\n        \"watsonxAIBearerToken\",\n        \"watsonxAIUsername\",\n        \"watsonxAIPassword\",\n        \"watsonxAIUrl\",\n        \"watsonxAIAuthType\",\n        \"disableSSL\",\n      ],\n\n      SHARED: [\n        \"maxRetries\",\n        \"authenticator\",\n        \"serviceUrl\",\n        \"version\",\n        \"streaming\",\n        \"callbackManager\",\n        \"callbacks\",\n        \"maxConcurrency\",\n        \"cache\",\n        \"metadata\",\n        \"concurrency\",\n        \"onFailedAttempt\",\n        \"verbose\",\n        \"tags\",\n        \"headers\",\n        \"disableStreaming\",\n        \"timeout\",\n        \"stopSequences\",\n      ],\n\n      GATEWAY: [\n        \"tools\",\n        \"frequencyPenalty\",\n        \"logitBias\",\n        \"logprobs\",\n        \"topLogprobs\",\n        \"maxTokens\",\n        \"n\",\n        \"presencePenalty\",\n        \"responseFormat\",\n        \"seed\",\n        \"stop\",\n        \"temperature\",\n        \"topP\",\n        \"model\",\n        \"modelGatewayKwargs\",\n        \"modelGateway\",\n        \"reasoningEffort\",\n      ],\n\n      DEPLOYMENT: [\"idOrName\"],\n\n      PROJECT_OR_SPACE: [\n        \"spaceId\",\n        \"projectId\",\n        \"tools\",\n        \"toolChoiceOption\",\n        \"frequencyPenalty\",\n        \"logitBias\",\n        \"logprobs\",\n        \"topLogprobs\",\n        \"maxTokens\",\n        \"maxCompletionTokens\",\n        \"n\",\n        \"presencePenalty\",\n        \"responseFormat\",\n        \"seed\",\n        \"stop\",\n        \"temperature\",\n        \"topP\",\n        \"timeLimit\",\n        \"model\",\n        \"reasoningEffort\",\n        \"includeReasoning\",\n      ],\n    };\n\n    const validProps: string[] = [...PROPERTY_GROUPS.ALWAYS_ALLOWED];\n\n    if (includeCommonProps) {\n      validProps.push(...PROPERTY_GROUPS.AUTH, ...PROPERTY_GROUPS.SHARED);\n    }\n\n    if (this.modelGateway) {\n      validProps.push(...PROPERTY_GROUPS.GATEWAY);\n    } else if (this.idOrName) {\n      validProps.push(...PROPERTY_GROUPS.DEPLOYMENT);\n    } else if (this.spaceId || this.projectId) {\n      validProps.push(...PROPERTY_GROUPS.PROJECT_OR_SPACE);\n    }\n\n    checkValidProps(fields, validProps);\n  }\n\n  protected service?: WatsonXAI;\n\n  protected gateway?: Gateway;\n\n  model?: string;\n\n  version = \"2024-05-31\";\n\n  modelGateway = false;\n\n  maxTokens?: number;\n\n  maxCompletionTokens?: number;\n\n  maxRetries = 0;\n\n  serviceUrl: string;\n\n  spaceId?: string;\n\n  projectId?: string;\n\n  idOrName?: string;\n\n  frequencyPenalty?: number;\n\n  logprobs?: boolean;\n\n  topLogprobs?: number;\n\n  n?: number;\n\n  presencePenalty?: number;\n\n  temperature?: number;\n\n  topP?: number;\n\n  timeLimit?: number;\n\n  includeReasoning?: boolean;\n\n  reasoningEffort?: \"low\" | \"medium\" | \"high\";\n\n  maxConcurrency?: number;\n\n  responseFormat?: TextChatResponseFormat;\n\n  streaming = false;\n\n  modelGatewayKwargs?: WatsonxGatewayChatKwargs;\n\n  watsonxCallbacks?: RequestCallbacks;\n\n  constructor(fields: ChatWatsonxConstructorInput) {\n    super(fields);\n    const uniqueProps = [\"spaceId\", \"projectId\", \"idOrName\", \"modelGateway\"];\n    expectOneOf(fields, uniqueProps, true);\n\n    this.idOrName = fields?.idOrName;\n    this.projectId = fields?.projectId;\n    this.modelGateway = fields.modelGateway || this.modelGateway;\n    this.spaceId = fields?.spaceId;\n\n    this.checkValidProperties(fields);\n\n    this.model = fields?.model ?? this.model;\n    this.projectId = fields?.projectId;\n    this.spaceId = fields?.spaceId;\n    this.watsonxCallbacks = fields?.watsonxCallbacks;\n    this.serviceUrl = fields?.serviceUrl;\n    this.version = fields?.version ?? this.version;\n\n    this.temperature = fields?.temperature;\n    this.maxRetries = fields?.maxRetries || this.maxRetries;\n    this.maxConcurrency = fields?.maxConcurrency;\n    this.frequencyPenalty = fields?.frequencyPenalty;\n    this.maxTokens = fields?.maxTokens ?? this.maxTokens;\n    this.maxCompletionTokens = fields?.maxCompletionTokens;\n    this.presencePenalty = fields?.presencePenalty;\n    this.topP = fields?.topP;\n    this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    this.streaming = fields?.streaming ?? this.streaming;\n    this.n = fields?.n ?? this.n;\n    this.timeLimit = fields?.timeLimit;\n    this.reasoningEffort = fields?.reasoningEffort;\n    this.includeReasoning = fields?.includeReasoning;\n\n    this.modelGateway = fields?.modelGateway ?? this.modelGateway;\n    this.modelGatewayKwargs = fields?.modelGatewayKwargs;\n\n    const {\n      watsonxAIApikey,\n      watsonxAIAuthType,\n      watsonxAIBearerToken,\n      watsonxAIUsername,\n      watsonxAIPassword,\n      watsonxAIUrl,\n      disableSSL,\n      version,\n      serviceUrl,\n    } = fields;\n\n    const authData = {\n      watsonxAIApikey,\n      watsonxAIAuthType,\n      watsonxAIBearerToken,\n      watsonxAIUsername,\n      watsonxAIPassword,\n      watsonxAIUrl,\n      disableSSL,\n      version,\n      serviceUrl,\n    };\n\n    if (this.modelGateway) {\n      const chatGateway = authenticateAndSetGatewayInstance(authData);\n      if (chatGateway) this.gateway = chatGateway;\n      else throw new Error(\"You have not provided any type of authentication\");\n    } else {\n      const service = authenticateAndSetInstance(authData);\n\n      if (service) this.service = service;\n      else throw new Error(\"You have not provided any type of authentication\");\n    }\n  }\n\n  _llmType() {\n    return \"watsonx\";\n  }\n\n  invocationParams(options: this[\"ParsedCallOptions\"]) {\n    const { tools, responseFormat, timeLimit, tool_choice } = options;\n\n    expectOneOf(options, [\"spaceId\", \"projectId\", \"idOrName\", \"modelGateway\"]);\n    this.checkValidProperties(options, false);\n\n    const paramDefaults = {\n      maxTokens: options.maxTokens ?? this.maxTokens,\n      maxCompletionTokens:\n        options.maxCompletionTokens ?? this.maxCompletionTokens,\n      temperature: options.temperature ?? this.temperature,\n      topP: options.topP ?? this.topP,\n      presencePenalty: options.presencePenalty ?? this.presencePenalty,\n      n: options.n ?? this.n,\n      topLogprobs: options.topLogprobs ?? this.topLogprobs,\n      logprobs: options.logprobs ?? this.logprobs,\n      frequencyPenalty: options.frequencyPenalty ?? this.frequencyPenalty,\n      reasoningEffort: options.reasoningEffort ?? this.reasoningEffort,\n    };\n\n    const toolParams: Record<string, WatsonXAI.TextChatParameterTools[]> = tools\n      ? { tools: _convertToolToWatsonxTool(tools) }\n      : {};\n\n    const toolChoiceParams: Record<\n      string,\n      TextChatParameterTools | string | undefined\n    > = tool_choice ? _convertToolChoiceToWatsonxToolChoice(tool_choice) : {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const gatewayParams: Record<string, any> = this.modelGateway\n      ? { ...this.modelGatewayKwargs }\n      : {\n          timeLimit: timeLimit ?? this.timeLimit,\n          projectId: options.projectId ?? this.projectId,\n          includeReasoning: options.includeReasoning ?? this.includeReasoning,\n        };\n\n    return {\n      ...paramDefaults,\n      ...toolParams,\n      responseFormat,\n      ...toolChoiceParams,\n      ...gatewayParams,\n    };\n  }\n\n  invocationCallbacks(options: this[\"ParsedCallOptions\"]) {\n    return options.watsonxCallbacks ?? this.watsonxCallbacks;\n  }\n\n  override bindTools(\n    tools: ChatWatsonxToolType[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, AIMessageChunk, CallOptions> {\n    return this.withConfig({\n      tools: _convertToolToWatsonxTool(tools),\n      ...kwargs,\n    } as CallOptions);\n  }\n\n  scopeId(\n    options?: this[\"ParsedCallOptions\"]\n  ):\n    | { idOrName: string }\n    | { projectId: string; modelId: string }\n    | { spaceId: string; modelId: string }\n    | { modelId: string }\n    | { model: string } {\n    const model = options?.model ?? this.model;\n    const projectId = options?.projectId ?? this.projectId;\n    const spaceId = options?.spaceId ?? this.spaceId;\n    const idOrName = options?.idOrName ?? this.idOrName;\n\n    if (this.modelGateway) {\n      if (!model) {\n        throw new Error(\n          \"No model provided! Model gateway expects model to be provided\"\n        );\n      }\n      return { model };\n    }\n\n    if (projectId && model) return { projectId, modelId: model };\n    if (spaceId && model) return { spaceId, modelId: model };\n    if (idOrName) return { idOrName };\n    if (model) return { modelId: model };\n\n    throw new Error(\"No id or model provided!\");\n  }\n\n  async completionWithRetry<T>(\n    callback: () => T,\n    options?: this[\"ParsedCallOptions\"]\n  ) {\n    const caller = new AsyncCaller({\n      maxConcurrency: options?.maxConcurrency ?? this.maxConcurrency,\n      maxRetries: this.maxRetries,\n    });\n    const result = options\n      ? caller.callWithOptions(\n          {\n            signal: options.signal,\n          },\n          async () => callback()\n        )\n      : caller.call(async () => callback());\n\n    return result;\n  }\n\n  private async _chatModelGateway<S extends boolean = false>(\n    scopeId: ReturnType<ChatWatsonx[\"scopeId\"]>,\n    params: ReturnType<ChatWatsonx[\"invocationParams\"]>,\n    messages: ChatsMessage[],\n    signal?: AbortSignal,\n    stream: S = false as S\n  ): Promise<\n    S extends true ? Stream<ChatObjectStream> : Response<ChatsResponse>\n  > {\n    if (this.gateway) {\n      if (\"model\" in scopeId) {\n        return this.gateway.chat.completion.create({\n          ...params,\n          ...scopeId,\n          signal,\n          stream,\n          ...(stream ? { returnObject: true } : {}),\n          messages,\n        });\n      }\n      throw new Error(\n        \"No 'model' specified. Model needs to be spcified for model gateway\"\n      );\n    }\n    throw new Error(\n      \"'gateway' instance is not set. Please check your implementation\"\n    );\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (this.streaming) {\n      const stream = this._streamResponseChunks(messages, options, runManager);\n      const finalChunks: Record<number, ChatGenerationChunk> = {};\n      let tokenUsage: UsageMetadata = {\n        input_tokens: 0,\n        output_tokens: 0,\n        total_tokens: 0,\n      };\n      const tokenUsages: UsageMetadata[] = [];\n      for await (const chunk of stream) {\n        const message = chunk.message as AIMessageChunk;\n        const usageMetadata = message?.usage_metadata as UsageMetadata;\n        if (usageMetadata) {\n          const completion = chunk.generationInfo?.completion;\n          if (tokenUsages[completion])\n            tokenUsages[completion].output_tokens =\n              usageMetadata?.output_tokens;\n          else tokenUsages[completion] = usageMetadata;\n        }\n        chunk.message.response_metadata = {\n          model: this.model,\n          ...chunk.generationInfo,\n          ...chunk.message.response_metadata,\n        };\n\n        const index =\n          (chunk.generationInfo as NewTokenIndices)?.completion ?? 0;\n        if (finalChunks[index] === undefined) {\n          finalChunks[index] = chunk;\n        } else {\n          finalChunks[index] = finalChunks[index].concat(chunk);\n        }\n      }\n      tokenUsage = tokenUsages.reduce((acc, curr) => {\n        return {\n          input_tokens: acc.input_tokens + curr.input_tokens,\n          output_tokens: acc.output_tokens + curr.output_tokens,\n          total_tokens: acc.total_tokens + curr.total_tokens,\n        };\n      });\n      const generations = Object.entries(finalChunks)\n        .sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10))\n        .map(([_, value]) => value);\n      return { generations, llmOutput: { tokenUsage } };\n    } else {\n      const params = this.invocationParams(options);\n      const scopeId = this.scopeId(options);\n      const watsonxCallbacks = this.invocationCallbacks(options);\n      const watsonxMessages = _convertMessagesToWatsonxMessages(\n        messages,\n        this.model\n      );\n      const callback = () => {\n        if (this.modelGateway) {\n          return this._chatModelGateway(\n            scopeId,\n            params,\n            watsonxMessages,\n            options.signal,\n            false\n          );\n        }\n\n        if (this.service) {\n          if (\"idOrName\" in scopeId) {\n            return this.service.deploymentsTextChat(\n              {\n                ...scopeId,\n                messages: watsonxMessages,\n                signal: options?.signal,\n              },\n              watsonxCallbacks\n            );\n          }\n\n          if (\"modelId\" in scopeId)\n            return this.service.textChat(\n              {\n                ...params,\n                ...scopeId,\n                messages: watsonxMessages,\n                signal: options?.signal,\n              },\n              watsonxCallbacks\n            );\n        }\n\n        throw new Error(\n          \"No service or gateway set. Please check your intsance init\"\n        );\n      };\n\n      const { result } = await this.completionWithRetry(callback, options);\n      const generations: ChatGeneration[] = [];\n      for (const part of result.choices) {\n        const generation: ChatGeneration = {\n          text: part.message?.content ?? \"\",\n          message: _watsonxResponseToChatMessage(\n            part,\n            result.id,\n            result?.usage\n          ),\n        };\n        if (part.finish_reason) {\n          generation.generationInfo = { finish_reason: part.finish_reason };\n        }\n        generations.push(generation);\n      }\n\n      return {\n        generations,\n        llmOutput: {\n          tokenUsage: result?.usage,\n          model_name: this.model,\n          model: this.model,\n        },\n      };\n    }\n  }\n\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const params = this.invocationParams(options);\n    const scopeId = this.scopeId(options);\n    const watsonxMessages = _convertMessagesToWatsonxMessages(\n      messages,\n      this.model\n    );\n    const watsonxCallbacks = this.invocationCallbacks(options);\n    const { signal } = options;\n    const callback = () => {\n      if (this.modelGateway) {\n        return this._chatModelGateway(\n          scopeId,\n          params,\n          watsonxMessages,\n          signal,\n          true\n        );\n      }\n      if (this.service) {\n        if (\"idOrName\" in scopeId)\n          return this.service.deploymentsTextChatStream(\n            {\n              ...scopeId,\n              messages: watsonxMessages,\n              returnObject: true,\n              signal,\n            },\n            watsonxCallbacks\n          );\n        if (\"modelId\" in scopeId)\n          return this.service.textChatStream(\n            {\n              ...params,\n              ...scopeId,\n              messages: watsonxMessages,\n              returnObject: true,\n              signal,\n            },\n            watsonxCallbacks\n          );\n\n        throw new Error(\n          \"No idOrName or modelId specified. At least one of these needs to be specified in basic mode\"\n        );\n      }\n      throw new Error(\n        \"No service or gateway set. Please check your intsance init\"\n      );\n    };\n    const stream = await this.completionWithRetry(callback, options);\n    let defaultRole;\n    let usage: TextChatUsage | undefined;\n    let currentCompletion = 0;\n    const counter = { value: -1 };\n    for await (const chunk of stream) {\n      if (chunk?.data?.usage) usage = chunk.data.usage;\n      const { data } = chunk;\n      const choice = data.choices[0] as TextChatResultChoice &\n        Record<\"delta\", TextChatResultMessage>;\n\n      if (choice && !(\"delta\" in choice)) {\n        continue;\n      }\n      const delta = choice?.delta;\n      if (!delta) {\n        continue;\n      }\n\n      currentCompletion = choice.index ?? 0;\n      const newTokenIndices = {\n        prompt: options.promptIndex ?? 0,\n        completion: choice.index ?? 0,\n      };\n\n      const generationInfo = {\n        ...newTokenIndices,\n        finish_reason: choice.finish_reason,\n      };\n\n      const message = _convertDeltaToMessageChunk(\n        counter,\n        delta,\n        data,\n        this.model,\n        chunk.data.usage,\n        defaultRole\n      );\n      defaultRole = (delta.role ||\n        defaultRole) as TextChatMessagesTextChatMessageAssistant.Constants.Role;\n\n      if (\n        message === null ||\n        (!delta.content && !delta.tool_calls && delta.role === \"assistant\")\n      ) {\n        continue;\n      }\n      const generationChunk = new ChatGenerationChunk({\n        message,\n        text: delta.content ?? \"\",\n        generationInfo,\n      });\n\n      yield generationChunk;\n      // eslint-disable-next-line no-void\n      void _runManager?.handleLLMNewToken(\n        generationChunk.text,\n        newTokenIndices,\n        undefined,\n        undefined,\n        undefined,\n        { chunk: generationChunk }\n      );\n    }\n\n    const generationChunk = new ChatGenerationChunk({\n      message: new AIMessageChunk({\n        content: \"\",\n        response_metadata: {\n          model: this.model,\n          usage,\n        },\n        usage_metadata: {\n          input_tokens: usage?.prompt_tokens ?? 0,\n          output_tokens: usage?.completion_tokens ?? 0,\n          total_tokens: usage?.total_tokens ?? 0,\n        },\n      }),\n      text: \"\",\n      generationInfo: {\n        prompt: options.promptIndex ?? 0,\n        completion: currentCompletion ?? 0,\n      },\n    });\n    yield generationChunk;\n  }\n\n  /** @ignore */\n  _combineLLMOutput() {\n    return [];\n  }\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        { raw: BaseMessage; parsed: RunOutput }\n      > {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: InteropZodType<RunOutput> | Record<string, any> =\n      outputSchema;\n    const name = config?.name;\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    let functionName = name ?? \"extract\";\n    let outputParser: BaseLLMOutputParser<RunOutput>;\n    let llm: Runnable<BaseLanguageModelInput>;\n    if (method === \"jsonMode\") {\n      let outputFormatSchema: JsonSchema7Type | undefined;\n      if (isInteropZodSchema(schema)) {\n        outputParser = StructuredOutputParser.fromZodSchema(schema);\n        outputFormatSchema = toJsonSchema(schema);\n      } else {\n        outputParser = new JsonOutputParser<RunOutput>();\n      }\n      const options = {\n        responseFormat: { type: \"json_object\" },\n        ls_structured_output_format: {\n          kwargs: { method: \"jsonMode\" },\n          schema: outputFormatSchema,\n        },\n      } as Partial<CallOptions>;\n      llm = this.withConfig(options);\n    } else {\n      if (isInteropZodSchema(schema)) {\n        const asJsonSchema = toJsonSchema(schema);\n        llm = this.withConfig({\n          tools: [\n            {\n              type: \"function\" as const,\n              function: {\n                name: functionName,\n                description:\n                  asJsonSchema.description ?? `Tool: ${functionName}`,\n                parameters: asJsonSchema,\n              },\n            },\n          ],\n          // Ideally that would be set to required but this is not supported yet\n          tool_choice: {\n            type: \"function\",\n            function: {\n              name: functionName,\n            },\n          },\n          ls_structured_output_format: {\n            kwargs: { method: \"functionCalling\" },\n            schema: asJsonSchema,\n          },\n        } as Partial<CallOptions>);\n        outputParser = new WatsonxToolsOutputParser({\n          returnSingle: true,\n          keyName: functionName,\n          zodSchema: schema,\n        });\n      } else {\n        let openAIFunctionDefinition: FunctionDefinition;\n        if (\n          typeof schema.name === \"string\" &&\n          typeof schema.parameters === \"object\" &&\n          schema.parameters != null\n        ) {\n          openAIFunctionDefinition = schema as FunctionDefinition;\n          functionName = schema.name;\n        } else {\n          openAIFunctionDefinition = {\n            name: functionName,\n            description: schema.description ?? \"\",\n            parameters: schema,\n          };\n        }\n        llm = this.withConfig({\n          tools: [\n            {\n              type: \"function\" as const,\n              function: openAIFunctionDefinition,\n            },\n          ],\n          tool_choice: {\n            type: \"function\" as const,\n            function: {\n              name: functionName,\n            },\n          },\n          ls_structured_output_format: {\n            kwargs: { method: \"functionCalling\" },\n            schema: toJsonSchema(schema),\n          },\n        } as Partial<CallOptions>);\n        outputParser = new WatsonxToolsOutputParser<RunOutput>({\n          returnSingle: true,\n          keyName: functionName,\n        });\n      }\n    }\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser) as Runnable<\n        BaseLanguageModelInput,\n        RunOutput\n      >;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;AA0KA,SAAS,sBAAsBA,OAAeC,cAA8B;AAC1E,KAAI,MAAM,WAAW,YAAY,IAAI,aACnC,QAAO,sCAAsC,aAAa;AAC5D,QAAO;AACR;AAOD,SAAS,0BACPC,OACoC;AACpC,QAAO,MAAM,IAAI,CAAC,SAAS;AACzB,MAAI,UAAU,KACZ,QAAO;EAGT,MAAM,aAAa,mBAAmB,KAAK,OAAO,GAC9C,aAAa,KAAK,OAAO,GACzB,KAAK;AAET,SAAO;GACL,MAAM;GACN,UAAU;IACR,MAAM,KAAK;IACX,aAAa,KAAK,eAAe,CAAC,MAAM,EAAE,KAAK,MAAM;IACrD;GACD;EACF;CACF,EAAC;AACH;AACD,MAAMC,2BAAwD;CAC5D,OAAO;CACP,IAAI;CACJ,QAAQ;CACR,MAAM;CACN,UAAU;CACV,SAAS;CACT,WAAW;CACX,QAAQ;AACT;AAED,MAAM,UAAU,CAACC,SAA8B;CAC7C,MAAM,aAAa,yBAAyB;AAC5C,KAAI,CAAC,WACH,OAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,MAAM;AAEjD,QAAO;AACR;AAED,MAAM,eAAe,CAACC,SAAsBC,UAAmB;AAC7D,KAAI,YAAY,QAAQ,IAAI,QAAQ,YAAY,OAC9C,QAAO,QAAQ,WACZ,IAAI,CAAC,cAAc;EAClB,GAAG;EACH,IAAI,sBAAsB,SAAS,IAAI,SAAS,MAAM,GAAG;CAC1D,GAAE,CACF,IAAI,iCAAiC;AAE1C,QAAO;AACR;AAED,SAAS,kCACPC,UACAD,OAC0C;AAC1C,QAAO,SAAS,IAAI,CAAC,YAAY;EAC/B,MAAM,YAAY,aAAa,SAAS,MAAM;EAC9C,MAAM,UAAU,cAAc,SAAY,QAAQ,UAAU;AAC5D,MAAI,kBAAkB,WAAW,OAAO,QAAQ,iBAAiB,SAC/D,QAAO;GACL,MAAM,QAAQ,QAAQ,SAAS,CAAC;GAChC;GACA,MAAM,QAAQ;GACd,cAAc,sBAAsB,SAAS,IAAI,QAAQ,aAAa;EACvE;AAGH,SAAO;GACL,MAAM,QAAQ,QAAQ,SAAS,CAAC;GAChC;GACA,YAAY;EACb;CACF,EAAC;AACH;AAED,SAAS,8BACPE,QACAC,WACAC,OACa;CACb,MAAM,EAAE,SAAS,GAAG;AACpB,KAAI,CAAC,QAAS,OAAM,IAAI,MAAM;CAC9B,MAAM,eAAe,QAAQ,cAAc,CAAE;AAE7C,SAAQ,QAAQ,MAAhB;EACE,KAAK,aAAa;GAChB,MAAM,YAAY,CAAE;GACpB,MAAM,mBAAmB,CAAE;AAC3B,QAAK,MAAM,eAAe,aACxB,KAAI;IACF,MAAM,SAAS,cAAc,aAAa,EAAE,UAAU,KAAM,EAAC;IAC7D,UAAU,KAAK,OAAO;GACvB,SAAQC,GAAY;IACnB,iBAAiB,KACf,oBAAoB,aAAc,EAAY,QAAQ,CACvD;GACF;GAEH,MAAMC,oBAA6C;IACjD,YAAY,aAAa,IAAI,CAAC,cAAc;KAC1C,GAAG;KACH,MAAM;IACP,GAAE;IACH,GAAI,uBAAuB,UACvB,EAAE,WAAW,SAAS,kBAAmB,IACzC,CAAE;GACP;AAED,UAAO,IAAI,UAAU;IACnB,IAAI;IACJ,SAAS,QAAQ,WAAW;IAC5B,YAAY;IACZ,oBAAoB;IACpB;IACA,gBAAgB,QACZ;KACE,cAAc,MAAM,iBAAiB;KACrC,eAAe,MAAM,qBAAqB;KAC1C,cAAc,MAAM,gBAAgB;IACrC,IACD;GACL;EACF;EACD,QACE,QAAO,IAAI,YAAY,QAAQ,WAAW,IAAI,QAAQ,QAAQ;CACjE;AACF;AAED,SAAS,4BACPC,aACAC,OACAC,SACAT,OACAI,OACAM,aACA;AACA,KAAI,MAAM,QAAS,OAAM,IAAI,MAAM,MAAM;CAEzC,MAAM,eAAe,MAAM,YAAY,SACnC,MAAM,YAAY,IAChB,CACE,UACA,UAC2D;EAC3D,MAAM,UACJ,SAAS,MAAM,SAAS,OAAO,KAC3B,sBAAsB,SAAS,IAAI,SAAS,GAAG,GAC/C;AACN,MAAI,SAAS,IAAI,YAAY,SAAS;AACtC,SAAO;GACL,OACE,OAAO,cAAc,OAAO,YAAY,SAAS,IAC7C,QACA,YAAY;GAClB,GAAG;GACH,GAAI,YAAY,QAAQ,EAAE,IAAI,QAAS;GACvC,MAAM;EACP;CACF,EACF,GACD;CAEJ,MAAM,OAAO,MAAM,QAAQ,eAAe;CAC1C,MAAM,UAAU,MAAM,WAAW;CACjC,MAAM,oBAAoB;EACxB,GAAI,eAAe,EAAE,YAAY,aAAc,IAAG,CAAE;EACpD,GAAI,uBAAuB,QACvB,EAAE,WAAW,OAAO,kBAAmB,IACvC,CAAE;CACP;CAED,MAAM,gBAAgB;EACpB,cAAc,OAAO,iBAAiB;EACtC,eAAe,OAAO,qBAAqB;EAC3C,cAAc,OAAO,gBAAgB;CACtC;AACD,SAAQ,MAAR;EACE,KAAK,OACH,QAAO,IAAI,kBAAkB,EAAE,QAAS;EAE1C,KAAK,aAAa;GAEhB,MAAMC,iBAAkC,CAAE;AAC1C,OAAI,gBAAgB,cAAc,SAAS,EACzC,MAAK,MAAM,oBAAoB,cAAc;IAC3C,MAAM,eAAe,iBAAiB,SAAS;IAC/C,eAAe,KAAK;KAClB,MAAM,aAAa,SAAS,IAAI,eAAe;KAC/C,MAAM,iBAAiB,UAAU;KACjC,IAAI,iBAAiB;KACrB,OAAO,iBAAiB;KACxB,MAAM;IACP,EAAC;GACH;AAGH,UAAO,IAAI,eAAe;IACxB;IACA,kBAAkB;IAClB;IACA,gBAAgB;IAChB,IAAI,QAAQ;GACb;EACF;EAED,KAAK;AACH,OAAI,aACF,QAAO,IAAI,iBAAiB;IAC1B;IACA;IACA,cAAc,sBAAsB,SAAS,IAAI,aAAa,GAAG,GAAG;GACrE;AAEH,UAAO;EAET,KAAK,WACH,QAAO,IAAI,qBAAqB;GAC9B;GACA;EACD;EAEH,QACE,QAAO,IAAI,iBAAiB;GAAE;GAAS;EAAM;CAChD;AACF;AAED,SAAS,sCACPC,YACA;AACA,KAAI,OAAO,eAAe,SACxB,KAAI,eAAe,SAAS,eAAe,WACzC,QAAO,EAAE,kBAAkB,WAAY;UAC9B,eAAe,UAAU,eAAe,OACjD,QAAO,EAAE,kBAAkB,WAAY;KAEvC,QAAO,EACL,YAAY;EACV,MAAM;EACN,UAAU,EAAE,MAAM,WAAY;CAC/B,EACF;UAEM,UAAU,WAAY,QAAO,EAAE,WAAY;KAEpD,OAAM,IAAI,MACR,CAAC,mFAAmF,EAAE,YAAY;AAEvG;AAeD,IAAa,cAAb,cAGU,cAEV;CACE,OAAO,UAAU;AACf,SAAO;CACR;CAED,kBAAkB;CAElB,IAAI,aAAwC;AAC1C,SAAO;GACL,eAAe;GACf,QAAQ;GACR,QAAQ;GACR,mBAAmB;GACnB,iBAAiB;GACjB,sBAAsB;GACtB,mBAAmB;GACnB,mBAAmB;GACnB,cAAc;EACf;CACF;CAED,IAAI,aAAwC;AAC1C,SAAO;GACL,eAAe;GACf,QAAQ;GACR,QAAQ;GACR,mBAAmB;GACnB,iBAAiB;GACjB,sBAAsB;GACtB,mBAAmB;GACnB,mBAAmB;GACnB,cAAc;EACf;CACF;CAED,YAAYC,SAAqD;EAC/D,MAAM,SAAS,KAAK,iBAAiB,QAAQ;AAC7C,SAAO;GACL,aAAa;GACb,eAAe,KAAK;GACpB,eAAe;GACf,gBAAgB,OAAO,eAAe;GACtC,eAAe,OAAO,aAAa;EACpC;CACF;CAED,AAAQ,qBACNC,QACA,qBAAqB,MACrB;EACA,MAAM,kBAAkB;GACtB,gBAAgB;IACd;IACA;IACA;IACA;IACA;IACA;IACA;IACA;GACD;GAED,MAAM;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;GACD;GAED,QAAQ;IACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;GACD;GAED,SAAS;IACP;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;GACD;GAED,YAAY,CAAC,UAAW;GAExB,kBAAkB;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;GACD;EACF;EAED,MAAMC,aAAuB,CAAC,GAAG,gBAAgB,cAAe;AAEhE,MAAI,oBACF,WAAW,KAAK,GAAG,gBAAgB,MAAM,GAAG,gBAAgB,OAAO;AAGrE,MAAI,KAAK,cACP,WAAW,KAAK,GAAG,gBAAgB,QAAQ;WAClC,KAAK,UACd,WAAW,KAAK,GAAG,gBAAgB,WAAW;WACrC,KAAK,WAAW,KAAK,WAC9B,WAAW,KAAK,GAAG,gBAAgB,iBAAiB;EAGtD,gBAAgB,QAAQ,WAAW;CACpC;CAED,AAAU;CAEV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"}