{"version":3,"file":"agent.d.ts","names":["DefaultToolCall","AIMessage","ToolCallWithResult","BagTemplate","BaseStream","UseStreamOptions","UseAgentStream","Record","StateType","ToolCall","Bag","UseAgentStreamOptions"],"sources":["../../../src/ui/stream/agent.d.ts"],"sourcesContent":["/**\n * Stream types for ReactAgent instances created with `createAgent`.\n *\n * This module provides the stream interface that adds tool calling capabilities\n * on top of the base graph streaming functionality.\n *\n * @module\n */\nimport type { DefaultToolCall, AIMessage, ToolCallWithResult } from \"../../types.messages.js\";\nimport type { BagTemplate } from \"../../types.template.js\";\nimport type { BaseStream } from \"./base.js\";\nimport type { UseStreamOptions } from \"../types.js\";\n/**\n * Stream interface for ReactAgent instances created with `createAgent`.\n *\n * Extends {@link UseGraphStream} with tool calling capabilities. Tool calls are\n * automatically typed based on the agent's tools configuration.\n *\n * Use this interface when streaming from an agent created with `createAgent`.\n * For subagent streaming capabilities, use {@link UseDeepAgentStream} with `createDeepAgent`.\n *\n * @experimental This interface is subject to change.\n *\n * @template StateType - The agent's state type (base + middleware states)\n * @template ToolCall - Tool call type inferred from agent's tools\n * @template Bag - Type configuration bag\n *\n * @example\n * ```typescript\n * import { createAgent, tool } from \"@langchain/langgraph\";\n * import { useStream } from \"@langchain/langgraph-sdk/react\";\n * import { z } from \"zod\";\n *\n * // Define tools with typed schemas\n * const searchTool = tool(\n *   async ({ query }) => `Results for: ${query}`,\n *   { name: \"search\", schema: z.object({ query: z.string() }) }\n * );\n *\n * const calculatorTool = tool(\n *   async ({ expression }) => eval(expression).toString(),\n *   { name: \"calculator\", schema: z.object({ expression: z.string() }) }\n * );\n *\n * // Create the agent\n * const agent = createAgent({\n *   model: \"gpt-4\",\n *   tools: [searchTool, calculatorTool],\n * });\n *\n * // In React component:\n * function Chat() {\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"my-agent\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // Tool calls are typed!\n *   stream.toolCalls.forEach(tc => {\n *     if (tc.call.name === \"search\") {\n *       // tc.call.args is typed as { query: string }\n *       console.log(\"Searching for:\", tc.call.args.query);\n *     } else if (tc.call.name === \"calculator\") {\n *       // tc.call.args is typed as { expression: string }\n *       console.log(\"Calculating:\", tc.call.args.expression);\n *     }\n *   });\n * }\n * ```\n *\n * @remarks\n * This interface adds tool calling on top of {@link UseGraphStream}:\n * - `toolCalls` - Array of tool calls paired with their results\n * - `getToolCalls(message)` - Get tool calls for a specific AI message\n *\n * It does NOT include subagent streaming features. For those, use\n * {@link UseDeepAgentStream} with `createDeepAgent`.\n */\nexport interface UseAgentStream<StateType extends Record<string, unknown> = Record<string, unknown>, ToolCall = DefaultToolCall, Bag extends BagTemplate = BagTemplate> extends BaseStream<StateType, ToolCall, Bag> {\n    /**\n     * Tool calls paired with their results.\n     *\n     * Each entry contains the tool call request and its corresponding result.\n     * Useful for rendering tool invocations and their outputs together.\n     *\n     * @example\n     * ```typescript\n     * stream.toolCalls.map(({ call, result }) => (\n     *   <ToolCallCard\n     *     name={call.name}\n     *     args={call.args}\n     *     result={result}\n     *   />\n     * ));\n     * ```\n     */\n    toolCalls: ToolCallWithResult<ToolCall>[];\n    /**\n     * Get tool calls for a specific AI message.\n     *\n     * Use this to find which tool calls were initiated by a particular\n     * assistant message, useful for rendering tool calls inline with messages.\n     *\n     * @param message - The AI message to get tool calls for\n     * @returns Array of tool calls initiated by the message\n     *\n     * @example\n     * ```typescript\n     * messages.map(message => {\n     *   if (message.type === \"ai\") {\n     *     const calls = stream.getToolCalls(message);\n     *     return (\n     *       <>\n     *         <MessageBubble message={message} />\n     *         {calls.map(tc => <ToolCallCard key={tc.call.id} {...tc} />)}\n     *       </>\n     *     );\n     *   }\n     *   return <MessageBubble message={message} />;\n     * });\n     * ```\n     */\n    getToolCalls: (message: AIMessage<ToolCall>) => ToolCallWithResult<ToolCall>[];\n}\n/**\n * Options for configuring an agent stream.\n *\n * Use this options interface when calling `useStream` with a ReactAgent\n * created via `createAgent`.\n *\n * @experimental This interface is subject to change.\n *\n * @template StateType - The agent's state type\n * @template Bag - Type configuration bag\n *\n * @example\n * ```typescript\n * const stream = useStream<typeof agent>({\n *   assistantId: \"my-agent\",\n *   apiUrl: \"http://localhost:2024\",\n *   onError: (error) => console.error(error),\n * });\n * ```\n */\nexport interface UseAgentStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> extends UseStreamOptions<StateType, Bag> {\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAgJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAlEiBM,iCAAiCC,0BAA0BA,oCAAoCP,6BAA6BG,cAAcA,qBAAqBC,WAAWI,WAAWC,UAAUC;;;;;;;;;;;;;;;;;;aAkBjMR,mBAAmBO;;;;;;;;;;;;;;;;;;;;;;;;;;0BA0BNR,UAAUQ,cAAcP,mBAAmBO;;;;;;;;;;;;;;;;;;;;;;UAsBtDE,wCAAwCJ,0BAA0BA,qCAAqCJ,cAAcA,qBAAqBE,iBAAiBG,WAAWE"}