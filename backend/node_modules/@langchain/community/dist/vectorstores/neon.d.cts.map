{"version":3,"file":"neon.d.cts","names":["EmbeddingsInterface","VectorStore","Document","Metadata","Record","NeonPostgresArgs","NeonPostgres","Promise"],"sources":["../../src/vectorstores/neon.d.ts"],"sourcesContent":["import type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\ntype Metadata = Record<string, string | number | Record<\"in\", string[]>>;\n/**\n * Interface that defines the arguments required to create a\n * `NeonPostgres` instance. It includes Postgres connection options,\n * table name, filter, and verbosity level.\n */\nexport interface NeonPostgresArgs {\n    connectionString: string;\n    tableName?: string;\n    schemaName?: string;\n    columns?: {\n        idColumnName?: string;\n        vectorColumnName?: string;\n        contentColumnName?: string;\n        metadataColumnName?: string;\n    };\n    filter?: Metadata;\n    verbose?: boolean;\n}\n/**\n * Class that provides an interface to a Neon Postgres database. It\n * extends the `VectorStore` base class and implements methods for adding\n * documents and vectors, performing similarity searches, and ensuring the\n * existence of a table in the database.\n */\nexport declare class NeonPostgres extends VectorStore {\n    FilterType: Metadata;\n    tableName: string;\n    schemaName?: string;\n    idColumnName: string;\n    vectorColumnName: string;\n    contentColumnName: string;\n    metadataColumnName: string;\n    filter?: Metadata;\n    _verbose?: boolean;\n    neonConnectionString: string;\n    _vectorstoreType(): string;\n    constructor(embeddings: EmbeddingsInterface, config: NeonPostgresArgs);\n    get computedTableName(): string;\n    /**\n     * Static method to create a new `NeonPostgres` instance from a\n     * connection. It creates a table if one does not exist.\n     *\n     * @param embeddings - Embeddings instance.\n     * @param fields - `NeonPostgresArgs` instance.\n     * @returns A new instance of `NeonPostgres`.\n     */\n    static initialize(embeddings: EmbeddingsInterface, config: NeonPostgresArgs): Promise<NeonPostgres>;\n    /**\n     * Constructs the SQL query for inserting rows into the specified table.\n     *\n     * @param rows - The rows of data to be inserted, consisting of values and records.\n     * @param chunkIndex - The starting index for generating query placeholders based on chunk positioning.\n     * @returns The complete SQL INSERT INTO query string.\n     */\n    protected runInsertQuery(rows: (string | Record<string, any>)[][], useIdColumn: boolean): Promise<Record<string, any>[]>;\n    /**\n     * Method to add vectors to the vector store. It converts the vectors into\n     * rows and inserts them into the database.\n     *\n     * @param vectors - Array of vectors.\n     * @param documents - Array of `Document` instances.\n     * @param options - Optional arguments for adding documents\n     * @returns Promise that resolves when the vectors have been added.\n     */\n    addVectors(vectors: number[][], documents: Document[], options?: {\n        ids?: string[];\n    }): Promise<string[]>;\n    /**\n     * Method to perform a similarity search in the vector store. It returns\n     * the `k` most similar documents to the query vector, along with their\n     * similarity scores.\n     *\n     * @param query - Query vector.\n     * @param k - Number of most similar documents to return.\n     * @param filter - Optional filter to apply to the search.\n     * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n     */\n    similaritySearchVectorWithScore(query: number[], k: number, filter?: this[\"FilterType\"]): Promise<[Document, number][]>;\n    /**\n     * Method to add documents to the vector store. It converts the documents into\n     * vectors, and adds them to the store.\n     *\n     * @param documents - Array of `Document` instances.\n     * @param options - Optional arguments for adding documents\n     * @returns Promise that resolves when the documents have been added.\n     */\n    addDocuments(documents: Document[], options?: {\n        ids?: string[];\n    }): Promise<string[]>;\n    /**\n     * Method to delete documents from the vector store. It deletes the\n     * documents that match the provided ids.\n     *\n     * @param ids - Array of document ids.\n     * @param deleteAll - Boolean to delete all documents.\n     * @returns Promise that resolves when the documents have been deleted.\n     */\n    delete(params: {\n        ids?: string[];\n        deleteAll?: boolean;\n    }): Promise<void>;\n    /**\n     * Method to ensure the existence of the table to store vectors in\n     * the database. It creates the table if it does not already exist.\n     *\n     * @returns Promise that resolves when the table has been ensured.\n     */\n    ensureTableInDatabase(): Promise<void>;\n    /**\n     * Static method to create a new `NeonPostgres` instance from an\n     * array of texts and their metadata. It converts the texts into\n     * `Document` instances and adds them to the store.\n     *\n     * @param texts - Array of texts.\n     * @param metadatas - Array of metadata objects or a single metadata object.\n     * @param embeddings - Embeddings instance.\n     * @param dbConfig - `NeonPostgresArgs` instance.\n     * @returns Promise that resolves with a new instance of `NeonPostgresArgs`.\n     */\n    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, dbConfig: NeonPostgresArgs): Promise<NeonPostgres>;\n    /**\n     * Static method to create a new `NeonPostgres` instance from an\n     * array of `Document` instances. It adds the documents to the store.\n     *\n     * @param docs - Array of `Document` instances.\n     * @param embeddings - Embeddings instance.\n     * @param dbConfig - `NeonPostgreseArgs` instance.\n     * @returns Promise that resolves with a new instance of `NeonPostgres`.\n     */\n    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig: NeonPostgresArgs): Promise<NeonPostgres>;\n}\nexport {};\n//# sourceMappingURL=neon.d.ts.map"],"mappings":";;;;;KAGKG,QAAAA,GAAWC,iCAAiCA;;AADI;AAOrD;AAmBA;;AAQaD,UA3BIE,gBAAAA,CA2BJF;EAIeH,gBAAAA,EAAAA,MAAAA;EAA6BK,SAAAA,CAAAA,EAAAA,MAAAA;EAUvBL,UAAAA,CAAAA,EAAAA,MAAAA;EAA6BK,OAAAA,CAAAA,EAAAA;IAA2BC,YAAAA,CAAAA,EAAAA,MAAAA;IAARC,gBAAAA,CAAAA,EAAAA,MAAAA;IAQrCH,iBAAAA,CAAAA,EAAAA,MAAAA;IAAyDA,kBAAAA,CAAAA,EAAAA,MAAAA;EAARG,CAAAA;EAU/CL,MAAAA,CAAAA,EAjDlCC,QAiDkCD;EAEvCK,OAAAA,CAAAA,EAAAA,OAAAA;;;;;;;;AAqDuGF,cA/F1FC,YAAAA,SAAqBL,WAAAA,CA+FqEI;EAA2BC,UAAAA,EA9F1HH,QA8F0HG;EAARC,SAAAA,EAAAA,MAAAA;EAUnGL,UAAAA,CAAAA,EAAAA,MAAAA;EAAwBF,YAAAA,EAAAA,MAAAA;EAA+BK,gBAAAA,EAAAA,MAAAA;EAA2BC,iBAAAA,EAAAA,MAAAA;EAARC,kBAAAA,EAAAA,MAAAA;EAzG/DN,MAAAA,CAAAA,EAQ7BE,QAR6BF;EAAW,QAAA,CAAA,EAAA,OAAA;;;0BAYzBD,6BAA6BK;;;;;;;;;;gCAUvBL,6BAA6BK,mBAAmBE,QAAQD;;;;;;;;2CAQ7CF,iDAAiDG,QAAQH;;;;;;;;;;6CAUvDF;;MAEvCK;;;;;;;;;;;4FAWsFA,SAASL;;;;;;;;;0BAS3EA;;MAEpBK;;;;;;;;;;;;MAYAA;;;;;;;2BAOqBA;;;;;;;;;;;;8EAYmDP,+BAA+BK,mBAAmBE,QAAQD;;;;;;;;;;6BAU3GJ,wBAAwBF,+BAA+BK,mBAAmBE,QAAQD"}