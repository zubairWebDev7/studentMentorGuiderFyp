{"version":3,"file":"openai_functions.js","names":["config?: { argsOnly?: boolean }","generations: Generation[] | ChatGeneration[]","config?: { argsOnly?: boolean } & BaseCumulativeTransformOutputParserInput","prev: unknown | undefined","next: unknown","generations: ChatGeneration[]","text: string","fields: { attrName: string }"],"sources":["../../src/output_parsers/openai_functions.ts"],"sourcesContent":["import { type JsonSchema7ObjectType } from \"@langchain/core/utils/json_schema\";\nimport {\n  compare,\n  type Operation as JSONPatchOperation,\n} from \"@langchain/core/utils/json_patch\";\n\nimport { ChatGeneration, Generation } from \"@langchain/core/outputs\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  type BaseCumulativeTransformOutputParserInput,\n  BaseLLMOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport { parsePartialJson } from \"@langchain/core/output_parsers\";\nimport { Optional } from \"../types/type-utils.js\";\n\n/**\n * Represents optional parameters for a function in a JSON Schema.\n */\nexport type FunctionParameters = Optional<\n  JsonSchema7ObjectType,\n  \"additionalProperties\"\n>;\n\n/**\n * Class for parsing the output of an LLM. Can be configured to return\n * only the arguments of the function call in the output.\n */\nexport class OutputFunctionsParser extends BaseLLMOutputParser<string> {\n  static lc_name() {\n    return \"OutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  argsOnly = true;\n\n  constructor(config?: { argsOnly?: boolean }) {\n    super();\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n  }\n\n  /**\n   * Parses the output and returns a string representation of the function\n   * call or its arguments.\n   * @param generations The output of the LLM to parse.\n   * @returns A string representation of the function call or its arguments.\n   */\n  async parseResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<string> {\n    if (\"message\" in generations[0]) {\n      const gen = generations[0] as ChatGeneration;\n      const functionCall = gen.message.additional_kwargs.function_call;\n      if (!functionCall) {\n        throw new Error(\n          `No function_call in message ${JSON.stringify(generations)}`\n        );\n      }\n      if (!functionCall.arguments) {\n        throw new Error(\n          `No arguments in function_call ${JSON.stringify(generations)}`\n        );\n      }\n      if (this.argsOnly) {\n        return functionCall.arguments;\n      }\n      return JSON.stringify(functionCall);\n    } else {\n      throw new Error(\n        `No message in generations ${JSON.stringify(generations)}`\n      );\n    }\n  }\n}\n\n/**\n * Class for parsing the output of an LLM into a JSON object. Uses an\n * instance of `OutputFunctionsParser` to parse the output.\n */\nexport class JsonOutputFunctionsParser<\n  Output extends object = object,\n> extends BaseCumulativeTransformOutputParser<Output> {\n  static lc_name() {\n    return \"JsonOutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  outputParser: OutputFunctionsParser;\n\n  argsOnly = true;\n\n  constructor(\n    config?: { argsOnly?: boolean } & BaseCumulativeTransformOutputParserInput\n  ) {\n    super(config);\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n    this.outputParser = new OutputFunctionsParser(config);\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): JSONPatchOperation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    const ops = compare(prev ?? {}, next);\n    return ops;\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[]\n  ): Promise<Output | undefined> {\n    const generation = generations[0];\n    if (!generation.message) {\n      return undefined;\n    }\n    const { message } = generation;\n    const functionCall = message.additional_kwargs.function_call;\n    if (!functionCall) {\n      return undefined;\n    }\n    if (this.argsOnly) {\n      return parsePartialJson(functionCall.arguments);\n    }\n\n    return {\n      ...functionCall,\n      arguments: parsePartialJson(functionCall.arguments),\n    } as Output;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parseResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<Output> {\n    const result = await this.outputParser.parseResult(generations);\n    if (!result) {\n      throw new Error(\n        `No result from \"OutputFunctionsParser\" ${JSON.stringify(generations)}`\n      );\n    }\n    return this.parse(result);\n  }\n\n  async parse(text: string): Promise<Output> {\n    try {\n      const parsedResult = JSON.parse(text);\n      if (this.argsOnly) {\n        return parsedResult;\n      }\n      parsedResult.arguments = JSON.parse(parsedResult.arguments);\n      return parsedResult;\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`\n      );\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n\n/**\n * Class for parsing the output of an LLM into a JSON object and returning\n * a specific attribute. Uses an instance of `JsonOutputFunctionsParser`\n * to parse the output.\n */\nexport class JsonKeyOutputFunctionsParser<\n  T = object,\n> extends BaseLLMOutputParser<T> {\n  static lc_name() {\n    return \"JsonKeyOutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  outputParser = new JsonOutputFunctionsParser();\n\n  attrName: string;\n\n  get lc_aliases() {\n    return {\n      attrName: \"key_name\",\n    };\n  }\n\n  constructor(fields: { attrName: string }) {\n    super(fields);\n    this.attrName = fields.attrName;\n  }\n\n  /**\n   * Parses the output and returns a specific attribute of the parsed JSON\n   * object.\n   * @param generations The output of the LLM to parse.\n   * @returns The value of a specific attribute of the parsed JSON object.\n   */\n  async parseResult(generations: Generation[] | ChatGeneration[]): Promise<T> {\n    const result = await this.outputParser.parseResult(generations);\n    return result[this.attrName as keyof typeof result] as T;\n  }\n}\n"],"mappings":";;;;;;;;AA4BA,IAAa,wBAAb,cAA2C,oBAA4B;CACrE,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAkB;CAAmB;CAElE,kBAAkB;CAElB,WAAW;CAEX,YAAYA,QAAiC;EAC3C,OAAO;EACP,KAAK,WAAW,QAAQ,YAAY,KAAK;CAC1C;;;;;;;CAQD,MAAM,YACJC,aACiB;AACjB,MAAI,aAAa,YAAY,IAAI;GAC/B,MAAM,MAAM,YAAY;GACxB,MAAM,eAAe,IAAI,QAAQ,kBAAkB;AACnD,OAAI,CAAC,aACH,OAAM,IAAI,MACR,CAAC,4BAA4B,EAAE,KAAK,UAAU,YAAY,EAAE;AAGhE,OAAI,CAAC,aAAa,UAChB,OAAM,IAAI,MACR,CAAC,8BAA8B,EAAE,KAAK,UAAU,YAAY,EAAE;AAGlE,OAAI,KAAK,SACP,QAAO,aAAa;AAEtB,UAAO,KAAK,UAAU,aAAa;EACpC,MACC,OAAM,IAAI,MACR,CAAC,0BAA0B,EAAE,KAAK,UAAU,YAAY,EAAE;CAG/D;AACF;;;;;AAMD,IAAa,4BAAb,cAEU,oCAA4C;CACpD,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAkB;CAAmB;CAElE,kBAAkB;CAElB;CAEA,WAAW;CAEX,YACEC,QACA;EACA,MAAM,OAAO;EACb,KAAK,WAAW,QAAQ,YAAY,KAAK;EACzC,KAAK,eAAe,IAAI,sBAAsB;CAC/C;CAED,AAAU,MACRC,MACAC,MACkC;AAClC,MAAI,CAAC,KACH,QAAO;EAET,MAAM,MAAM,QAAQ,QAAQ,CAAE,GAAE,KAAK;AACrC,SAAO;CACR;CAED,MAAM,mBACJC,aAC6B;EAC7B,MAAM,aAAa,YAAY;AAC/B,MAAI,CAAC,WAAW,QACd,QAAO;EAET,MAAM,EAAE,SAAS,GAAG;EACpB,MAAM,eAAe,QAAQ,kBAAkB;AAC/C,MAAI,CAAC,aACH,QAAO;AAET,MAAI,KAAK,SACP,QAAO,iBAAiB,aAAa,UAAU;AAGjD,SAAO;GACL,GAAG;GACH,WAAW,iBAAiB,aAAa,UAAU;EACpD;CACF;;;;;;;CAQD,MAAM,YACJJ,aACiB;EACjB,MAAM,SAAS,MAAM,KAAK,aAAa,YAAY,YAAY;AAC/D,MAAI,CAAC,OACH,OAAM,IAAI,MACR,CAAC,uCAAuC,EAAE,KAAK,UAAU,YAAY,EAAE;AAG3E,SAAO,KAAK,MAAM,OAAO;CAC1B;CAED,MAAM,MAAMK,MAA+B;AACzC,MAAI;GACF,MAAM,eAAe,KAAK,MAAM,KAAK;AACrC,OAAI,KAAK,SACP,QAAO;GAET,aAAa,YAAY,KAAK,MAAM,aAAa,UAAU;AAC3D,UAAO;EACR,SAAQ,GAAG;AACV,SAAM,IAAI,sBACR,CAAC,wBAAwB,EAAE,KAAK,UAAU,EAAE,GAAG;EAElD;CACF;CAED,wBAAgC;AAC9B,SAAO;CACR;AACF;;;;;;AAOD,IAAa,+BAAb,cAEU,oBAAuB;CAC/B,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAkB;CAAmB;CAElE,kBAAkB;CAElB,eAAe,IAAI;CAEnB;CAEA,IAAI,aAAa;AACf,SAAO,EACL,UAAU,WACX;CACF;CAED,YAAYC,QAA8B;EACxC,MAAM,OAAO;EACb,KAAK,WAAW,OAAO;CACxB;;;;;;;CAQD,MAAM,YAAYN,aAA0D;EAC1E,MAAM,SAAS,MAAM,KAAK,aAAa,YAAY,YAAY;AAC/D,SAAO,OAAO,KAAK;CACpB;AACF"}