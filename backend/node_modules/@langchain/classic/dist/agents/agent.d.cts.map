{"version":3,"file":"agent.d.cts","names":["StructuredToolInterface","ToolInterface","BaseLanguageModelInterface","CallbackManager","Callbacks","BasePromptTemplate","AgentAction","AgentFinish","AgentStep","BaseMessage","ChainValues","Serializable","Runnable","RunnableConfig","RunnableSequence","RunnableLike","LLMChain","AgentActionOutputParser","AgentInput","RunnableMultiActionAgentInput","RunnableSingleActionAgentInput","SerializedAgent","StoppingMethod","OutputParserArgs","Record","BaseAgent","Promise","BaseSingleActionAgent","BaseMultiActionAgent","isRunnableAgent","AgentRunnableSequence","RunInput","RunOutput","Error","Exclude","RunnableSingleActionAgent","RunnableMultiActionAgent","RunnableAgent","LLMSingleActionAgentInput","LLMSingleActionAgent","AgentArgs","Agent"],"sources":["../../src/agents/agent.d.ts"],"sourcesContent":["import type { StructuredToolInterface, ToolInterface } from \"@langchain/core/tools\";\nimport type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { CallbackManager, Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { AgentAction, AgentFinish, AgentStep } from \"@langchain/core/agents\";\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport { Runnable, type RunnableConfig, RunnableSequence, RunnableLike } from \"@langchain/core/runnables\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport type { AgentActionOutputParser, AgentInput, RunnableMultiActionAgentInput, RunnableSingleActionAgentInput, SerializedAgent, StoppingMethod } from \"./types.js\";\n/**\n * Record type for arguments passed to output parsers.\n */\nexport type OutputParserArgs = Record<string, any>;\n/**\n * Abstract base class for agents in LangChain. Provides common\n * functionality for agents, such as handling inputs and outputs.\n */\nexport declare abstract class BaseAgent extends Serializable {\n    ToolType: StructuredToolInterface;\n    abstract get inputKeys(): string[];\n    get returnValues(): string[];\n    get allowedTools(): string[] | undefined;\n    /**\n     * Return the string type key uniquely identifying this class of agent.\n     */\n    _agentType(): string;\n    /**\n     * Return the string type key uniquely identifying multi or single action agents.\n     */\n    abstract _agentActionType(): string;\n    /**\n     * Return response when agent has been stopped due to max iterations\n     */\n    returnStoppedResponse(earlyStoppingMethod: StoppingMethod, _steps: AgentStep[], _inputs: ChainValues, _callbackManager?: CallbackManager): Promise<AgentFinish>;\n    /**\n     * Prepare the agent for output, if needed\n     */\n    prepareForOutput(_returnValues: AgentFinish[\"returnValues\"], _steps: AgentStep[]): Promise<AgentFinish[\"returnValues\"]>;\n}\n/**\n * Abstract base class for single action agents in LangChain. Extends the\n * BaseAgent class and provides additional functionality specific to\n * single action agents.\n */\nexport declare abstract class BaseSingleActionAgent extends BaseAgent {\n    _agentActionType(): string;\n    /**\n     * Decide what to do, given some input.\n     *\n     * @param steps - Steps the LLM has taken so far, along with observations from each.\n     * @param inputs - User inputs.\n     * @param callbackManager - Callback manager.\n     *\n     * @returns Action specifying what tool to use.\n     */\n    abstract plan(steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager, config?: RunnableConfig): Promise<AgentAction | AgentFinish>;\n}\n/**\n * Abstract base class for multi-action agents in LangChain. Extends the\n * BaseAgent class and provides additional functionality specific to\n * multi-action agents.\n */\nexport declare abstract class BaseMultiActionAgent extends BaseAgent {\n    _agentActionType(): string;\n    /**\n     * Decide what to do, given some input.\n     *\n     * @param steps - Steps the LLM has taken so far, along with observations from each.\n     * @param inputs - User inputs.\n     * @param callbackManager - Callback manager.\n     *\n     * @returns Actions specifying what tools to use.\n     */\n    abstract plan(steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager, config?: RunnableConfig): Promise<AgentAction[] | AgentFinish>;\n}\nexport declare function isRunnableAgent(x: BaseAgent): boolean;\nexport declare class AgentRunnableSequence<RunInput = any, RunOutput = any> extends RunnableSequence<RunInput, RunOutput> {\n    streamRunnable?: boolean;\n    singleAction: boolean;\n    static fromRunnables<RunInput = any, RunOutput = any>([first, ...runnables]: [\n        RunnableLike<RunInput>,\n        ...RunnableLike[],\n        RunnableLike<any, RunOutput>\n    ], config: {\n        singleAction: boolean;\n        streamRunnable?: boolean;\n        name?: string;\n    }): AgentRunnableSequence<RunInput, Exclude<RunOutput, Error>>;\n    static isAgentRunnableSequence(x: Runnable): x is AgentRunnableSequence;\n}\n/**\n * Class representing a single-action agent powered by runnables.\n * Extends the BaseSingleActionAgent class and provides methods for\n * planning agent actions with runnables.\n */\nexport declare class RunnableSingleActionAgent extends BaseSingleActionAgent {\n    lc_namespace: string[];\n    runnable: Runnable<ChainValues & {\n        steps: AgentStep[];\n    }, AgentAction | AgentFinish>;\n    get inputKeys(): string[];\n    /**\n     * Whether to stream from the runnable or not.\n     * If true, the underlying LLM is invoked in a streaming fashion to make it\n     * possible to get access to the individual LLM tokens when using\n     * `streamLog` with the Agent Executor. If false then LLM is invoked in a\n     * non-streaming fashion and individual LLM tokens will not be available\n     * in `streamLog`.\n     *\n     * Note that the runnable should still only stream a single action or\n     * finish chunk.\n     */\n    streamRunnable: boolean;\n    defaultRunName: string;\n    constructor(fields: RunnableSingleActionAgentInput);\n    plan(steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager, config?: RunnableConfig): Promise<AgentAction | AgentFinish>;\n}\n/**\n * Class representing a multi-action agent powered by runnables.\n * Extends the BaseMultiActionAgent class and provides methods for\n * planning agent actions with runnables.\n */\nexport declare class RunnableMultiActionAgent extends BaseMultiActionAgent {\n    lc_namespace: string[];\n    runnable: Runnable<ChainValues & {\n        steps: AgentStep[];\n    }, AgentAction[] | AgentAction | AgentFinish>;\n    defaultRunName: string;\n    stop?: string[];\n    streamRunnable: boolean;\n    get inputKeys(): string[];\n    constructor(fields: RunnableMultiActionAgentInput);\n    plan(steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager, config?: RunnableConfig): Promise<AgentAction[] | AgentFinish>;\n}\nexport declare class RunnableAgent extends RunnableMultiActionAgent {\n}\n/**\n * Interface for input data for creating a LLMSingleActionAgent.\n */\nexport interface LLMSingleActionAgentInput {\n    llmChain: LLMChain;\n    outputParser: AgentActionOutputParser;\n    stop?: string[];\n}\n/**\n * Class representing a single action agent using a LLMChain in LangChain.\n * Extends the BaseSingleActionAgent class and provides methods for\n * planning agent actions based on LLMChain outputs.\n * @example\n * ```typescript\n * const customPromptTemplate = new CustomPromptTemplate({\n *   tools: [new Calculator()],\n *   inputVariables: [\"input\", \"agent_scratchpad\"],\n * });\n * const customOutputParser = new CustomOutputParser();\n * const agent = new LLMSingleActionAgent({\n *   llmChain: new LLMChain({\n *     prompt: customPromptTemplate,\n *     llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0 }),\n *   }),\n *   outputParser: customOutputParser,\n *   stop: [\"\\nObservation\"],\n * });\n * const executor = new AgentExecutor({\n *   agent,\n *   tools: [new Calculator()],\n * });\n * const result = await executor.invoke({\n *   input:\n *     \"Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?\",\n * });\n * ```\n */\nexport declare class LLMSingleActionAgent extends BaseSingleActionAgent {\n    lc_namespace: string[];\n    llmChain: LLMChain;\n    outputParser: AgentActionOutputParser;\n    stop?: string[];\n    constructor(input: LLMSingleActionAgentInput);\n    get inputKeys(): string[];\n    /**\n     * Decide what to do given some input.\n     *\n     * @param steps - Steps the LLM has taken so far, along with observations from each.\n     * @param inputs - User inputs.\n     * @param callbackManager - Callback manager.\n     *\n     * @returns Action specifying what tool to use.\n     */\n    plan(steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager): Promise<AgentAction | AgentFinish>;\n}\n/**\n * Interface for arguments used to create an agent in LangChain.\n */\nexport interface AgentArgs {\n    outputParser?: AgentActionOutputParser;\n    callbacks?: Callbacks;\n    /**\n     * @deprecated Use `callbacks` instead.\n     */\n    callbackManager?: CallbackManager;\n}\n/**\n * Class responsible for calling a language model and deciding an action.\n *\n * @remarks This is driven by an LLMChain. The prompt in the LLMChain *must*\n * include a variable called \"agent_scratchpad\" where the agent can put its\n * intermediary work.\n */\nexport declare abstract class Agent extends BaseSingleActionAgent {\n    llmChain: LLMChain;\n    outputParser: AgentActionOutputParser | undefined;\n    private _allowedTools?;\n    get allowedTools(): string[] | undefined;\n    get inputKeys(): string[];\n    constructor(input: AgentInput);\n    /**\n     * Prefix to append the observation with.\n     */\n    abstract observationPrefix(): string;\n    /**\n     * Prefix to append the LLM call with.\n     */\n    abstract llmPrefix(): string;\n    /**\n     * Return the string type key uniquely identifying this class of agent.\n     */\n    abstract _agentType(): string;\n    /**\n     * Get the default output parser for this agent.\n     */\n    static getDefaultOutputParser(_fields?: OutputParserArgs): AgentActionOutputParser;\n    /**\n     * Create a prompt for this class\n     *\n     * @param _tools - List of tools the agent will have access to, used to format the prompt.\n     * @param _fields - Additional fields used to format the prompt.\n     *\n     * @returns A PromptTemplate assembled from the given tools and fields.\n     * */\n    static createPrompt(_tools: StructuredToolInterface[], _fields?: Record<string, any>): BasePromptTemplate;\n    /** Construct an agent from an LLM and a list of tools */\n    static fromLLMAndTools(_llm: BaseLanguageModelInterface, _tools: StructuredToolInterface[], _args?: AgentArgs): Agent;\n    /**\n     * Validate that appropriate tools are passed in\n     */\n    static validateTools(_tools: StructuredToolInterface[]): void;\n    _stop(): string[];\n    /**\n     * Name of tool to use to terminate the chain.\n     */\n    finishToolName(): string;\n    /**\n     * Construct a scratchpad to let the agent continue its thought process\n     */\n    constructScratchPad(steps: AgentStep[]): Promise<string | BaseMessage[]>;\n    private _plan;\n    /**\n     * Decide what to do given some input.\n     *\n     * @param steps - Steps the LLM has taken so far, along with observations from each.\n     * @param inputs - User inputs.\n     * @param callbackManager - Callback manager to use for this call.\n     *\n     * @returns Action specifying what tool to use.\n     */\n    plan(steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager): Promise<AgentAction | AgentFinish>;\n    /**\n     * Return response when agent has been stopped due to max iterations\n     */\n    returnStoppedResponse(earlyStoppingMethod: StoppingMethod, steps: AgentStep[], inputs: ChainValues, callbackManager?: CallbackManager): Promise<AgentFinish>;\n    /**\n     * Load an agent from a json-like object describing it.\n     */\n    static deserialize(data: SerializedAgent & {\n        llm?: BaseLanguageModelInterface;\n        tools?: ToolInterface[];\n    }): Promise<Agent>;\n}\n//# sourceMappingURL=agent.d.ts.map"],"mappings":"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"}