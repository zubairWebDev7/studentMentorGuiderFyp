{"version":3,"file":"base.d.ts","names":["ExpressionNode","Program","ExpressionStatement","CallExpression","StringLiteral","NumericLiteral","BooleanLiteral","Identifier","ObjectExpression","ArrayExpression","PropertyAssignment","MemberExpression","ParseFunction","NodeHandler","Promise","ASTParser"],"sources":["../../../src/output_parsers/expression_type_handlers/base.d.ts"],"sourcesContent":["import type { ExpressionNode, Program, ExpressionStatement, CallExpression, StringLiteral, NumericLiteral, BooleanLiteral, Identifier, ObjectExpression, ArrayExpression, PropertyAssignment, MemberExpression, ParseFunction } from \"../../types/expression-parser.js\";\n/**\n * Abstract class for handling nodes in an expression language. Subclasses\n * must implement the `accepts` and `handle` methods.\n */\nexport declare abstract class NodeHandler {\n    protected parentHandler?: NodeHandler | undefined;\n    constructor(parentHandler?: NodeHandler | undefined);\n    /**\n     * Determines whether the given node is acceptable.\n     * @param node The node to be checked.\n     * @returns A Promise that resolves to either the node itself or a boolean indicating whether the node is acceptable.\n     */\n    abstract accepts(node: ExpressionNode): Promise<ExpressionNode | boolean>;\n    /**\n     * Handles the given node. The specifics of how the node is handled are\n     * determined by the subclass implementation.\n     * @param node The node to be handled.\n     * @returns A Promise that resolves to the result of handling the node.\n     */\n    abstract handle(node: ExpressionNode): Promise<any>;\n}\n/**\n * Utility class for parsing Abstract Syntax Trees (ASTs). Contains\n * methods for identifying the type of a given node and a method for\n * importing and generating a parser using the Peggy library.\n */\nexport declare class ASTParser {\n    static astParseInstance: ParseFunction;\n    /**\n     * Imports and generates a parser using the Peggy library.\n     * @returns A Promise that resolves to the parser instance.\n     */\n    static importASTParser(): Promise<ParseFunction>;\n    /**\n     * Checks if the given node is a Program node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a Program node.\n     */\n    static isProgram(node: ExpressionNode): node is Program;\n    /**\n     * Checks if the given node is an ExpressionStatement node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an ExpressionStatement node.\n     */\n    static isExpressionStatement(node: ExpressionNode): node is ExpressionStatement;\n    /**\n     * Checks if the given node is a CallExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a CallExpression node.\n     */\n    static isCallExpression(node: ExpressionNode): node is CallExpression;\n    /**\n     * Checks if the given node is a StringLiteral node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a StringLiteral node.\n     */\n    static isStringLiteral(node: ExpressionNode): node is StringLiteral;\n    /**\n     * Checks if the given node is a NumericLiteral node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a NumericLiteral node.\n     */\n    static isNumericLiteral(node: ExpressionNode): node is NumericLiteral;\n    /**\n     * Checks if the given node is a BooleanLiteral node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a BooleanLiteral node.\n     */\n    static isBooleanLiteral(node: ExpressionNode): node is BooleanLiteral;\n    /**\n     * Checks if the given node is an Identifier node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an Identifier node.\n     */\n    static isIdentifier(node: ExpressionNode): node is Identifier;\n    /**\n     * Checks if the given node is an ObjectExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an ObjectExpression node.\n     */\n    static isObjectExpression(node: ExpressionNode): node is ObjectExpression;\n    /**\n     * Checks if the given node is an ArrayExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is an ArrayExpression node.\n     */\n    static isArrayExpression(node: ExpressionNode): node is ArrayExpression;\n    /**\n     * Checks if the given node is a PropertyAssignment node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a PropertyAssignment node.\n     */\n    static isPropertyAssignment(node: ExpressionNode): node is PropertyAssignment;\n    /**\n     * Checks if the given node is a MemberExpression node.\n     * @param node The node to be checked.\n     * @returns A boolean indicating whether the node is a MemberExpression node.\n     */\n    static isMemberExpression(node: ExpressionNode): node is MemberExpression;\n}\n//# sourceMappingURL=base.d.ts.map"],"mappings":";;;;;;AAKA;;AAEgCa,uBAFFA,WAAAA,CAEEA;EAMLb,UAAAA,aAAAA,CAAAA,EAPGa,WAOHb,GAAAA,SAAAA;EAAyBA,WAAAA,CAAAA,aAAAA,CAAAA,EANpBa,WAMoBb,GAAAA,SAAAA;EAARc;;;AAOM;AAOlD;EAC6BF,SAAAA,OAAAA,CAAAA,IAAAA,EAfFZ,cAeEY,CAAAA,EAfeE,OAefF,CAfuBZ,cAevBY,GAAAA,OAAAA,CAAAA;EAKSA;;;;;;EAkBJZ,SAAAA,MAAAA,CAAAA,IAAAA,EA/BRA,cA+BQA,CAAAA,EA/BSc,OA+BTd,CAAAA,GAAAA,CAAAA;;;;;;;AAkByBM,cA1CtCS,SAAAA,CA0CsCT;EAM7BN,OAAAA,gBAAAA,EA/CDY,aA+CCZ;EAAyBO;;;;EAYKE,OAAAA,eAAAA,CAAAA,CAAAA,EAtD9BK,OAsD8BL,CAtDtBG,aAsDsBH,CAAAA;EAMtBT;;;;AAMuC;yBA5DlDA,yBAAyBC;;;;;;qCAMbD,yBAAyBE;;;;;;gCAM9BF,yBAAyBG;;;;;;+BAM1BH,yBAAyBI;;;;;;gCAMxBJ,yBAAyBK;;;;;;gCAMzBL,yBAAyBM;;;;;;4BAM7BN,yBAAyBO;;;;;;kCAMnBP,yBAAyBQ;;;;;;iCAM1BR,yBAAyBS;;;;;;oCAMtBT,yBAAyBU;;;;;;kCAM3BV,yBAAyBW"}