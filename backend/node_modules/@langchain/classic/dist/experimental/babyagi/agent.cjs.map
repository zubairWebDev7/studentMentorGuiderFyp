{"version":3,"file":"agent.cjs","names":["BaseChain","task: Task","result: string","task_description: string","objective: string","runManager?: CallbackManagerForChainRun","thisTaskID: number","query: string","task: string","Document","TaskCreationChain","TaskPrioritizationChain","TaskExecutionChain"],"sources":["../../../src/experimental/babyagi/agent.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport type { VectorStoreInterface } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { BaseChain, ChainInputs } from \"../../chains/base.js\";\nimport { SerializedBaseChain } from \"../../chains/serde.js\";\nimport { Optional } from \"../../types/type-utils.js\";\nimport { TaskCreationChain } from \"./task_creation.js\";\nimport { TaskExecutionChain } from \"./task_execution.js\";\nimport { TaskPrioritizationChain } from \"./task_prioritization.js\";\n\n/**\n * Interface defining the structure of a task. A task has a `taskID` and a\n * `taskName`.\n */\nexport interface Task {\n  taskID: string;\n  taskName: string;\n}\n\n/**\n * Interface defining the structure of the inputs for the `BabyAGI` class.\n * It extends the `ChainInputs` interface, omitting the 'memory' and\n * 'callbackManager' properties, and adds properties specific to\n * `BabyAGI`.\n */\nexport interface BabyAGIInputs extends Omit<\n  ChainInputs,\n  \"memory\" | \"callbackManager\"\n> {\n  creationChain: BaseChain;\n  prioritizationChain: BaseChain;\n  executionChain: BaseChain;\n  vectorstore: VectorStoreInterface;\n  maxIterations?: number;\n}\n\n/**\n * Class responsible for managing tasks, including their creation,\n * prioritization, and execution. It uses three chains for these\n * operations: `creationChain`, `prioritizationChain`, and\n * `executionChain`.\n * @example\n * ```typescript\n * const babyAGI = BabyAGI.fromLLM({\n *   llm: new OpenAI({ temperature: 0 }),\n *   vectorstore: new MemoryVectorStore(new OpenAIEmbeddings()),\n *   maxIterations: 3,\n * });\n *\n * const result = await babyAGI.call({\n *   objective: \"Write a weather report for SF today\",\n * });\n * ```\n */\nexport class BabyAGI extends BaseChain implements BabyAGIInputs {\n  static lc_name() {\n    return \"BabyAGI\";\n  }\n\n  taskList: Task[];\n\n  creationChain: BaseChain;\n\n  prioritizationChain: BaseChain;\n\n  executionChain: BaseChain;\n\n  taskIDCounter: number;\n\n  vectorstore: VectorStoreInterface;\n\n  maxIterations: number;\n\n  constructor({\n    creationChain,\n    prioritizationChain,\n    executionChain,\n    vectorstore,\n    maxIterations = 100,\n    verbose,\n    callbacks,\n  }: BabyAGIInputs) {\n    super(undefined, verbose, callbacks);\n    this.taskList = [];\n    this.creationChain = creationChain;\n    this.prioritizationChain = prioritizationChain;\n    this.executionChain = executionChain;\n    this.taskIDCounter = 1;\n    this.vectorstore = vectorstore;\n    this.maxIterations = maxIterations;\n  }\n\n  _chainType() {\n    return \"BabyAGI\" as const;\n  }\n\n  get inputKeys() {\n    return [\"objective\", \"firstTask\"];\n  }\n\n  get outputKeys() {\n    return [];\n  }\n\n  /**\n   * Adds a task to the task list.\n   * @param task The task to be added.\n   * @returns Promise resolving to void.\n   */\n  async addTask(task: Task) {\n    this.taskList.push(task);\n  }\n\n  /**\n   * Prints the current task list to the console.\n   * @returns void\n   */\n  printTaskList() {\n    console.log(\"\\x1b[95m\\x1b[1m\\n*****TASK LIST*****\\n\\x1b[0m\\x1b[0m\");\n    for (const t of this.taskList) {\n      console.log(`${t.taskID}: ${t.taskName}`);\n    }\n  }\n\n  /**\n   * Prints the next task to the console.\n   * @param task The next task to be printed.\n   * @returns void\n   */\n  printNextTask(task: Task) {\n    console.log(\"\\x1b[92m\\x1b[1m\\n*****NEXT TASK*****\\n\\x1b[0m\\x1b[0m\");\n    console.log(`${task.taskID}: ${task.taskName}`);\n  }\n\n  /**\n   * Prints the result of a task to the console.\n   * @param result The result of the task.\n   * @returns void\n   */\n  printTaskResult(result: string) {\n    console.log(\"\\x1b[93m\\x1b[1m\\n*****TASK RESULT*****\\n\\x1b[0m\\x1b[0m\");\n    console.log(result.trim());\n  }\n\n  /**\n   * Generates the next tasks based on the result of the previous task, the\n   * task description, and the objective.\n   * @param result The result of the previous task.\n   * @param task_description The description of the task.\n   * @param objective The objective of the task.\n   * @param runManager Optional CallbackManagerForChainRun instance.\n   * @returns Promise resolving to an array of tasks without taskID.\n   */\n  async getNextTasks(\n    result: string,\n    task_description: string,\n    objective: string,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<Optional<Task, \"taskID\">[]> {\n    const taskNames = this.taskList.map((t) => t.taskName);\n    const incomplete_tasks = taskNames.join(\", \");\n    const { [this.creationChain.outputKeys[0]]: text } =\n      await this.creationChain.call(\n        {\n          result,\n          task_description,\n          incomplete_tasks,\n          objective,\n        },\n        runManager?.getChild()\n      );\n    const newTasks = (text as string).split(\"\\n\");\n    return newTasks\n      .filter((taskName) => taskName.trim())\n      .map((taskName) => ({ taskName }));\n  }\n\n  /**\n   * Prioritizes the tasks based on the current task ID and the objective.\n   * @param thisTaskID The ID of the current task.\n   * @param objective The objective of the task.\n   * @param runManager Optional CallbackManagerForChainRun instance.\n   * @returns Promise resolving to an array of prioritized tasks.\n   */\n  async prioritizeTasks(\n    thisTaskID: number,\n    objective: string,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    const taskNames = this.taskList.map((t) => t.taskName);\n    const nextTaskID = thisTaskID + 1;\n    const { [this.prioritizationChain.outputKeys[0]]: text } =\n      await this.prioritizationChain.call(\n        {\n          task_names: taskNames.join(\", \"),\n          next_task_id: String(nextTaskID),\n          objective,\n        },\n        runManager?.getChild()\n      );\n    const newTasks = (text as string).trim().split(\"\\n\");\n    const prioritizedTaskList = [];\n    for (const taskString of newTasks) {\n      const taskParts = taskString.trim().split(\".\", 2);\n      if (taskParts.length === 2) {\n        const taskID = taskParts[0].trim();\n        const taskName = taskParts[1].trim();\n        prioritizedTaskList.push({ taskID, taskName });\n      }\n    }\n    return prioritizedTaskList;\n  }\n\n  /**\n   * Retrieves the top tasks that are most similar to the given query.\n   * @param query The query to search for.\n   * @param k The number of top tasks to retrieve.\n   * @returns Promise resolving to an array of top tasks.\n   */\n  async getTopTasks(query: string, k = 5) {\n    const results = await this.vectorstore.similaritySearch(query, k);\n    if (!results) {\n      return [];\n    }\n    return results.map((item) => String(item.metadata.task));\n  }\n\n  /**\n   * Executes a task based on the objective and the task description.\n   * @param objective The objective of the task.\n   * @param task The task to be executed.\n   * @param runManager Optional CallbackManagerForChainRun instance.\n   * @returns Promise resolving to the result of the task execution as a string.\n   */\n  async executeTask(\n    objective: string,\n    task: string,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    const context = await this.getTopTasks(objective);\n    const { [this.executionChain.outputKeys[0]]: text } =\n      await this.executionChain.call(\n        {\n          objective,\n          context: context.join(\"\\n\"),\n          task,\n        },\n        runManager?.getChild()\n      );\n    return text as string;\n  }\n\n  async _call(\n    { objective, firstTask = \"Make a todo list\" }: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    this.taskList = [];\n    this.taskIDCounter = 1;\n    await this.addTask({ taskID: \"1\", taskName: firstTask });\n\n    let numIters = 0;\n    while (numIters < this.maxIterations && this.taskList.length > 0) {\n      this.printTaskList();\n\n      const task = this.taskList.shift()!;\n      this.printNextTask(task);\n\n      const result = await this.executeTask(\n        objective,\n        task.taskName,\n        runManager\n      );\n      const thisTaskID = parseInt(task.taskID, 10);\n      this.printTaskResult(result);\n\n      await this.vectorstore.addDocuments([\n        new Document({\n          pageContent: result,\n          metadata: { task: task.taskName },\n        }),\n      ]);\n\n      const newTasks = await this.getNextTasks(\n        result,\n        task.taskName,\n        objective,\n        runManager\n      );\n      for (const newTask of newTasks) {\n        this.taskIDCounter += 1;\n        newTask.taskID = this.taskIDCounter.toFixed();\n        await this.addTask(newTask as Task);\n      }\n      this.taskList = await this.prioritizeTasks(\n        thisTaskID,\n        objective,\n        runManager\n      );\n\n      numIters += 1;\n    }\n    return {};\n  }\n\n  serialize(): SerializedBaseChain {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Static method to create a new BabyAGI instance from a\n   * BaseLanguageModel.\n   * @param llm BaseLanguageModel instance used to generate a new BabyAGI instance.\n   * @param vectorstore VectorStore instance used to store and retrieve vectors.\n   * @param executionChain Optional BaseChain instance used to execute tasks.\n   * @param verbose Optional boolean indicating whether to log verbose output.\n   * @param callbacks Optional callbacks to be used during the execution of tasks.\n   * @param rest Optional additional parameters.\n   * @returns A new instance of BabyAGI.\n   */\n  static fromLLM({\n    llm,\n    vectorstore,\n    executionChain,\n    verbose,\n    callbacks,\n    ...rest\n  }: Optional<\n    BabyAGIInputs,\n    \"executionChain\" | \"creationChain\" | \"prioritizationChain\"\n  > & { llm: BaseLanguageModelInterface }) {\n    const creationChain = TaskCreationChain.fromLLM({\n      llm,\n      verbose,\n      callbacks,\n    });\n    const prioritizationChain = TaskPrioritizationChain.fromLLM({\n      llm,\n      verbose,\n      callbacks,\n    });\n    return new BabyAGI({\n      creationChain,\n      prioritizationChain,\n      executionChain:\n        executionChain ||\n        TaskExecutionChain.fromLLM({ llm, verbose, callbacks }),\n      vectorstore,\n      verbose,\n      callbacks,\n      ...rest,\n    });\n  }\n}\n"],"mappings":"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"}