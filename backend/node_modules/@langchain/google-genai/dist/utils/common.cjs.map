{"version":3,"file":"common.cjs","names":["fn: () => string","message: BaseMessage","ChatMessage","author: string","content: MessageContentComplex","message: ToolMessage | ToolMessageChunk","previousMessages: BaseMessage[]","isMultimodalModel: boolean","standardContentBlockConverter: StandardContentBlockConverter<{\n    text: TextPart;\n    image: FileDataPart | InlineDataPart;\n    audio: FileDataPart | InlineDataPart;\n    file: FileDataPart | InlineDataPart | TextPart;\n  }>","model?: string","functionCalls: FunctionCallPart[]","messageParts: Part[]","messages: BaseMessage[]","convertSystemMessageToHumanContent: boolean","model: string","prevContent","content: Content","response: EnhancedGenerateContentResponse","extra?: {\n    usageMetadata: UsageMetadata | undefined;\n  }","content: MessageContent | undefined","generation: ChatGeneration","AIMessage","extra: {\n    usageMetadata?: UsageMetadata | undefined;\n    index: number;\n  }","toolCallChunks: ToolCallChunk[]","ChatGenerationChunk","AIMessageChunk","tools: GoogleGenerativeAIToolType[]","schemaToGenerativeAIParameters","assertNoEmptyStringEnums","jsonSchemaToGeminiParameters","usageMetadata: GenerateContentResponse[\"usageMetadata\"]","output: UsageMetadata"],"sources":["../../src/utils/common.ts"],"sourcesContent":["import {\n  EnhancedGenerateContentResponse,\n  Content,\n  Part,\n  type FunctionDeclarationsTool as GoogleGenerativeAIFunctionDeclarationsTool,\n  type FunctionDeclaration as GenerativeAIFunctionDeclaration,\n  POSSIBLE_ROLES,\n  FunctionCallPart,\n  TextPart,\n  FileDataPart,\n  InlineDataPart,\n  type GenerateContentResponse,\n} from \"@google/generative-ai\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  ChatMessage,\n  ToolMessage,\n  ToolMessageChunk,\n  MessageContent,\n  MessageContentComplex,\n  UsageMetadata,\n  isAIMessage,\n  isBaseMessage,\n  isToolMessage,\n  StandardContentBlockConverter,\n  parseBase64DataUrl,\n  convertToProviderContentBlock,\n  isDataContentBlock,\n  InputTokenDetails,\n} from \"@langchain/core/messages\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { isLangChainTool } from \"@langchain/core/utils/function_calling\";\nimport { isOpenAITool } from \"@langchain/core/language_models/base\";\nimport { ToolCallChunk } from \"@langchain/core/messages/tool\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  jsonSchemaToGeminiParameters,\n  schemaToGenerativeAIParameters,\n} from \"./zod_to_genai_parameters.js\";\nimport {\n  GoogleGenerativeAIPart,\n  GoogleGenerativeAIToolType,\n} from \"../types.js\";\nimport { assertNoEmptyStringEnums } from \"./validate_schema.js\";\n\nexport const _FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY =\n  \"__gemini_function_call_thought_signatures__\";\nconst DUMMY_SIGNATURE =\n  \"ErYCCrMCAdHtim9kOoOkrPiCNVsmlpMIKd7ZMxgiFbVQOkgp7nlLcDMzVsZwIzvuT7nQROivoXA72ccC2lSDvR0Gh7dkWaGuj7ctv6t7ZceHnecx0QYa+ix8tYpRfjhyWozQ49lWiws6+YGjCt10KRTyWsZ2h6O7iHTYJwKIRwGUHRKy/qK/6kFxJm5ML00gLq4D8s5Z6DBpp2ZlR+uF4G8jJgeWQgyHWVdx2wGYElaceVAc66tZdPQRdOHpWtgYSI1YdaXgVI8KHY3/EfNc2YqqMIulvkDBAnuMhkAjV9xmBa54Tq+ih3Im4+r3DzqhGqYdsSkhS0kZMwte4Hjs65dZzCw9lANxIqYi1DJ639WNPYihp/DCJCos7o+/EeSPJaio5sgWDyUnMGkY1atsJZ+m7pj7DD5tvQ==\";\n\nconst iife = (fn: () => string) => fn();\n\nexport function getMessageAuthor(message: BaseMessage) {\n  if (ChatMessage.isInstance(message)) {\n    return message.role;\n  }\n  return message.type;\n}\n\n/**\n * Maps a message type to a Google Generative AI chat author.\n * @param message The message to map.\n * @param model The model to use for mapping.\n * @returns The message type mapped to a Google Generative AI chat author.\n */\nexport function convertAuthorToRole(\n  author: string\n): (typeof POSSIBLE_ROLES)[number] {\n  switch (author) {\n    /**\n     *  Note: Gemini currently is not supporting system messages\n     *  we will convert them to human messages and merge with following\n     * */\n    case \"supervisor\":\n    case \"ai\":\n    case \"model\":\n      return \"model\";\n    case \"system\":\n      return \"system\";\n    case \"human\":\n      return \"user\";\n    case \"tool\":\n    case \"function\":\n      return \"function\";\n    default:\n      throw new Error(`Unknown / unsupported author: ${author}`);\n  }\n}\n\nfunction messageContentMedia(content: MessageContentComplex): Part {\n  if (\"mimeType\" in content && \"data\" in content) {\n    return {\n      inlineData: {\n        mimeType: content.mimeType,\n        data: content.data,\n      },\n    };\n  }\n  if (\"mimeType\" in content && \"fileUri\" in content) {\n    return {\n      fileData: {\n        mimeType: content.mimeType,\n        fileUri: content.fileUri,\n      },\n    };\n  }\n\n  throw new Error(\"Invalid media content\");\n}\n\nfunction inferToolNameFromPreviousMessages(\n  message: ToolMessage | ToolMessageChunk,\n  previousMessages: BaseMessage[]\n): string | undefined {\n  return previousMessages\n    .map((msg) => {\n      if (isAIMessage(msg)) {\n        return msg.tool_calls ?? [];\n      }\n      return [];\n    })\n    .flat()\n    .find((toolCall) => {\n      return toolCall.id === message.tool_call_id;\n    })?.name;\n}\n\nfunction _getStandardContentBlockConverter(isMultimodalModel: boolean) {\n  const standardContentBlockConverter: StandardContentBlockConverter<{\n    text: TextPart;\n    image: FileDataPart | InlineDataPart;\n    audio: FileDataPart | InlineDataPart;\n    file: FileDataPart | InlineDataPart | TextPart;\n  }> = {\n    providerName: \"Google Gemini\",\n\n    fromStandardTextBlock(block) {\n      return {\n        text: block.text,\n      };\n    },\n\n    fromStandardImageBlock(block): FileDataPart | InlineDataPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support images\");\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardAudioBlock(block): FileDataPart | InlineDataPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support audio\");\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardFileBlock(block): FileDataPart | InlineDataPart | TextPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support files\");\n      }\n      if (block.source_type === \"text\") {\n        return {\n          text: block.text,\n        };\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n  };\n  return standardContentBlockConverter;\n}\n\nfunction _convertLangChainContentToPart(\n  content: MessageContentComplex,\n  isMultimodalModel: boolean\n): Part | undefined {\n  if (isDataContentBlock(content)) {\n    return convertToProviderContentBlock(\n      content,\n      _getStandardContentBlockConverter(isMultimodalModel)\n    );\n  }\n\n  if (content.type === \"text\") {\n    return { text: content.text };\n  } else if (content.type === \"executableCode\") {\n    return { executableCode: content.executableCode };\n  } else if (content.type === \"codeExecutionResult\") {\n    return { codeExecutionResult: content.codeExecutionResult };\n  } else if (content.type === \"image_url\") {\n    if (!isMultimodalModel) {\n      throw new Error(`This model does not support images`);\n    }\n    let source;\n    if (typeof content.image_url === \"string\") {\n      source = content.image_url;\n    } else if (\n      typeof content.image_url === \"object\" &&\n      \"url\" in content.image_url\n    ) {\n      source = content.image_url.url;\n    } else {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n    const [dm, data] = source.split(\",\");\n    if (!dm.startsWith(\"data:\")) {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n\n    const [mimeType, encoding] = dm.replace(/^data:/, \"\").split(\";\");\n    if (encoding !== \"base64\") {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n\n    return {\n      inlineData: {\n        data,\n        mimeType,\n      },\n    };\n  } else if (content.type === \"media\") {\n    return messageContentMedia(content);\n  } else if (content.type === \"tool_use\") {\n    return {\n      functionCall: {\n        name: content.name,\n        args: content.input,\n      },\n    };\n  } else if (content.type === \"tool_call\") {\n    return {\n      functionCall: {\n        name: content.name,\n        args: content.args,\n      },\n    };\n  } else if (\n    content.type?.includes(\"/\") &&\n    // Ensure it's a single slash.\n    content.type.split(\"/\").length === 2 &&\n    \"data\" in content &&\n    typeof content.data === \"string\"\n  ) {\n    return {\n      inlineData: {\n        mimeType: content.type,\n        data: content.data,\n      },\n    };\n  } else if (\"functionCall\" in content) {\n    // No action needed here â€” function calls will be added later from message.tool_calls\n    return undefined;\n  } else {\n    if (\"type\" in content) {\n      throw new Error(`Unknown content type ${content.type}`);\n    } else {\n      throw new Error(`Unknown content ${JSON.stringify(content)}`);\n    }\n  }\n}\n\nexport function convertMessageContentToParts(\n  message: BaseMessage,\n  isMultimodalModel: boolean,\n  previousMessages: BaseMessage[],\n  model?: string\n): Part[] {\n  if (isToolMessage(message)) {\n    const messageName =\n      message.name ??\n      inferToolNameFromPreviousMessages(message, previousMessages);\n    if (messageName === undefined) {\n      throw new Error(\n        `Google requires a tool name for each tool call response, and we could not infer a called tool name for ToolMessage \"${message.id}\" from your passed messages. Please populate a \"name\" field on that ToolMessage explicitly.`\n      );\n    }\n\n    const result = Array.isArray(message.content)\n      ? (message.content\n          .map((c) => _convertLangChainContentToPart(c, isMultimodalModel))\n          .filter((p) => p !== undefined) as Part[])\n      : message.content;\n\n    if (message.status === \"error\") {\n      return [\n        {\n          functionResponse: {\n            name: messageName,\n            // The API expects an object with an `error` field if the function call fails.\n            // `error` must be a valid object (not a string or array), so we wrap `message.content` here\n            response: { error: { details: result } },\n          },\n        },\n      ];\n    }\n\n    return [\n      {\n        functionResponse: {\n          name: messageName,\n          // again, can't have a string or array value for `response`, so we wrap it as an object here\n          response: { result },\n        },\n      },\n    ];\n  }\n\n  let functionCalls: FunctionCallPart[] = [];\n  const messageParts: Part[] = [];\n\n  if (typeof message.content === \"string\" && message.content) {\n    messageParts.push({ text: message.content });\n  }\n\n  if (Array.isArray(message.content)) {\n    messageParts.push(\n      ...(message.content\n        .map((c) => _convertLangChainContentToPart(c, isMultimodalModel))\n        .filter((p) => p !== undefined) as Part[])\n    );\n  }\n\n  const functionThoughtSignatures = message.additional_kwargs?.[\n    _FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY\n  ] as Record<string, string>;\n\n  if (isAIMessage(message) && message.tool_calls?.length) {\n    functionCalls = message.tool_calls.map((tc) => {\n      const thoughtSignature = iife(() => {\n        if (tc.id) {\n          const signature = functionThoughtSignatures?.[tc.id];\n          if (signature) {\n            return signature;\n          }\n        }\n        if (model?.includes(\"gemini-3\")) {\n          return DUMMY_SIGNATURE;\n        }\n        return \"\";\n      });\n      return {\n        functionCall: {\n          name: tc.name,\n          args: tc.args,\n        },\n        ...(thoughtSignature ? { thoughtSignature } : {}),\n      };\n    });\n  }\n\n  return [...messageParts, ...functionCalls];\n}\n\nexport function convertBaseMessagesToContent(\n  messages: BaseMessage[],\n  isMultimodalModel: boolean,\n  convertSystemMessageToHumanContent: boolean = false,\n  model: string\n) {\n  return messages.reduce<{\n    content: Content[];\n    mergeWithPreviousContent: boolean;\n  }>(\n    (acc, message, index) => {\n      if (!isBaseMessage(message)) {\n        throw new Error(\"Unsupported message input\");\n      }\n      const author = getMessageAuthor(message);\n      if (author === \"system\" && index !== 0) {\n        throw new Error(\"System message should be the first one\");\n      }\n      const role = convertAuthorToRole(author);\n\n      const prevContent = acc.content[acc.content.length];\n      if (\n        !acc.mergeWithPreviousContent &&\n        prevContent &&\n        prevContent.role === role\n      ) {\n        throw new Error(\n          \"Google Generative AI requires alternate messages between authors\"\n        );\n      }\n\n      const parts = convertMessageContentToParts(\n        message,\n        isMultimodalModel,\n        messages.slice(0, index),\n        model\n      );\n\n      if (acc.mergeWithPreviousContent) {\n        const prevContent = acc.content[acc.content.length - 1];\n        if (!prevContent) {\n          throw new Error(\n            \"There was a problem parsing your system message. Please try a prompt without one.\"\n          );\n        }\n        prevContent.parts.push(...parts);\n\n        return {\n          mergeWithPreviousContent: false,\n          content: acc.content,\n        };\n      }\n      let actualRole = role;\n      if (\n        actualRole === \"function\" ||\n        (actualRole === \"system\" && !convertSystemMessageToHumanContent)\n      ) {\n        // GenerativeAI API will throw an error if the role is not \"user\" or \"model.\"\n        actualRole = \"user\";\n      }\n      const content: Content = {\n        role: actualRole,\n        parts,\n      };\n      return {\n        mergeWithPreviousContent:\n          author === \"system\" && !convertSystemMessageToHumanContent,\n        content: [...acc.content, content],\n      };\n    },\n    { content: [], mergeWithPreviousContent: false }\n  ).content;\n}\n\nexport function mapGenerateContentResultToChatResult(\n  response: EnhancedGenerateContentResponse,\n  extra?: {\n    usageMetadata: UsageMetadata | undefined;\n  }\n): ChatResult {\n  // if rejected or error, return empty generations with reason in filters\n  if (\n    !response.candidates ||\n    response.candidates.length === 0 ||\n    !response.candidates[0]\n  ) {\n    return {\n      generations: [],\n      llmOutput: {\n        filters: response.promptFeedback,\n      },\n    };\n  }\n  const [candidate] = response.candidates;\n  const { content: candidateContent, ...generationInfo } = candidate;\n  const functionCalls = candidateContent.parts?.reduce(\n    (acc, p) => {\n      if (\"functionCall\" in p && p.functionCall) {\n        acc.push({\n          ...p,\n          id:\n            \"id\" in p.functionCall && typeof p.functionCall.id === \"string\"\n              ? p.functionCall.id\n              : uuidv4(),\n        });\n      }\n      return acc;\n    },\n    [] as (FunctionCallPart & { id: string })[]\n  );\n  let content: MessageContent | undefined;\n\n  const parts = candidateContent?.parts as GoogleGenerativeAIPart[] | undefined;\n\n  if (\n    Array.isArray(parts) &&\n    parts.length === 1 &&\n    \"text\" in parts[0] &&\n    parts[0].text &&\n    !parts[0].thought\n  ) {\n    content = parts[0].text;\n  } else if (Array.isArray(parts) && parts.length > 0) {\n    content = parts.map((p) => {\n      if (p.thought && \"text\" in p && p.text) {\n        return {\n          type: \"thinking\",\n          thinking: p.text,\n          ...(p.thoughtSignature ? { signature: p.thoughtSignature } : {}),\n        };\n      } else if (\"text\" in p) {\n        return {\n          type: \"text\",\n          text: p.text,\n        };\n      } else if (\"inlineData\" in p) {\n        return {\n          type: \"inlineData\",\n          inlineData: p.inlineData,\n        };\n      } else if (\"functionCall\" in p) {\n        return {\n          type: \"functionCall\",\n          functionCall: p.functionCall,\n        };\n      } else if (\"functionResponse\" in p) {\n        return {\n          type: \"functionResponse\",\n          functionResponse: p.functionResponse,\n        };\n      } else if (\"fileData\" in p) {\n        return {\n          type: \"fileData\",\n          fileData: p.fileData,\n        };\n      } else if (\"executableCode\" in p) {\n        return {\n          type: \"executableCode\",\n          executableCode: p.executableCode,\n        };\n      } else if (\"codeExecutionResult\" in p) {\n        return {\n          type: \"codeExecutionResult\",\n          codeExecutionResult: p.codeExecutionResult,\n        };\n      }\n      return p;\n    });\n  } else {\n    // no content returned - likely due to abnormal stop reason, e.g. malformed function call\n    content = [];\n  }\n\n  const functionThoughtSignatures = functionCalls?.reduce(\n    (acc, fc) => {\n      if (\"thoughtSignature\" in fc && typeof fc.thoughtSignature === \"string\") {\n        acc[fc.id] = fc.thoughtSignature;\n      }\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  let text = \"\";\n  if (typeof content === \"string\") {\n    text = content;\n  } else if (Array.isArray(content) && content.length > 0) {\n    const block = content.find((b) => \"text\" in b) as\n      | { text: string }\n      | undefined;\n    text = block?.text ?? text;\n  }\n\n  const generation: ChatGeneration = {\n    text,\n    message: new AIMessage({\n      content: content ?? \"\",\n      tool_calls: functionCalls?.map((fc) => ({\n        type: \"tool_call\",\n        id: fc.id,\n        name: fc.functionCall.name,\n        args: fc.functionCall.args,\n      })),\n      additional_kwargs: {\n        ...generationInfo,\n        [_FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY]: functionThoughtSignatures,\n      },\n      usage_metadata: extra?.usageMetadata,\n    }),\n    generationInfo,\n  };\n\n  return {\n    generations: [generation],\n    llmOutput: {\n      tokenUsage: {\n        promptTokens: extra?.usageMetadata?.input_tokens,\n        completionTokens: extra?.usageMetadata?.output_tokens,\n        totalTokens: extra?.usageMetadata?.total_tokens,\n      },\n    },\n  };\n}\n\nexport function convertResponseContentToChatGenerationChunk(\n  response: EnhancedGenerateContentResponse,\n  extra: {\n    usageMetadata?: UsageMetadata | undefined;\n    index: number;\n  }\n): ChatGenerationChunk | null {\n  if (!response.candidates || response.candidates.length === 0) {\n    return null;\n  }\n  const [candidate] = response.candidates;\n  const { content: candidateContent, ...generationInfo } = candidate;\n  const functionCalls = candidateContent.parts?.reduce(\n    (acc, p) => {\n      if (\"functionCall\" in p && p.functionCall) {\n        acc.push({\n          ...p,\n          id:\n            \"id\" in p.functionCall && typeof p.functionCall.id === \"string\"\n              ? p.functionCall.id\n              : uuidv4(),\n        });\n      }\n      return acc;\n    },\n    [] as (FunctionCallPart & { id: string })[]\n  );\n  let content: MessageContent | undefined;\n  const streamParts = candidateContent?.parts as\n    | GoogleGenerativeAIPart[]\n    | undefined;\n\n  // Checks if all parts are plain text (no thought flags). If so, join as string.\n  if (\n    Array.isArray(streamParts) &&\n    streamParts.every((p) => \"text\" in p && !p.thought)\n  ) {\n    content = streamParts.map((p) => p.text).join(\"\");\n  } else if (Array.isArray(streamParts)) {\n    content = streamParts.map((p) => {\n      if (p.thought && \"text\" in p && p.text) {\n        return {\n          type: \"thinking\",\n          thinking: p.text,\n          ...(p.thoughtSignature ? { signature: p.thoughtSignature } : {}),\n        };\n      } else if (\"text\" in p) {\n        return {\n          type: \"text\",\n          text: p.text,\n        };\n      } else if (\"inlineData\" in p) {\n        return {\n          type: \"inlineData\",\n          inlineData: p.inlineData,\n        };\n      } else if (\"functionCall\" in p) {\n        return {\n          type: \"functionCall\",\n          functionCall: p.functionCall,\n        };\n      } else if (\"functionResponse\" in p) {\n        return {\n          type: \"functionResponse\",\n          functionResponse: p.functionResponse,\n        };\n      } else if (\"fileData\" in p) {\n        return {\n          type: \"fileData\",\n          fileData: p.fileData,\n        };\n      } else if (\"executableCode\" in p) {\n        return {\n          type: \"executableCode\",\n          executableCode: p.executableCode,\n        };\n      } else if (\"codeExecutionResult\" in p) {\n        return {\n          type: \"codeExecutionResult\",\n          codeExecutionResult: p.codeExecutionResult,\n        };\n      }\n      return p;\n    });\n  } else {\n    // no content returned - likely due to abnormal stop reason, e.g. malformed function call\n    content = [];\n  }\n\n  let text = \"\";\n  if (content && typeof content === \"string\") {\n    text = content;\n  } else if (Array.isArray(content)) {\n    const block = content.find((b) => \"text\" in b) as\n      | { text: string }\n      | undefined;\n    text = block?.text ?? \"\";\n  }\n\n  const toolCallChunks: ToolCallChunk[] = [];\n  if (functionCalls) {\n    toolCallChunks.push(\n      ...functionCalls.map((fc) => ({\n        type: \"tool_call_chunk\" as const,\n        id: fc.id,\n        name: fc.functionCall.name,\n        args: JSON.stringify(fc.functionCall.args),\n      }))\n    );\n  }\n\n  const functionThoughtSignatures = functionCalls?.reduce(\n    (acc, fc) => {\n      if (\"thoughtSignature\" in fc && typeof fc.thoughtSignature === \"string\") {\n        acc[fc.id] = fc.thoughtSignature;\n      }\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  return new ChatGenerationChunk({\n    text,\n    message: new AIMessageChunk({\n      content: content || \"\",\n      name: !candidateContent ? undefined : candidateContent.role,\n      tool_call_chunks: toolCallChunks,\n      // Each chunk can have unique \"generationInfo\", and merging strategy is unclear,\n      // so leave blank for now.\n      additional_kwargs: {\n        [_FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY]: functionThoughtSignatures,\n      },\n      response_metadata: {\n        model_provider: \"google-genai\",\n      },\n      usage_metadata: extra.usageMetadata,\n    }),\n    generationInfo,\n  });\n}\n\nexport function convertToGenerativeAITools(\n  tools: GoogleGenerativeAIToolType[]\n): GoogleGenerativeAIFunctionDeclarationsTool[] {\n  if (\n    tools.every(\n      (tool) =>\n        \"functionDeclarations\" in tool &&\n        Array.isArray(tool.functionDeclarations)\n    )\n  ) {\n    return tools as GoogleGenerativeAIFunctionDeclarationsTool[];\n  }\n  return [\n    {\n      functionDeclarations: tools.map(\n        (tool): GenerativeAIFunctionDeclaration => {\n          if (isLangChainTool(tool)) {\n            const jsonSchema = schemaToGenerativeAIParameters(tool.schema);\n            if (\n              jsonSchema.type === \"object\" &&\n              \"properties\" in jsonSchema &&\n              Object.keys(jsonSchema.properties).length === 0\n            ) {\n              return {\n                name: tool.name,\n                description: tool.description,\n              };\n            }\n            assertNoEmptyStringEnums(jsonSchema, tool.name);\n            return {\n              name: tool.name,\n              description: tool.description,\n              parameters: jsonSchema,\n            };\n          }\n          if (isOpenAITool(tool)) {\n            const params = jsonSchemaToGeminiParameters(\n              tool.function.parameters\n            );\n            assertNoEmptyStringEnums(params, tool.function.name);\n            return {\n              name: tool.function.name,\n              description:\n                tool.function.description ?? `A function available to call.`,\n              parameters: params,\n            };\n          }\n          return tool as unknown as GenerativeAIFunctionDeclaration;\n        }\n      ),\n    },\n  ];\n}\n\nexport function convertUsageMetadata(\n  usageMetadata: GenerateContentResponse[\"usageMetadata\"],\n  model: string\n): UsageMetadata {\n  const output: UsageMetadata = {\n    input_tokens: usageMetadata?.promptTokenCount ?? 0,\n    output_tokens: usageMetadata?.candidatesTokenCount ?? 0,\n    total_tokens: usageMetadata?.totalTokenCount ?? 0,\n  };\n  if (usageMetadata?.cachedContentTokenCount) {\n    output.input_token_details ??= {};\n    output.input_token_details.cache_read =\n      usageMetadata.cachedContentTokenCount;\n  }\n  // gemini-3-pro-preview has bracket based tracking of tokens per request\n  // FIXME(hntrl): move this usageMetadata calculation elsewhere\n  if (model === \"gemini-3-pro-preview\") {\n    const over200k = Math.max(0, usageMetadata?.promptTokenCount ?? 0 - 200000);\n    const cachedOver200k = Math.max(\n      0,\n      usageMetadata?.cachedContentTokenCount ?? 0 - 200000\n    );\n    if (over200k) {\n      output.input_token_details = {\n        ...output.input_token_details,\n        over_200k: over200k,\n      } as InputTokenDetails;\n    }\n    if (cachedOver200k) {\n      output.input_token_details = {\n        ...output.input_token_details,\n        cache_read_over_200k: cachedOver200k,\n      } as InputTokenDetails;\n    }\n  }\n  return output;\n}\n"],"mappings":"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"}