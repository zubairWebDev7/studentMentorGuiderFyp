{"version":3,"file":"combine_docs_chain.cjs","names":["BaseChain","fields: StuffDocumentsChainInput","values: ChainValues","runManager?: CallbackManagerForChainRun","data: SerializedStuffDocumentsChain","LLMChain","fields: MapReduceDocumentsChainInput","intermediateSteps: string[]","i","data: SerializedMapReduceDocumentsChain","PromptTemplate","fields: RefineDocumentsChainInput","doc: Document","rest: Record<string, unknown>","baseInfo: Record<string, unknown>","documentInfo: Record<string, unknown>","baseInputs: Record<string, unknown>","res: string","data: SerializedRefineDocumentsChain"],"sources":["../../src/chains/combine_docs_chain.ts"],"sourcesContent":["import { Document } from \"@langchain/core/documents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { BasePromptTemplate, PromptTemplate } from \"@langchain/core/prompts\";\nimport type {\n  SerializedStuffDocumentsChain,\n  SerializedMapReduceDocumentsChain,\n  SerializedRefineDocumentsChain,\n} from \"./serde.js\";\nimport { BaseChain, ChainInputs } from \"./base.js\";\nimport { LLMChain } from \"./llm_chain.js\";\n\n/**\n * Interface for the input properties of the StuffDocumentsChain class.\n */\nexport interface StuffDocumentsChainInput extends ChainInputs {\n  /** LLM Wrapper to use after formatting documents */\n  llmChain: LLMChain;\n  inputKey?: string;\n  /** Variable name in the LLM chain to put the documents in */\n  documentVariableName?: string;\n}\n\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class StuffDocumentsChain\n  extends BaseChain\n  implements StuffDocumentsChainInput\n{\n  static lc_name() {\n    return \"StuffDocumentsChain\";\n  }\n\n  llmChain: LLMChain;\n\n  inputKey = \"input_documents\";\n\n  documentVariableName = \"context\";\n\n  get inputKeys() {\n    return [this.inputKey, ...this.llmChain.inputKeys].filter(\n      (key) => key !== this.documentVariableName\n    );\n  }\n\n  get outputKeys() {\n    return this.llmChain.outputKeys;\n  }\n\n  constructor(fields: StuffDocumentsChainInput) {\n    super(fields);\n    this.llmChain = fields.llmChain;\n    this.documentVariableName =\n      fields.documentVariableName ?? this.documentVariableName;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n  }\n\n  /** @ignore */\n  _prepInputs(values: ChainValues): ChainValues {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const { [this.inputKey]: docs, ...rest } = values;\n    const texts = (docs as Document[]).map(({ pageContent }) => pageContent);\n    const text = texts.join(\"\\n\\n\");\n    return {\n      ...rest,\n      [this.documentVariableName]: text,\n    };\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    const result = await this.llmChain.call(\n      this._prepInputs(values),\n      runManager?.getChild(\"combine_documents\")\n    );\n    return result;\n  }\n\n  _chainType() {\n    return \"stuff_documents_chain\" as const;\n  }\n\n  static async deserialize(data: SerializedStuffDocumentsChain) {\n    if (!data.llm_chain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n\n    return new StuffDocumentsChain({\n      llmChain: await LLMChain.deserialize(data.llm_chain),\n    });\n  }\n\n  serialize(): SerializedStuffDocumentsChain {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n    };\n  }\n}\n\n/**\n * Interface for the input properties of the MapReduceDocumentsChain\n * class.\n */\nexport interface MapReduceDocumentsChainInput extends StuffDocumentsChainInput {\n  /** The maximum number of tokens before requiring to do the reduction */\n  maxTokens?: number;\n  /** The maximum number of iterations to run through the map */\n  maxIterations?: number;\n  /** Ensures that the map step is taken regardless of max tokens */\n  ensureMapStep?: boolean;\n  /** Chain to use to combine results of applying llm_chain to documents. */\n  combineDocumentChain: StuffDocumentsChain;\n  /** Return the results of the map steps in the output. */\n  returnIntermediateSteps?: boolean;\n}\n\n/**\n * Combine documents by mapping a chain over them, then combining results.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class MapReduceDocumentsChain\n  extends BaseChain\n  implements MapReduceDocumentsChainInput\n{\n  static lc_name() {\n    return \"MapReduceDocumentsChain\";\n  }\n\n  llmChain: LLMChain;\n\n  inputKey = \"input_documents\";\n\n  documentVariableName = \"context\";\n\n  returnIntermediateSteps = false;\n\n  get inputKeys() {\n    return [this.inputKey, ...this.combineDocumentChain.inputKeys];\n  }\n\n  get outputKeys() {\n    return this.combineDocumentChain.outputKeys;\n  }\n\n  maxTokens = 3000;\n\n  maxIterations = 10;\n\n  ensureMapStep = false;\n\n  combineDocumentChain: StuffDocumentsChain;\n\n  constructor(fields: MapReduceDocumentsChainInput) {\n    super(fields);\n    this.llmChain = fields.llmChain;\n    this.combineDocumentChain = fields.combineDocumentChain;\n    this.documentVariableName =\n      fields.documentVariableName ?? this.documentVariableName;\n    this.ensureMapStep = fields.ensureMapStep ?? this.ensureMapStep;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.maxTokens = fields.maxTokens ?? this.maxTokens;\n    this.maxIterations = fields.maxIterations ?? this.maxIterations;\n    this.returnIntermediateSteps = fields.returnIntermediateSteps ?? false;\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const { [this.inputKey]: docs, ...rest } = values;\n\n    let currentDocs = docs as Document[];\n    let intermediateSteps: string[] = [];\n\n    // For each iteration, we'll use the `llmChain` to get a new result\n    for (let i = 0; i < this.maxIterations; i += 1) {\n      const inputs = currentDocs.map((d) => ({\n        [this.documentVariableName]: d.pageContent,\n        ...rest,\n      }));\n\n      const canSkipMapStep = i !== 0 || !this.ensureMapStep;\n      if (canSkipMapStep) {\n        // Calculate the total tokens required in the input\n        const formatted =\n          await this.combineDocumentChain.llmChain.prompt.format(\n            this.combineDocumentChain._prepInputs({\n              [this.combineDocumentChain.inputKey]: currentDocs,\n              ...rest,\n            })\n          );\n        const length =\n          await this.combineDocumentChain.llmChain._getNumTokens(formatted);\n\n        const withinTokenLimit = length < this.maxTokens;\n        // If we can skip the map step, and we're within the token limit, we don't\n        // need to run the map step, so just break out of the loop.\n        if (withinTokenLimit) {\n          break;\n        }\n      }\n\n      const results = await this.llmChain.apply(\n        inputs,\n        // If we have a runManager, then we need to create a child for each input\n        // so that we can track the progress of each input.\n        runManager\n          ? Array.from({ length: inputs.length }, (_, i) =>\n              runManager.getChild(`map_${i + 1}`)\n            )\n          : undefined\n      );\n      const { outputKey } = this.llmChain;\n\n      // If the flag is set, then concat that to the intermediate steps\n      if (this.returnIntermediateSteps) {\n        intermediateSteps = intermediateSteps.concat(\n          results.map((r) => r[outputKey])\n        );\n      }\n\n      currentDocs = results.map((r) => ({\n        pageContent: r[outputKey],\n        metadata: {},\n      }));\n    }\n\n    // Now, with the final result of all the inputs from the `llmChain`, we can\n    // run the `combineDocumentChain` over them.\n    const newInputs = {\n      [this.combineDocumentChain.inputKey]: currentDocs,\n      ...rest,\n    };\n    const result = await this.combineDocumentChain.call(\n      newInputs,\n      runManager?.getChild(\"combine_documents\")\n    );\n\n    // Return the intermediate steps results if the flag is set\n    if (this.returnIntermediateSteps) {\n      return { ...result, intermediateSteps };\n    }\n    return result;\n  }\n\n  _chainType() {\n    return \"map_reduce_documents_chain\" as const;\n  }\n\n  static async deserialize(data: SerializedMapReduceDocumentsChain) {\n    if (!data.llm_chain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n\n    if (!data.combine_document_chain) {\n      throw new Error(\"Missing combine_document_chain\");\n    }\n\n    return new MapReduceDocumentsChain({\n      llmChain: await LLMChain.deserialize(data.llm_chain),\n      combineDocumentChain: await StuffDocumentsChain.deserialize(\n        data.combine_document_chain\n      ),\n    });\n  }\n\n  serialize(): SerializedMapReduceDocumentsChain {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n      combine_document_chain: this.combineDocumentChain.serialize(),\n    };\n  }\n}\n\n/**\n * Interface for the input properties of the RefineDocumentsChain class.\n */\nexport interface RefineDocumentsChainInput extends StuffDocumentsChainInput {\n  refineLLMChain: LLMChain;\n  documentPrompt?: BasePromptTemplate;\n  initialResponseName?: string;\n  documentVariableName?: string;\n  outputKey?: string;\n}\n\n/**\n * Combine documents by doing a first pass and then refining on more documents.\n * @augments BaseChain\n * @augments RefineDocumentsChainInput\n */\nexport class RefineDocumentsChain\n  extends BaseChain\n  implements RefineDocumentsChainInput\n{\n  static lc_name() {\n    return \"RefineDocumentsChain\";\n  }\n\n  llmChain: LLMChain;\n\n  inputKey = \"input_documents\";\n\n  outputKey = \"output_text\";\n\n  documentVariableName = \"context\";\n\n  initialResponseName = \"existing_answer\";\n\n  refineLLMChain: LLMChain;\n\n  get defaultDocumentPrompt(): BasePromptTemplate {\n    return new PromptTemplate({\n      inputVariables: [\"page_content\"],\n      template: \"{page_content}\",\n    });\n  }\n\n  documentPrompt = this.defaultDocumentPrompt;\n\n  get inputKeys() {\n    return [\n      ...new Set([\n        this.inputKey,\n        ...this.llmChain.inputKeys,\n        ...this.refineLLMChain.inputKeys,\n      ]),\n    ].filter(\n      (key) =>\n        key !== this.documentVariableName && key !== this.initialResponseName\n    );\n  }\n\n  get outputKeys() {\n    return [this.outputKey];\n  }\n\n  constructor(fields: RefineDocumentsChainInput) {\n    super(fields);\n    this.llmChain = fields.llmChain;\n    this.refineLLMChain = fields.refineLLMChain;\n    this.documentVariableName =\n      fields.documentVariableName ?? this.documentVariableName;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.outputKey = fields.outputKey ?? this.outputKey;\n    this.documentPrompt = fields.documentPrompt ?? this.documentPrompt;\n    this.initialResponseName =\n      fields.initialResponseName ?? this.initialResponseName;\n  }\n\n  /** @ignore */\n  async _constructInitialInputs(doc: Document, rest: Record<string, unknown>) {\n    const baseInfo: Record<string, unknown> = {\n      page_content: doc.pageContent,\n      ...doc.metadata,\n    };\n    const documentInfo: Record<string, unknown> = {};\n    this.documentPrompt.inputVariables.forEach((value) => {\n      documentInfo[value] = baseInfo[value];\n    });\n\n    const baseInputs: Record<string, unknown> = {\n      [this.documentVariableName]: await this.documentPrompt.format({\n        ...documentInfo,\n      }),\n    };\n    const inputs = { ...baseInputs, ...rest };\n    return inputs;\n  }\n\n  /** @ignore */\n  async _constructRefineInputs(doc: Document, res: string) {\n    const baseInfo: Record<string, unknown> = {\n      page_content: doc.pageContent,\n      ...doc.metadata,\n    };\n    const documentInfo: Record<string, unknown> = {};\n    this.documentPrompt.inputVariables.forEach((value) => {\n      documentInfo[value] = baseInfo[value];\n    });\n    const baseInputs: Record<string, unknown> = {\n      [this.documentVariableName]: await this.documentPrompt.format({\n        ...documentInfo,\n      }),\n    };\n    const inputs = { [this.initialResponseName]: res, ...baseInputs };\n    return inputs;\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const { [this.inputKey]: docs, ...rest } = values;\n\n    const currentDocs = docs as Document[];\n\n    const initialInputs = await this._constructInitialInputs(\n      currentDocs[0],\n      rest\n    );\n    let res = await this.llmChain.predict(\n      { ...initialInputs },\n      runManager?.getChild(\"answer\")\n    );\n\n    const refineSteps = [res];\n\n    for (let i = 1; i < currentDocs.length; i += 1) {\n      const refineInputs = await this._constructRefineInputs(\n        currentDocs[i],\n        res\n      );\n      const inputs = { ...refineInputs, ...rest };\n      res = await this.refineLLMChain.predict(\n        { ...inputs },\n        runManager?.getChild(\"refine\")\n      );\n      refineSteps.push(res);\n    }\n\n    return { [this.outputKey]: res };\n  }\n\n  _chainType() {\n    return \"refine_documents_chain\" as const;\n  }\n\n  static async deserialize(data: SerializedRefineDocumentsChain) {\n    const SerializedLLMChain = data.llm_chain;\n\n    if (!SerializedLLMChain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n\n    const SerializedRefineDocumentChain = data.refine_llm_chain;\n\n    if (!SerializedRefineDocumentChain) {\n      throw new Error(\"Missing refine_llm_chain\");\n    }\n\n    return new RefineDocumentsChain({\n      llmChain: await LLMChain.deserialize(SerializedLLMChain),\n      refineLLMChain: await LLMChain.deserialize(SerializedRefineDocumentChain),\n    });\n  }\n\n  serialize(): SerializedRefineDocumentsChain {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n      refine_llm_chain: this.refineLLMChain.serialize(),\n    };\n  }\n}\n"],"mappings":"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"}