{"version":3,"file":"parser.js","names":["allowedComparators: Comparator[]","allowedOperators: Operator[]","funcName: string","parsed: CallExpressionType","node: ParsedType","expression: string"],"sources":["../../../src/chains/query_constructor/parser.ts"],"sourcesContent":["import {\n  Comparator,\n  Comparators,\n  Comparison,\n  FilterDirective,\n  Operation,\n  Operator,\n  Operators,\n} from \"@langchain/core/structured_query\";\nimport {\n  CallExpressionType,\n  ExpressionParser,\n  ParsedType,\n} from \"../../output_parsers/expression.js\";\n\n/**\n * A type representing the possible types that can be traversed in an\n * expression.\n */\nexport type TraverseType =\n  | boolean\n  | Operation\n  | Comparison\n  | string\n  | number\n  | { [key: string]: TraverseType }\n  | TraverseType[];\n\n/**\n * A class for transforming and parsing query expressions.\n */\nexport class QueryTransformer {\n  constructor(\n    public allowedComparators: Comparator[] = [],\n    public allowedOperators: Operator[] = []\n  ) {}\n\n  /**\n   * Matches a function name to a comparator or operator. Throws an error if\n   * the function name is unknown or not allowed.\n   * @param funcName The function name to match.\n   * @returns The matched function name.\n   */\n  private matchFunctionName(funcName: string) {\n    if (funcName in Comparators) {\n      if (this.allowedComparators.length > 0) {\n        if (this.allowedComparators.includes(funcName as Comparator)) {\n          return funcName;\n        } else {\n          throw new Error(\"Received comparator not allowed\");\n        }\n      } else {\n        return funcName;\n      }\n    }\n    if (funcName in Operators) {\n      if (this.allowedOperators.length > 0) {\n        if (this.allowedOperators.includes(funcName as Operator)) {\n          return funcName;\n        } else {\n          throw new Error(\"Received operator not allowed\");\n        }\n      } else {\n        return funcName;\n      }\n    }\n    throw new Error(\"Unknown function name\");\n  }\n\n  /**\n   * Transforms a parsed expression into an operation or comparison. Throws\n   * an error if the parsed expression is not supported.\n   * @param parsed The parsed expression to transform.\n   * @returns The transformed operation or comparison.\n   */\n  private transform(parsed: CallExpressionType): Operation | Comparison {\n    const traverse = (node: ParsedType): TraverseType => {\n      switch (node.type) {\n        case \"call_expression\": {\n          if (typeof node.funcCall !== \"string\") {\n            throw new Error(\n              \"Property access expression and element access expression not supported\"\n            );\n          }\n          const funcName = this.matchFunctionName(node.funcCall);\n          if (funcName in Operators) {\n            return new Operation(\n              funcName as Operator,\n              node.args?.map((arg) => traverse(arg)) as FilterDirective[]\n            );\n          }\n          if (funcName in Comparators) {\n            if (node.args && node.args.length === 2) {\n              const [attribute, value] = node.args;\n              return new Comparison(\n                funcName as Comparator,\n                traverse(attribute) as string,\n                traverse(value) as string | number\n              );\n            }\n            throw new Error(\"Comparator must have exactly 2 arguments\");\n          }\n          throw new Error(\"Function name neither operator nor comparator\");\n        }\n        case \"string_literal\": {\n          return node.value;\n        }\n        case \"numeric_literal\": {\n          return node.value;\n        }\n        case \"array_literal\": {\n          return node.values.map((value) => traverse(value));\n        }\n        case \"object_literal\": {\n          return node.values.reduce(\n            (acc, value) => {\n              acc[value.identifier] = traverse(value.value);\n              return acc;\n            },\n            {} as { [key: string]: TraverseType }\n          );\n        }\n        case \"boolean_literal\": {\n          return node.value;\n        }\n        default: {\n          throw new Error(\"Unknown node type\");\n        }\n      }\n    };\n    return traverse(parsed) as Operation | Comparison;\n  }\n\n  /**\n   * Parses an expression and returns the transformed operation or\n   * comparison. Throws an error if the expression cannot be parsed.\n   * @param expression The expression to parse.\n   * @returns A Promise that resolves to the transformed operation or comparison.\n   */\n  async parse(expression: string): Promise<Operation | Comparison> {\n    const expressionParser = new ExpressionParser();\n    const parsed = (await expressionParser.parse(\n      expression\n    )) as CallExpressionType;\n    if (!parsed) {\n      throw new Error(\"Could not parse expression\");\n    }\n    return this.transform(parsed);\n  }\n}\n"],"mappings":";;;;;;;AA+BA,IAAa,mBAAb,MAA8B;CAC5B,YACSA,qBAAmC,CAAE,GACrCC,mBAA+B,CAAE,GACxC;EAFO;EACA;CACL;;;;;;;CAQJ,AAAQ,kBAAkBC,UAAkB;AAC1C,MAAI,YAAY,YACd,KAAI,KAAK,mBAAmB,SAAS,EACnC,KAAI,KAAK,mBAAmB,SAAS,SAAuB,CAC1D,QAAO;MAEP,OAAM,IAAI,MAAM;MAGlB,QAAO;AAGX,MAAI,YAAY,UACd,KAAI,KAAK,iBAAiB,SAAS,EACjC,KAAI,KAAK,iBAAiB,SAAS,SAAqB,CACtD,QAAO;MAEP,OAAM,IAAI,MAAM;MAGlB,QAAO;AAGX,QAAM,IAAI,MAAM;CACjB;;;;;;;CAQD,AAAQ,UAAUC,QAAoD;EACpE,MAAM,WAAW,CAACC,SAAmC;AACnD,WAAQ,KAAK,MAAb;IACE,KAAK,mBAAmB;AACtB,SAAI,OAAO,KAAK,aAAa,SAC3B,OAAM,IAAI,MACR;KAGJ,MAAM,WAAW,KAAK,kBAAkB,KAAK,SAAS;AACtD,SAAI,YAAY,UACd,QAAO,IAAI,UACT,UACA,KAAK,MAAM,IAAI,CAAC,QAAQ,SAAS,IAAI,CAAC;AAG1C,SAAI,YAAY,aAAa;AAC3B,UAAI,KAAK,QAAQ,KAAK,KAAK,WAAW,GAAG;OACvC,MAAM,CAAC,WAAW,MAAM,GAAG,KAAK;AAChC,cAAO,IAAI,WACT,UACA,SAAS,UAAU,EACnB,SAAS,MAAM;MAElB;AACD,YAAM,IAAI,MAAM;KACjB;AACD,WAAM,IAAI,MAAM;IACjB;IACD,KAAK,iBACH,QAAO,KAAK;IAEd,KAAK,kBACH,QAAO,KAAK;IAEd,KAAK,gBACH,QAAO,KAAK,OAAO,IAAI,CAAC,UAAU,SAAS,MAAM,CAAC;IAEpD,KAAK,iBACH,QAAO,KAAK,OAAO,OACjB,CAAC,KAAK,UAAU;KACd,IAAI,MAAM,cAAc,SAAS,MAAM,MAAM;AAC7C,YAAO;IACR,GACD,CAAE,EACH;IAEH,KAAK,kBACH,QAAO,KAAK;IAEd,QACE,OAAM,IAAI,MAAM;GAEnB;EACF;AACD,SAAO,SAAS,OAAO;CACxB;;;;;;;CAQD,MAAM,MAAMC,YAAqD;EAC/D,MAAM,mBAAmB,IAAI;EAC7B,MAAM,SAAU,MAAM,iBAAiB,MACrC,WACD;AACD,MAAI,CAAC,OACH,OAAM,IAAI,MAAM;AAElB,SAAO,KAAK,UAAU,OAAO;CAC9B;AACF"}