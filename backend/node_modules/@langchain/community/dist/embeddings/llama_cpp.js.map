{"version":3,"file":"llama_cpp.js","names":["inputs: LlamaCppEmbeddingsParams","inputs: LlamaBaseCppInputs","texts: string[]","embeddings: number[][]","text: string"],"sources":["../../src/embeddings/llama_cpp.ts"],"sourcesContent":["import { LlamaModel, LlamaEmbeddingContext, getLlama } from \"node-llama-cpp\";\nimport { Embeddings, type EmbeddingsParams } from \"@langchain/core/embeddings\";\nimport {\n  LlamaBaseCppInputs,\n  createLlamaModel,\n  createLlamaEmbeddingContext,\n} from \"../utils/llama_cpp.js\";\n\n/**\n * Note that the modelPath is the only required parameter. For testing you\n * can set this in the environment variable `LLAMA_PATH`.\n */\nexport interface LlamaCppEmbeddingsParams\n  extends LlamaBaseCppInputs, EmbeddingsParams {}\n\n/**\n * @example\n * ```typescript\n * // Initialize LlamaCppEmbeddings with the path to the model file\n * const embeddings = await LlamaCppEmbeddings.initialize({\n *   modelPath: llamaPath,\n * });\n *\n * // Embed a query string using the Llama embeddings\n * const res = embeddings.embedQuery(\"Hello Llama!\");\n *\n * // Output the resulting embeddings\n * console.log(res);\n *\n * ```\n */\nexport class LlamaCppEmbeddings extends Embeddings {\n  _model: LlamaModel;\n\n  _embeddingContext: LlamaEmbeddingContext;\n\n  public constructor(inputs: LlamaCppEmbeddingsParams) {\n    super(inputs);\n    const _inputs = inputs;\n    _inputs.embedding = true;\n  }\n\n  /**\n   * Initializes the llama_cpp model for usage in the embeddings wrapper.\n   * @param inputs - the inputs passed onto the model.\n   * @returns A Promise that resolves to the LlamaCppEmbeddings type class.\n   */\n  public static async initialize(\n    inputs: LlamaBaseCppInputs\n  ): Promise<LlamaCppEmbeddings> {\n    const instance = new LlamaCppEmbeddings(inputs);\n    const llama = await getLlama();\n\n    instance._model = await createLlamaModel(inputs, llama);\n    instance._embeddingContext = await createLlamaEmbeddingContext(\n      instance._model,\n      inputs\n    );\n\n    return instance;\n  }\n\n  /**\n   * Generates embeddings for an array of texts.\n   * @param texts - An array of strings to generate embeddings for.\n   * @returns A Promise that resolves to an array of embeddings.\n   */\n  async embedDocuments(texts: string[]): Promise<number[][]> {\n    const embeddings: number[][] = [];\n\n    for (const text of texts) {\n      const embedding = await this.caller.call(() =>\n        this._embeddingContext.getEmbeddingFor(text)\n      );\n      embeddings.push(Array.from(embedding.vector));\n    }\n\n    return embeddings;\n  }\n\n  /**\n   * Generates an embedding for a single text.\n   * @param text - A string to generate an embedding for.\n   * @returns A Promise that resolves to an array of numbers representing the embedding.\n   */\n  async embedQuery(text: string): Promise<number[]> {\n    const embedding = await this.caller.call(() =>\n      this._embeddingContext.getEmbeddingFor(text)\n    );\n    return Array.from(embedding.vector);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AA+BA,IAAa,qBAAb,MAAa,2BAA2B,WAAW;CACjD;CAEA;CAEA,AAAO,YAAYA,QAAkC;EACnD,MAAM,OAAO;EACb,MAAM,UAAU;EAChB,QAAQ,YAAY;CACrB;;;;;;CAOD,aAAoB,WAClBC,QAC6B;EAC7B,MAAM,WAAW,IAAI,mBAAmB;EACxC,MAAM,QAAQ,MAAM,UAAU;EAE9B,SAAS,SAAS,MAAM,iBAAiB,QAAQ,MAAM;EACvD,SAAS,oBAAoB,MAAM,4BACjC,SAAS,QACT,OACD;AAED,SAAO;CACR;;;;;;CAOD,MAAM,eAAeC,OAAsC;EACzD,MAAMC,aAAyB,CAAE;AAEjC,OAAK,MAAM,QAAQ,OAAO;GACxB,MAAM,YAAY,MAAM,KAAK,OAAO,KAAK,MACvC,KAAK,kBAAkB,gBAAgB,KAAK,CAC7C;GACD,WAAW,KAAK,MAAM,KAAK,UAAU,OAAO,CAAC;EAC9C;AAED,SAAO;CACR;;;;;;CAOD,MAAM,WAAWC,MAAiC;EAChD,MAAM,YAAY,MAAM,KAAK,OAAO,KAAK,MACvC,KAAK,kBAAkB,gBAAgB,KAAK,CAC7C;AACD,SAAO,MAAM,KAAK,UAAU,OAAO;CACpC;AACF"}