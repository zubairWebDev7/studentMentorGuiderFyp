{"version":3,"file":"couchbase_query.js","names":["embedding: EmbeddingsInterface","config: CouchbaseQueryVectorStoreArgs","embeddings: EmbeddingsInterface","s: any","c: any","vectors: number[][]","documents: Document[]","options?: AddVectorOptions","uuid","documentsToInsert: { [key: string]: any }[]","options: { ids: string[] }","e: any","queryEmbeddings: number[]","filter: CouchbaseQueryVectorStoreFilter","docsWithScore: [Document, number][]","query: string","documentsToInsert: {\n      [x: string]: any;\n    }[]","successfulDocIds: string[]","options: CreateIndexOptions","indexParams: Record<string, any>","indexQuery: string","finalIndexName: string","texts: string[]","metadatas: object[] | object","docs: Document[]"],"sources":["../../src/vectorstores/couchbase_query.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/no-extraneous-dependencies */\nimport { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Bucket, Cluster, Collection, Scope } from \"couchbase\";\nimport { Document } from \"@langchain/core/documents\";\nimport { v4 as uuid } from \"uuid\";\n\n/**\n * Enum for different distance strategies supported by Couchbase vector search\n */\nexport enum DistanceStrategy {\n  DOT = \"dot\",\n  COSINE = \"cosine\",\n  EUCLIDEAN = \"euclidean\",\n  EUCLIDEAN_SQUARED = \"euclidean_squared\",\n}\n\nexport enum IndexType {\n  COMPOSITE = \"composite\",\n  HYPERSCALE = \"hyperscale\",\n}\n\n/**\n * Interface for create_index method parameters\n */\nexport interface CreateIndexOptions {\n  indexType: IndexType;\n  indexDescription: string;\n  distanceMetric?: DistanceStrategy;\n  indexName?: string;\n  vectorField?: string;\n  vectorDimension?: number;\n  fields?: string[];\n  whereClause?: string;\n  indexScanNprobes?: number;\n  indexTrainlist?: number;\n}\n\n/**\n * This interface define the optional fields for adding vector\n * - `ids` - vector of ids for each document. If undefined, then uuid will be used\n * - `metadata` - vector of metadata object for each document\n */\nexport interface AddVectorOptions {\n  ids?: string[];\n  metadata?: Record<string, any>[];\n}\n\n/**\n * This interface defines the fields required to initialize a query vector store\n * These are the fields part of config:\n * @property {Cluster} cluster - The Couchbase cluster that the store will interact with.\n * @property {string} bucketName - The name of the bucket in the Couchbase cluster.\n * @property {string} scopeName - The name of the scope within the bucket.\n * @property {string} collectionName - The name of the collection within the scope.\n * @property {string} textKey - The key to be used for text in the documents. Defaults to \"text\".\n * @property {string} embeddingKey - The key to be used for embeddings in the documents. Defaults to \"embedding\".\n * @property {DistanceStrategy} distanceStrategy - The distance strategy to use for vector similarity calculations. Defaults to DOT.\n * @property {AddVectorOptions} addVectorOptions - Options for adding vectors with specific id/metadata\n */\nexport interface CouchbaseQueryVectorStoreArgs {\n  cluster: Cluster;\n  bucketName: string;\n  scopeName: string;\n  collectionName: string;\n  textKey?: string;\n  embeddingKey?: string;\n  distanceStrategy?: DistanceStrategy;\n  addVectorOptions?: AddVectorOptions;\n}\n\n/**\n * This type defines the search filters used in couchbase query vector search\n * - `where`: Optional WHERE clause conditions for the SQL++ query\n * - `fields`: Optional list of fields to include in the results\n */\ntype CouchbaseQueryVectorStoreFilter = {\n  where?: string;\n  fields?: string[];\n};\n\n/**\n * Class for interacting with the Couchbase database using Query service for vector search.\n * It extends the VectorStore class and provides methods for adding vectors and\n * documents, and searching for similar vectors using SQL++ queries.\n * Initiate the class using initialize() method.\n */\nexport class CouchbaseQueryVectorStore extends VectorStore {\n  declare FilterType: CouchbaseQueryVectorStoreFilter;\n\n  private metadataKey = \"metadata\";\n\n  private readonly defaultTextKey = \"text\";\n\n  private readonly defaultEmbeddingKey = \"embedding\";\n\n  private readonly defaultDistanceStrategy = DistanceStrategy.DOT;\n\n  private cluster: Cluster;\n\n  private _bucket: Bucket;\n\n  private _scope: Scope;\n\n  private _collection: Collection;\n\n  private bucketName: string;\n\n  private scopeName: string;\n\n  private collectionName: string;\n\n  private textKey = this.defaultTextKey;\n\n  private embeddingKey = this.defaultEmbeddingKey;\n\n  private distanceStrategy = this.defaultDistanceStrategy;\n\n  /**\n   * The private constructor used to provide embedding to parent class.\n   * Initialize the class using static initialize() method\n   * @param embedding - object to generate embedding\n   * @param config -  the fields required to initialize a vector store\n   */\n  private constructor(\n    embedding: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ) {\n    super(embedding, config);\n  }\n\n  _vectorstoreType(): string {\n    return \"couchbase_query\";\n  }\n\n  /**\n   * initialize class for interacting with the Couchbase database using Query service.\n   * It extends the VectorStore class and provides methods\n   * for adding vectors and documents, and searching for similar vectors.\n   * This also verifies the params\n   *\n   * @param embeddings - object to generate embedding\n   * @param config - the fields required to initialize a vector store\n   */\n  static async initialize(\n    embeddings: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ) {\n    const store = new CouchbaseQueryVectorStore(embeddings, config);\n\n    const {\n      cluster,\n      bucketName,\n      scopeName,\n      collectionName,\n      textKey,\n      embeddingKey,\n      distanceStrategy,\n    } = config;\n\n    store.cluster = cluster;\n    store.bucketName = bucketName;\n    store.scopeName = scopeName;\n    store.collectionName = collectionName;\n    if (textKey) {\n      store.textKey = textKey;\n    } else {\n      store.textKey = store.defaultTextKey;\n    }\n\n    if (embeddingKey) {\n      store.embeddingKey = embeddingKey;\n    } else {\n      store.embeddingKey = store.defaultEmbeddingKey;\n    }\n\n    if (distanceStrategy) {\n      store.distanceStrategy = distanceStrategy;\n    } else {\n      store.distanceStrategy = store.defaultDistanceStrategy;\n    }\n\n    try {\n      store._bucket = store.cluster.bucket(store.bucketName);\n      store._scope = store._bucket.scope(store.scopeName);\n      store._collection = store._scope.collection(store.collectionName);\n    } catch (err) {\n      throw new Error(\n        `Error connecting to couchbase, Please check connection and credentials. ${err}`\n      );\n    }\n\n    try {\n      if (\n        !(await store.checkBucketExists()) ||\n        !(await store.checkScopeAndCollectionExists())\n      ) {\n        throw new Error(\"Error while initializing vector store\");\n      }\n    } catch (err) {\n      throw new Error(`Error while initializing vector store: ${err}`);\n    }\n    return store;\n  }\n\n  /**\n   * An asynchronous method to verify the bucket exists.\n   * It retrieves bucket information and checks if the bucket is present.\n   *\n   * @throws - If the specified bucket does not exist in the database.\n   *\n   * @returns - returns promise true if no error is found\n   */\n  private async checkBucketExists(): Promise<boolean> {\n    try {\n      await this.cluster.buckets().getBucket(this.bucketName);\n      return true;\n    } catch (err) {\n      throw new Error(\n        `Bucket with name ${this.bucketName} does not exist. Error: ${err}`\n      );\n    }\n  }\n\n  /**\n   * An asynchronous method to verify the scope and collection exist.\n   * It checks if the specified scope and collection are present.\n   *\n   * @throws - If the specified scope or collection does not exist in the database.\n   *\n   * @returns - returns promise true if no error is found\n   */\n  private async checkScopeAndCollectionExists(): Promise<boolean> {\n    try {\n      const scopes = await this._bucket.collections().getAllScopes();\n      const scope = scopes.find((s: any) => s.name === this.scopeName);\n      if (!scope) {\n        throw new Error(`Scope ${this.scopeName} does not exist`);\n      }\n\n      const collection = scope.collections.find(\n        (c: any) => c.name === this.collectionName\n      );\n      if (!collection) {\n        throw new Error(`Collection ${this.collectionName} does not exist`);\n      }\n\n      return true;\n    } catch (err) {\n      throw new Error(\n        `Scope ${this.scopeName} or Collection ${this.collectionName} does not exist. Error: ${err}`\n      );\n    }\n  }\n\n  /**\n   * Method to add vectors and documents to the vector store.\n   *\n   * @param vectors - Vectors to be added to the vector store.\n   * @param documents - Documents to be added to the vector store.\n   * @param options - Optional parameters for adding vectors.\n   *\n   * @returns - Promise that resolves to an array of document IDs.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: AddVectorOptions\n  ): Promise<string[]> {\n    if (vectors.length === 0) {\n      return [];\n    }\n\n    if (vectors.length !== documents.length) {\n      throw new Error(\"Vectors and documents must have the same length\");\n    }\n\n    const documentIds = options?.ids || documents.map(() => uuid());\n    const documentsToInsert: { [key: string]: any }[] = [];\n\n    for (let index = 0; index < vectors.length; index += 1) {\n      const vector = vectors[index];\n      const document = documents[index];\n      const documentId = documentIds[index];\n\n      const documentToInsert = {\n        [documentId]: {\n          [this.textKey]: document.pageContent,\n          [this.embeddingKey]: vector,\n          [this.metadataKey]: document.metadata,\n        },\n      };\n\n      documentsToInsert.push(documentToInsert);\n    }\n\n    const docIds = await this.upsertDocuments(documentsToInsert);\n    return docIds;\n  }\n\n  /**\n   * Method to add documents to the vector store. It first converts\n   * the documents to vectors using the embeddings and then adds them to the vector store.\n   *\n   * @param documents - Documents to be added to the vector store.\n   * @param options - Optional parameters for adding documents.\n   *\n   * @returns - Promise that resolves to an array of document IDs.\n   */\n  async addDocuments(\n    documents: Document[],\n    options?: AddVectorOptions\n  ): Promise<string[]> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    const vectors = await this.embeddings.embedDocuments(texts);\n    return this.addVectors(vectors, documents, options);\n  }\n\n  /**\n   * Method to delete documents from the vector store.\n   *\n   * @param ids - Array of document IDs to be deleted.\n   *\n   * @returns - Promise that resolves when the deletion is complete.\n   */\n  async delete(options: { ids: string[] }): Promise<void> {\n    const { ids } = options;\n    const deletePromises = ids.map((id) =>\n      this._collection.remove(id).catch((e: any) => {\n        throw new Error(`Delete failed with error: ${e}`);\n      })\n    );\n\n    await Promise.all(deletePromises);\n  }\n\n  /**\n   * Return documents that are most similar to the vector embedding using SQL++ query.\n   *\n   * @param queryEmbeddings - Embedding vector to look up documents similar to.\n   * @param k - Number of documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - Promise of list of [document, score] that are the most similar to the query vector.\n   *\n   * @throws If the search operation fails.\n   */\n  async similaritySearchVectorWithScore(\n    queryEmbeddings: number[],\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<[Document, number][]> {\n    const { where, fields } = filter;\n\n    // Build the SELECT clause\n    let selectClause = `META().id, ${this.textKey}, ${this.metadataKey}`;\n    if (fields && fields.length > 0) {\n      selectClause = fields.join(\", \");\n      if (!fields.includes(this.textKey)) {\n        selectClause += `, ${this.textKey}`;\n      }\n      if (!fields.includes(this.metadataKey)) {\n        selectClause += `, ${this.metadataKey}`;\n      }\n      if (!fields.includes(\"META().id\")) {\n        selectClause += `, META().id`;\n      }\n    }\n\n    // Build the WHERE clause\n    let whereClause = \"\";\n    if (where) {\n      whereClause = `AND ${where}`;\n    }\n\n    // Build the SQL++ query with vector search using APPROX_VECTOR_DISTANCE function\n    // Using the configured distance metric for similarity scoring\n\n    const distanceMetric = this.distanceStrategy;\n    const query = `\n      SELECT ${selectClause},\n             APPROX_VECTOR_DISTANCE(${this.embeddingKey}, [${queryEmbeddings}], \"${distanceMetric}\") as distance\n      FROM \\`${this.bucketName}\\`.\\`${this.scopeName}\\`.\\`${this.collectionName}\\`\n      WHERE ${this.embeddingKey} IS NOT NULL ${whereClause}\n      ORDER BY APPROX_VECTOR_DISTANCE(${this.embeddingKey}, [${queryEmbeddings}], \"${distanceMetric}\")\n      LIMIT ${k}\n    `;\n\n    const docsWithScore: [Document, number][] = [];\n    try {\n      const result = await this.cluster.query(query, {\n        parameters: {\n          queryVector: queryEmbeddings,\n          k,\n        },\n      });\n\n      for (const row of result.rows) {\n        const text = row[this.textKey];\n        const metadata = row[this.metadataKey] || {};\n        // Convert distance to similarity score (lower distance = higher similarity)\n        const distance = row.distance || 0;\n        const doc = new Document({\n          pageContent: text,\n          metadata,\n        });\n        docsWithScore.push([doc, distance]);\n      }\n    } catch (err) {\n      throw new Error(`Query failed with error: ${err}`);\n    }\n    return docsWithScore;\n  }\n\n  /**\n   * Return documents that are most similar to the vector embedding.\n   *\n   * @param queryEmbeddings - Embedding to look up documents similar to.\n   * @param k - The number of similar documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - A promise that resolves to an array of documents that match the similarity search.\n   */\n  async similaritySearchByVector(\n    queryEmbeddings: number[],\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<Document[]> {\n    const docsWithScore = await this.similaritySearchVectorWithScore(\n      queryEmbeddings,\n      k,\n      filter\n    );\n    const docs = [];\n    for (const doc of docsWithScore) {\n      docs.push(doc[0]);\n    }\n    return docs;\n  }\n\n  /**\n   * Return documents that are most similar to the query.\n   *\n   * @param query - Query to look up for similar documents\n   * @param k - The number of similar documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - Promise of list of documents that are most similar to the query.\n   */\n  async similaritySearch(\n    query: string,\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<Document[]> {\n    const queryEmbeddings = await this.embeddings.embedQuery(query);\n    const docsWithScore = await this.similaritySearchVectorWithScore(\n      queryEmbeddings,\n      k,\n      filter\n    );\n    const docs = [];\n    for (const doc of docsWithScore) {\n      docs.push(doc[0]);\n    }\n    return docs;\n  }\n\n  /**\n   * Return documents that are most similar to the query with their scores.\n   *\n   * @param query - Query to look up for similar documents\n   * @param k - The number of similar documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - Promise of list of documents that are most similar to the query.\n   */\n  async similaritySearchWithScore(\n    query: string,\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<[Document, number][]> {\n    const queryEmbeddings = await this.embeddings.embedQuery(query);\n    const docsWithScore = await this.similaritySearchVectorWithScore(\n      queryEmbeddings,\n      k,\n      filter\n    );\n    return docsWithScore;\n  }\n\n  /**\n   * upsert documents asynchronously into a couchbase collection\n   * @param documentsToInsert Documents to be inserted into couchbase collection with embeddings, original text and metadata\n   * @returns DocIds of the inserted documents\n   */\n  private async upsertDocuments(\n    documentsToInsert: {\n      [x: string]: any;\n    }[]\n  ) {\n    // Create promises for each document to be upserted\n    const upsertDocumentsPromises = documentsToInsert.map((document) => {\n      const currentDocumentKey = Object.keys(document)[0];\n      return this._collection\n        .upsert(currentDocumentKey, document[currentDocumentKey])\n        .then(() => currentDocumentKey)\n        .catch((e: any) => {\n          throw new Error(`Upsert failed with error: ${e}`);\n        });\n    });\n\n    // Upsert all documents asynchronously\n    const docIds = await Promise.all(upsertDocumentsPromises);\n    const successfulDocIds: string[] = [];\n    for (const id of docIds) {\n      if (id) {\n        successfulDocIds.push(id);\n      }\n    }\n    return successfulDocIds;\n  }\n\n  /**\n   * Create a new vector index for the Query vector store.\n   *\n   * @param options - Configuration options for creating the index\n   * @param options.indexType - Type of the index (HYPERSCALE or COMPOSITE) to create\n   * @param options.indexDescription - Description of the index like \"IVF,SQ8\"\n   * @param options.distanceMetric - Distance metric to use for the index. Defaults to the distance metric in the constructor\n   * @param options.indexName - Name of the index to create. Defaults to \"langchain_{indexType}_query_index\"\n   * @param options.vectorField - Name of the vector field to use for the index. Defaults to the embedding key in the constructor\n   * @param options.vectorDimension - Dimension of the vector field. If not provided, it will be determined from the embedding object\n   * @param options.fields - List of fields to include in the index. Defaults to the text field in the constructor\n   * @param options.whereClause - Optional where clause to filter the documents to index\n   * @param options.indexScanNprobes - Number of probes to use for the index\n   * @param options.indexTrainlist - Number of training samples to use for the index\n   *\n   * @throws {Error} If index creation fails or invalid parameters are provided\n   */\n  async createIndex(options: CreateIndexOptions): Promise<void> {\n    const {\n      indexType,\n      indexDescription,\n      distanceMetric,\n      indexName,\n      vectorField,\n      vectorDimension,\n      fields,\n      whereClause,\n      indexScanNprobes,\n      indexTrainlist,\n    } = options;\n\n    if (!Object.values(IndexType).includes(indexType)) {\n      throw new Error(\n        `Invalid index type. Got ${indexType}. Expected one of: ${Object.values(\n          IndexType\n        ).join(\", \")}`\n      );\n    }\n\n    if (!indexDescription) {\n      throw new Error(\n        \"Index description is required for creating Vector Query index.\"\n      );\n    }\n\n    const similarityMetric = distanceMetric || this.distanceStrategy;\n    const vectorFieldName = vectorField || this.embeddingKey;\n\n    // Get the vector dimension for the index\n    let vectorDim = vectorDimension;\n    if (!vectorDim) {\n      try {\n        const testEmbedding = await this.embeddings.embedQuery(\n          \"check the size of the vector embeddings\"\n        );\n        vectorDim = testEmbedding.length;\n      } catch (e) {\n        throw new Error(\n          \"Vector dimension is required for creating Query index. \" +\n            \"Unable to determine the dimension from the embedding object. \" +\n            `Error: ${e}`\n        );\n      }\n    }\n\n    // Create the index parameters for the index creation query\n    const indexParams: Record<string, any> = {\n      dimension: vectorDim,\n      similarity: similarityMetric,\n      description: indexDescription,\n    };\n\n    if (indexScanNprobes) {\n      indexParams.scan_nprobes = indexScanNprobes;\n    }\n    if (indexTrainlist) {\n      indexParams.train_list = indexTrainlist;\n    }\n\n    // Add the text field to the fields if empty or if it is not present\n    const includeFields = fields || [this.textKey];\n    if (!includeFields.includes(this.textKey)) {\n      includeFields.push(this.textKey);\n    }\n\n    // Build where clause if provided\n    const whereClauseStr = whereClause ? `WHERE ${whereClause}` : \"\";\n\n    // Convert index params to WITH clause format\n    const withClause = `WITH ${JSON.stringify(indexParams).replace(/\"/g, \"'\")}`;\n\n    let indexQuery: string;\n    let finalIndexName: string;\n\n    if (indexType === IndexType.HYPERSCALE) {\n      finalIndexName = indexName || \"langchain_hyperscale_query_index\";\n      // HYPERSCALE: Specialized vector index with INCLUDE clause for additional fields\n      indexQuery =\n        `CREATE VECTOR INDEX \\`${finalIndexName}\\` ON \\`${this.bucketName}\\`.\\`${this.scopeName}\\`.\\`${this.collectionName}\\` ` +\n        `(\\`${vectorFieldName}\\` VECTOR) INCLUDE (${includeFields\n          .map((f) => `\\`${f}\\``)\n          .join(\", \")}) ` +\n        `${whereClauseStr} USING GSI ${withClause}`;\n    } else if (indexType === IndexType.COMPOSITE) {\n      finalIndexName = indexName || \"langchain_composite_query_index\";\n      // COMPOSITE: General GSI index that includes vector field alongside other fields with VECTOR keyword\n      indexQuery =\n        `CREATE INDEX \\`${finalIndexName}\\` ON \\`${this.bucketName}\\`.\\`${this.scopeName}\\`.\\`${this.collectionName}\\` ` +\n        `(${includeFields\n          .map((f) => `\\`${f}\\``)\n          .join(\", \")}, \\`${vectorFieldName}\\` VECTOR) ` +\n        `${whereClauseStr} USING GSI ${withClause}`;\n    } else {\n      throw new Error(`Unsupported index type: ${indexType}`);\n    }\n\n    try {\n      await this.cluster.query(indexQuery);\n    } catch (e) {\n      if (\n        e &&\n        typeof e === \"object\" &&\n        \"cause\" in e &&\n        e.cause &&\n        typeof e.cause === \"object\" &&\n        \"first_error_message\" in e.cause\n      ) {\n        throw new Error(\n          `Index creation failed with error: ${e.cause.first_error_message}`\n        );\n      }\n      throw new Error(`Index creation failed with error: ${e}`);\n    }\n  }\n\n  /**\n   * Static method to create a new CouchbaseQueryVectorStore from an array of texts.\n   * It first converts the texts to vectors using the embeddings and then creates a new vector store.\n   *\n   * @param texts - Array of texts to be converted to vectors.\n   * @param metadatas - Array of metadata objects corresponding to the texts.\n   * @param embeddings - Embeddings to be used for converting texts to vectors.\n   * @param config - Configuration for the vector store.\n   *\n   * @returns - Promise that resolves to a new CouchbaseQueryVectorStore instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ): Promise<CouchbaseQueryVectorStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return CouchbaseQueryVectorStore.fromDocuments(docs, embeddings, config);\n  }\n\n  /**\n   * Static method to create a new CouchbaseQueryVectorStore from an array of documents.\n   * It first converts the documents to vectors using the embeddings and then creates a new vector store.\n   *\n   * @param docs - Array of documents to be converted to vectors.\n   * @param embeddings - Embeddings to be used for converting documents to vectors.\n   * @param config - Configuration for the vector store.\n   *\n   * @returns - Promise that resolves to a new CouchbaseQueryVectorStore instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ): Promise<CouchbaseQueryVectorStore> {\n    const instance = await CouchbaseQueryVectorStore.initialize(\n      embeddings,\n      config\n    );\n    await instance.addDocuments(docs);\n    return instance;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;AAWA,IAAY,gEAAL;;;;;;AAKN;AAED,IAAY,kDAAL;;;;AAGN;;;;;;;AAmED,IAAa,4BAAb,MAAa,kCAAkC,YAAY;CAGzD,AAAQ,cAAc;CAEtB,AAAiB,iBAAiB;CAElC,AAAiB,sBAAsB;CAEvC,AAAiB,0BAA0B,iBAAiB;CAE5D,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ,UAAU,KAAK;CAEvB,AAAQ,eAAe,KAAK;CAE5B,AAAQ,mBAAmB,KAAK;;;;;;;CAQhC,AAAQ,YACNA,WACAC,QACA;EACA,MAAM,WAAW,OAAO;CACzB;CAED,mBAA2B;AACzB,SAAO;CACR;;;;;;;;;;CAWD,aAAa,WACXC,YACAD,QACA;EACA,MAAM,QAAQ,IAAI,0BAA0B,YAAY;EAExD,MAAM,EACJ,SACA,YACA,WACA,gBACA,SACA,cACA,kBACD,GAAG;EAEJ,MAAM,UAAU;EAChB,MAAM,aAAa;EACnB,MAAM,YAAY;EAClB,MAAM,iBAAiB;AACvB,MAAI,SACF,MAAM,UAAU;OAEhB,MAAM,UAAU,MAAM;AAGxB,MAAI,cACF,MAAM,eAAe;OAErB,MAAM,eAAe,MAAM;AAG7B,MAAI,kBACF,MAAM,mBAAmB;OAEzB,MAAM,mBAAmB,MAAM;AAGjC,MAAI;GACF,MAAM,UAAU,MAAM,QAAQ,OAAO,MAAM,WAAW;GACtD,MAAM,SAAS,MAAM,QAAQ,MAAM,MAAM,UAAU;GACnD,MAAM,cAAc,MAAM,OAAO,WAAW,MAAM,eAAe;EAClE,SAAQ,KAAK;AACZ,SAAM,IAAI,MACR,CAAC,wEAAwE,EAAE,KAAK;EAEnF;AAED,MAAI;AACF,OACE,CAAE,MAAM,MAAM,mBAAmB,IACjC,CAAE,MAAM,MAAM,+BAA+B,CAE7C,OAAM,IAAI,MAAM;EAEnB,SAAQ,KAAK;AACZ,SAAM,IAAI,MAAM,CAAC,uCAAuC,EAAE,KAAK;EAChE;AACD,SAAO;CACR;;;;;;;;;CAUD,MAAc,oBAAsC;AAClD,MAAI;GACF,MAAM,KAAK,QAAQ,SAAS,CAAC,UAAU,KAAK,WAAW;AACvD,UAAO;EACR,SAAQ,KAAK;AACZ,SAAM,IAAI,MACR,CAAC,iBAAiB,EAAE,KAAK,WAAW,wBAAwB,EAAE,KAAK;EAEtE;CACF;;;;;;;;;CAUD,MAAc,gCAAkD;AAC9D,MAAI;GACF,MAAM,SAAS,MAAM,KAAK,QAAQ,aAAa,CAAC,cAAc;GAC9D,MAAM,QAAQ,OAAO,KAAK,CAACE,MAAW,EAAE,SAAS,KAAK,UAAU;AAChE,OAAI,CAAC,MACH,OAAM,IAAI,MAAM,CAAC,MAAM,EAAE,KAAK,UAAU,eAAe,CAAC;GAG1D,MAAM,aAAa,MAAM,YAAY,KACnC,CAACC,MAAW,EAAE,SAAS,KAAK,eAC7B;AACD,OAAI,CAAC,WACH,OAAM,IAAI,MAAM,CAAC,WAAW,EAAE,KAAK,eAAe,eAAe,CAAC;AAGpE,UAAO;EACR,SAAQ,KAAK;AACZ,SAAM,IAAI,MACR,CAAC,MAAM,EAAE,KAAK,UAAU,eAAe,EAAE,KAAK,eAAe,wBAAwB,EAAE,KAAK;EAE/F;CACF;;;;;;;;;;CAWD,MAAM,WACJC,SACAC,WACAC,SACmB;AACnB,MAAI,QAAQ,WAAW,EACrB,QAAO,CAAE;AAGX,MAAI,QAAQ,WAAW,UAAU,OAC/B,OAAM,IAAI,MAAM;EAGlB,MAAM,cAAc,SAAS,OAAO,UAAU,IAAI,MAAMC,IAAM,CAAC;EAC/D,MAAMC,oBAA8C,CAAE;AAEtD,OAAK,IAAI,QAAQ,GAAG,QAAQ,QAAQ,QAAQ,SAAS,GAAG;GACtD,MAAM,SAAS,QAAQ;GACvB,MAAM,WAAW,UAAU;GAC3B,MAAM,aAAa,YAAY;GAE/B,MAAM,mBAAmB,GACtB,aAAa;KACX,KAAK,UAAU,SAAS;KACxB,KAAK,eAAe;KACpB,KAAK,cAAc,SAAS;GAC9B,EACF;GAED,kBAAkB,KAAK,iBAAiB;EACzC;EAED,MAAM,SAAS,MAAM,KAAK,gBAAgB,kBAAkB;AAC5D,SAAO;CACR;;;;;;;;;;CAWD,MAAM,aACJH,WACAC,SACmB;EACnB,MAAM,QAAQ,UAAU,IAAI,CAAC,EAAE,aAAa,KAAK,YAAY;EAC7D,MAAM,UAAU,MAAM,KAAK,WAAW,eAAe,MAAM;AAC3D,SAAO,KAAK,WAAW,SAAS,WAAW,QAAQ;CACpD;;;;;;;;CASD,MAAM,OAAOG,SAA2C;EACtD,MAAM,EAAE,KAAK,GAAG;EAChB,MAAM,iBAAiB,IAAI,IAAI,CAAC,OAC9B,KAAK,YAAY,OAAO,GAAG,CAAC,MAAM,CAACC,MAAW;AAC5C,SAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,GAAG;EACjD,EAAC,CACH;EAED,MAAM,QAAQ,IAAI,eAAe;CAClC;;;;;;;;;;;;;;CAeD,MAAM,gCACJC,iBACA,IAAI,GACJC,SAA0C,CAAE,GACb;EAC/B,MAAM,EAAE,OAAO,QAAQ,GAAG;EAG1B,IAAI,eAAe,CAAC,WAAW,EAAE,KAAK,QAAQ,EAAE,EAAE,KAAK,aAAa;AACpE,MAAI,UAAU,OAAO,SAAS,GAAG;GAC/B,eAAe,OAAO,KAAK,KAAK;AAChC,OAAI,CAAC,OAAO,SAAS,KAAK,QAAQ,EAChC,gBAAgB,CAAC,EAAE,EAAE,KAAK,SAAS;AAErC,OAAI,CAAC,OAAO,SAAS,KAAK,YAAY,EACpC,gBAAgB,CAAC,EAAE,EAAE,KAAK,aAAa;AAEzC,OAAI,CAAC,OAAO,SAAS,YAAY,EAC/B,gBAAgB,CAAC,WAAW,CAAC;EAEhC;EAGD,IAAI,cAAc;AAClB,MAAI,OACF,cAAc,CAAC,IAAI,EAAE,OAAO;EAM9B,MAAM,iBAAiB,KAAK;EAC5B,MAAM,QAAQ,CAAC;aACN,EAAE,aAAa;oCACQ,EAAE,KAAK,aAAa,GAAG,EAAE,gBAAgB,IAAI,EAAE,eAAe;aACrF,EAAE,KAAK,WAAW,KAAK,EAAE,KAAK,UAAU,KAAK,EAAE,KAAK,eAAe;YACpE,EAAE,KAAK,aAAa,aAAa,EAAE,YAAY;sCACrB,EAAE,KAAK,aAAa,GAAG,EAAE,gBAAgB,IAAI,EAAE,eAAe;YACxF,EAAE,EAAE;IACZ,CAAC;EAED,MAAMC,gBAAsC,CAAE;AAC9C,MAAI;GACF,MAAM,SAAS,MAAM,KAAK,QAAQ,MAAM,OAAO,EAC7C,YAAY;IACV,aAAa;IACb;GACD,EACF,EAAC;AAEF,QAAK,MAAM,OAAO,OAAO,MAAM;IAC7B,MAAM,OAAO,IAAI,KAAK;IACtB,MAAM,WAAW,IAAI,KAAK,gBAAgB,CAAE;IAE5C,MAAM,WAAW,IAAI,YAAY;IACjC,MAAM,MAAM,IAAI,SAAS;KACvB,aAAa;KACb;IACD;IACD,cAAc,KAAK,CAAC,KAAK,QAAS,EAAC;GACpC;EACF,SAAQ,KAAK;AACZ,SAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,KAAK;EAClD;AACD,SAAO;CACR;;;;;;;;;;;;CAaD,MAAM,yBACJF,iBACA,IAAI,GACJC,SAA0C,CAAE,GACvB;EACrB,MAAM,gBAAgB,MAAM,KAAK,gCAC/B,iBACA,GACA,OACD;EACD,MAAM,OAAO,CAAE;AACf,OAAK,MAAM,OAAO,eAChB,KAAK,KAAK,IAAI,GAAG;AAEnB,SAAO;CACR;;;;;;;;;;;;CAaD,MAAM,iBACJE,OACA,IAAI,GACJF,SAA0C,CAAE,GACvB;EACrB,MAAM,kBAAkB,MAAM,KAAK,WAAW,WAAW,MAAM;EAC/D,MAAM,gBAAgB,MAAM,KAAK,gCAC/B,iBACA,GACA,OACD;EACD,MAAM,OAAO,CAAE;AACf,OAAK,MAAM,OAAO,eAChB,KAAK,KAAK,IAAI,GAAG;AAEnB,SAAO;CACR;;;;;;;;;;;;CAaD,MAAM,0BACJE,OACA,IAAI,GACJF,SAA0C,CAAE,GACb;EAC/B,MAAM,kBAAkB,MAAM,KAAK,WAAW,WAAW,MAAM;EAC/D,MAAM,gBAAgB,MAAM,KAAK,gCAC/B,iBACA,GACA,OACD;AACD,SAAO;CACR;;;;;;CAOD,MAAc,gBACZG,mBAGA;EAEA,MAAM,0BAA0B,kBAAkB,IAAI,CAAC,aAAa;GAClE,MAAM,qBAAqB,OAAO,KAAK,SAAS,CAAC;AACjD,UAAO,KAAK,YACT,OAAO,oBAAoB,SAAS,oBAAoB,CACxD,KAAK,MAAM,mBAAmB,CAC9B,MAAM,CAACL,MAAW;AACjB,UAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,GAAG;GACjD,EAAC;EACL,EAAC;EAGF,MAAM,SAAS,MAAM,QAAQ,IAAI,wBAAwB;EACzD,MAAMM,mBAA6B,CAAE;AACrC,OAAK,MAAM,MAAM,OACf,KAAI,IACF,iBAAiB,KAAK,GAAG;AAG7B,SAAO;CACR;;;;;;;;;;;;;;;;;;CAmBD,MAAM,YAAYC,SAA4C;EAC5D,MAAM,EACJ,WACA,kBACA,gBACA,WACA,aACA,iBACA,QACA,aACA,kBACA,gBACD,GAAG;AAEJ,MAAI,CAAC,OAAO,OAAO,UAAU,CAAC,SAAS,UAAU,CAC/C,OAAM,IAAI,MACR,CAAC,wBAAwB,EAAE,UAAU,mBAAmB,EAAE,OAAO,OAC/D,UACD,CAAC,KAAK,KAAK,EAAE;AAIlB,MAAI,CAAC,iBACH,OAAM,IAAI,MACR;EAIJ,MAAM,mBAAmB,kBAAkB,KAAK;EAChD,MAAM,kBAAkB,eAAe,KAAK;EAG5C,IAAI,YAAY;AAChB,MAAI,CAAC,UACH,KAAI;GACF,MAAM,gBAAgB,MAAM,KAAK,WAAW,WAC1C,0CACD;GACD,YAAY,cAAc;EAC3B,SAAQ,GAAG;AACV,SAAM,IAAI,MACR,CAEG,2HAAO,EAAE,GAAG;EAElB;EAIH,MAAMC,cAAmC;GACvC,WAAW;GACX,YAAY;GACZ,aAAa;EACd;AAED,MAAI,kBACF,YAAY,eAAe;AAE7B,MAAI,gBACF,YAAY,aAAa;EAI3B,MAAM,gBAAgB,UAAU,CAAC,KAAK,OAAQ;AAC9C,MAAI,CAAC,cAAc,SAAS,KAAK,QAAQ,EACvC,cAAc,KAAK,KAAK,QAAQ;EAIlC,MAAM,iBAAiB,cAAc,CAAC,MAAM,EAAE,aAAa,GAAG;EAG9D,MAAM,aAAa,CAAC,KAAK,EAAE,KAAK,UAAU,YAAY,CAAC,QAAQ,MAAM,IAAI,EAAE;EAE3E,IAAIC;EACJ,IAAIC;AAEJ,MAAI,cAAc,UAAU,YAAY;GACtC,iBAAiB,aAAa;GAE9B,aACE,CAAC,sBAAsB,EAAE,eAAe,QAAQ,EAAE,KAAK,WAAW,KAAK,EAAE,KAAK,UAAU,KAAK,EAAE,KAAK,eAAe,MAAG,EAChH,gBAAgB,oBAAoB,EAAE,cACzC,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CACtB,KAAK,KAAK,CAAC,EAAE,EACb,eAAe,WAAW,EAAE,YAAY;EAC9C,WAAU,cAAc,UAAU,WAAW;GAC5C,iBAAiB,aAAa;GAE9B,aACE,CAAC,eAAe,EAAE,eAAe,QAAQ,EAAE,KAAK,WAAW,KAAK,EAAE,KAAK,UAAU,KAAK,EAAE,KAAK,eAAe,IAAG,EAC3G,cACD,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CACtB,KAAK,KAAK,CAAC,IAAI,EAAE,gBAAgB,WAAW,EAC5C,eAAe,WAAW,EAAE,YAAY;EAC9C,MACC,OAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,WAAW;AAGxD,MAAI;GACF,MAAM,KAAK,QAAQ,MAAM,WAAW;EACrC,SAAQ,GAAG;AACV,OACE,KACA,OAAO,MAAM,YACb,WAAW,KACX,EAAE,SACF,OAAO,EAAE,UAAU,YACnB,yBAAyB,EAAE,MAE3B,OAAM,IAAI,MACR,CAAC,kCAAkC,EAAE,EAAE,MAAM,qBAAqB;AAGtE,SAAM,IAAI,MAAM,CAAC,kCAAkC,EAAE,GAAG;EACzD;CACF;;;;;;;;;;;;CAaD,aAAa,UACXC,OACAC,WACArB,YACAD,QACoC;EACpC,MAAMuB,OAAmB,CAAE;AAC3B,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;GACxC,MAAM,WAAW,MAAM,QAAQ,UAAU,GAAG,UAAU,KAAK;GAC3D,MAAM,SAAS,IAAI,SAAS;IAC1B,aAAa,MAAM;IACnB;GACD;GACD,KAAK,KAAK,OAAO;EAClB;AACD,SAAO,0BAA0B,cAAc,MAAM,YAAY,OAAO;CACzE;;;;;;;;;;;CAYD,aAAa,cACXA,MACAtB,YACAD,QACoC;EACpC,MAAM,WAAW,MAAM,0BAA0B,WAC/C,YACA,OACD;EACD,MAAM,SAAS,aAAa,KAAK;AACjC,SAAO;CACR;AACF"}