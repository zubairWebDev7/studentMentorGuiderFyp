{"version":3,"file":"hanavector.d.ts","names":["EmbeddingsInterface","VectorStore","MaxMarginalRelevanceSearchOptions","Document","DistanceStrategy","ComparisonRValue","Date","Array","Comparator","ComparatorFilter","LogicalOperator","LogicalFilter","Filter","PropertyFilter","HanaDBArgs","HanaDB","Promise"],"sources":["../../src/vectorstores/hanavector.d.ts"],"sourcesContent":["import type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore, MaxMarginalRelevanceSearchOptions } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nexport type DistanceStrategy = \"euclidean\" | \"cosine\";\ntype ComparisonRValue = string | number | boolean | Date | Array<ComparisonRValue>;\ntype Comparator = \"$eq\" | \"$ne\" | \"$lt\" | \"$lte\" | \"$gt\" | \"$gte\" | \"$in\" | \"$nin\" | \"$between\" | \"$like\";\ntype ComparatorFilter = {\n    [K in Comparator]?: ComparisonRValue;\n};\ntype LogicalOperator = \"$and\" | \"$or\";\ntype LogicalFilter = {\n    [K in LogicalOperator]?: Filter[];\n};\ntype PropertyFilter = {\n    [property: string]: string | number | boolean | Date | ComparatorFilter;\n};\ntype Filter = PropertyFilter | LogicalFilter;\n/**\n * Interface defining the arguments required to create an instance of\n * `HanaDB`.\n */\nexport interface HanaDBArgs {\n    connection: any;\n    distanceStrategy?: DistanceStrategy;\n    tableName?: string;\n    contentColumn?: string;\n    metadataColumn?: string;\n    vectorColumn?: string;\n    vectorColumnLength?: number;\n    specificMetadataColumns?: string[];\n}\nexport declare class HanaDB extends VectorStore {\n    private connection;\n    private distanceStrategy;\n    private static compiledPattern;\n    private tableName;\n    private contentColumn;\n    private metadataColumn;\n    private vectorColumn;\n    private vectorColumnLength;\n    FilterType: Filter;\n    private specificMetadataColumns;\n    _vectorstoreType(): string;\n    constructor(embeddings: EmbeddingsInterface, args: HanaDBArgs);\n    private executeQuery;\n    private prepareQuery;\n    private executeStatement;\n    initialize(): Promise<void>;\n    /**\n     * Sanitizes the input string by removing characters that are not alphanumeric or underscores.\n     * @param inputStr The string to be sanitized.\n     * @returns The sanitized string.\n     */\n    static sanitizeName(inputStr: string): string;\n    static escapeSqlIdentifier(inputStr: string): string;\n    /**\n     * Sanitizes the input to integer. Throws an error if the value is less than lower bound.\n     * @param inputInt The input to be sanitized.\n     * @returns The sanitized integer.\n     */\n    static sanitizeInt(inputInt: number | string, lowerBound?: number): number;\n    /**\n     * Sanitizes a list to ensure all elements are floats (numbers in TypeScript).\n     * Throws an error if any element is not a number.\n     *\n     * @param {number[]} embedding - The array of numbers (floats) to be sanitized.\n     * @returns {number[]} The sanitized array of numbers (floats).\n     * @throws {Error} Throws an error if any element is not a number.\n     */\n    static sanitizeListFloat(embedding: number[]): number[];\n    /**\n     * Sanitizes the keys of the metadata object to ensure they match the required pattern.\n     * Throws an error if any key does not match the pattern.\n     *\n     * @param {Record<string, any>} metadata - The metadata object with keys to be validated.\n     * @returns {object[] | object} The original metadata object if all keys are valid.\n     * @throws {Error} Throws an error if any metadata key is invalid.\n     */\n    private sanitizeMetadataKeys;\n    /**\n     * Parses a string representation of a float array and returns an array of numbers.\n     * @param {string} arrayAsString - The string representation of the array.\n     * @returns {number[]} An array of floats parsed from the string.\n     */\n    static parseFloatArrayFromString(arrayAsString: string): number[];\n    /**\n     * Checks if the specified column exists in the table and validates its data type and length.\n     * @param tableName The name of the table.\n     * @param columnName The name of the column to check.\n     * @param columnType The expected data type(s) of the column.\n     * @param columnLength The expected length of the column. Optional.\n     */\n    checkColumn(tableName: string, columnName: string, columnType: string | string[], columnLength?: number): Promise<void>;\n    private createTableIfNotExists;\n    tableExists(tableName: string): Promise<boolean>;\n    /**\n     * Creates a WHERE clause based on the provided filter object.\n     * @param filter - A filter object with keys as metadata fields and values as filter values.\n     * @returns A tuple containing the WHERE clause string and an array of query parameters.\n     */\n    private createWhereByFilter;\n    /**\n     * Processes a filter object to generate SQL WHERE clause components.\n     * @param filter - A filter object with keys as metadata fields and values as filter values.\n     * @returns A tuple containing the WHERE clause string and an array of query parameters.\n     */\n    private processFilterObject;\n    /**\n     * Creates an HNSW vector index on a specified table and vector column with\n     * optional build and search configurations. If no configurations are provided,\n     * default parameters from the database are used. If provided values exceed the\n     * valid ranges, an error will be raised.\n     * The index is always created in ONLINE mode.\n     *\n     * @param {object} options Object containing configuration options for the index\n     * @param {number} [options.m] (Optional) Maximum number of neighbors per graph node (Valid Range: [4, 1000])\n     * @param {number} [options.efConstruction] (Optional) Maximal candidates to consider when building the graph\n     *                                           (Valid Range: [1, 100000])\n     * @param {number} [options.efSearch] (Optional) Minimum candidates for top-k-nearest neighbor queries\n     *                                     (Valid Range: [1, 100000])\n     * @param {string} [options.indexName] (Optional) Custom index name. Defaults to <table_name>_<distance_strategy>_idx\n     * @returns {Promise<void>} Promise that resolves when index is added.\n     */\n    createHnswIndex(options?: {\n        m?: number;\n        efConstruction?: number;\n        efSearch?: number;\n        indexName?: string;\n    }): Promise<void>;\n    /**\n     * Deletes entries from the table based on the provided filter.\n     * @param ids - Optional. Deletion by ids is not supported and will throw an error.\n     * @param filter - Optional. A filter object to specify which entries to delete.\n     * @throws Error if 'ids' parameter is provided, as deletion by ids is not supported.\n     * @throws Error if 'filter' parameter is not provided, as it is required for deletion.\n     * to do: adjust the call signature\n     */\n    delete(options: {\n        ids?: string[];\n        filter?: Filter;\n    }): Promise<void>;\n    /**\n     * Static method to create a HanaDB instance from raw texts. This method embeds the documents,\n     * creates a table if it does not exist, and adds the documents to the table.\n     * @param texts Array of text documents to add.\n     * @param metadatas metadata for each text document.\n     * @param embedding EmbeddingsInterface instance for document embedding.\n     * @param dbConfig Configuration for the HanaDB.\n     * @returns A Promise that resolves to an instance of HanaDB.\n     */\n    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, dbConfig: HanaDBArgs): Promise<HanaDB>;\n    /**\n     * Creates an instance of `HanaDB` from an array of\n     * Document instances. The documents are added to the database.\n     * @param docs List of documents to be converted to vectors.\n     * @param embeddings Embeddings instance used to convert the documents to vectors.\n     * @param dbConfig Configuration for the HanaDB.\n     * @returns Promise that resolves to an instance of `HanaDB`.\n     */\n    static fromDocuments(docs: Document[], embeddings: EmbeddingsInterface, dbConfig: HanaDBArgs): Promise<HanaDB>;\n    /**\n     * Adds an array of documents to the table. The documents are first\n     * converted to vectors using the `embedDocuments` method of the\n     * `embeddings` instance.\n     * @param documents Array of Document instances to be added to the table.\n     * @returns Promise that resolves when the documents are added.\n     */\n    addDocuments(documents: Document[]): Promise<void>;\n    /**\n     * Adds an array of vectors and corresponding documents to the database.\n     * The vectors and documents are batch inserted into the database.\n     * @param vectors Array of vectors to be added to the table.\n     * @param documents Array of Document instances corresponding to the vectors.\n     * @returns Promise that resolves when the vectors and documents are added.\n     */\n    addVectors(vectors: number[][], documents: Document[]): Promise<void>;\n    /**\n       * Return docs most similar to query.\n       * @param query Query text for the similarity search.\n       * @param k Number of Documents to return. Defaults to 4.\n       * @param filter A dictionary of metadata fields and values to filter by.\n                      Defaults to None.\n       * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n       */\n    similaritySearch(query: string, k: number, filter?: this[\"FilterType\"]): Promise<Document[]>;\n    /**\n       * Return documents and score values most similar to query.\n       * @param query Query text for the similarity search.\n       * @param k Number of Documents to return. Defaults to 4.\n       * @param filter A dictionary of metadata fields and values to filter by.\n                      Defaults to None.\n       * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n       */\n    similaritySearchWithScore(query: string, k: number, filter?: this[\"FilterType\"]): Promise<[Document, number][]>;\n    /**\n       * Return docs most similar to the given embedding.\n       * @param query Query embedding for the similarity search.\n       * @param k Number of Documents to return. Defaults to 4.\n       * @param filter A dictionary of metadata fields and values to filter by.\n                      Defaults to None.\n       * @returns Promise that resolves to a list of documents and their corresponding similarity scores.\n       */\n    similaritySearchVectorWithScore(queryEmbedding: number[], k: number, filter?: this[\"FilterType\"]): Promise<[Document, number][]>;\n    /**\n     * Performs a similarity search based on vector comparison and returns documents along with their similarity scores and vectors.\n     * @param embedding The vector representation of the query for similarity comparison.\n     * @param k The number of top similar documents to return.\n     * @param filter Optional filter criteria to apply to the search query.\n     * @returns A promise that resolves to an array of tuples, each containing a Document, its similarity score, and its vector.\n     */\n    similaritySearchWithScoreAndVectorByVector(embedding: number[], k: number, filter?: this[\"FilterType\"]): Promise<Array<[Document, number, number[]]>>;\n    /**\n     * Return documents selected using the maximal marginal relevance.\n     * Maximal marginal relevance optimizes for similarity to the query AND\n     * diversity among selected documents.\n     * @param query Text to look up documents similar to.\n     * @param options.k Number of documents to return.\n     * @param options.fetchK=20 Number of documents to fetch before passing to\n     *     the MMR algorithm.\n     * @param options.lambda=0.5 Number between 0 and 1 that determines the\n     *     degree of diversity among the results, where 0 corresponds to maximum\n     *     diversity and 1 to minimum diversity.\n     * @returns List of documents selected by maximal marginal relevance.\n     */\n    maxMarginalRelevanceSearch(query: string, options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>): Promise<Document[]>;\n}\nexport {};\n//# sourceMappingURL=hanavector.d.ts.map"],"mappings":";;;;;KAGYI,gBAAAA;KACPC,gBAAAA,+BAA+CC,OAAOC,MAAMF;AADjE,KAEKG,UAAAA,GAFOJ,KAAgB,GAAA,KAAA,GAAA,KAAA,GAAA,MAAA,GAAA,KAAA,GAAA,MAAA,GAAA,KAAA,GAAA,MAAA,GAAA,UAAA,GAAA,OAAA;AAA0B,KAGjDK,gBAAAA,GAFgB,QAGXD,UAH0CF,IAG5BD,gBAH4BC,EAAaD;KAK5DK,eAAAA,GALsDH,MAAAA,GAAAA,KAAAA;AAAK,KAM3DI,aAAAA,GAN2D,QAOtDD,eANK,IAMcE,MANd,EAAA,EAAA;AAEyB,KAMnCC,cAAAA,GAJe;EACfF,CAAAA,QAAAA,EAAAA,MAAa,CAAA,EAAA,MAAA,GACRD,MAAAA,GAAAA,OAAAA,GAG0CJ,IAHjB,GAGwBG,gBAHxB;AAAA,CAAA;AAGwC,KAEtEG,MAAAA,GAASC,cAAAA,GAAiBF,aAAAA;AAK/B;AAUA;;;AAYuDG,UAtBtCA,UAAAA,CAsBsCA;EAIrCE,UAAAA,EAAAA,GAAAA;EA6C4FA,gBAAAA,CAAAA,EArEvFZ,gBAqEuFY;EAE1EA,SAAAA,CAAAA,EAAAA,MAAAA;EAkC5BA,aAAAA,CAAAA,EAAAA,MAAAA;EAWSJ,cAAAA,CAAAA,EAAAA,MAAAA;EACTI,YAAAA,CAAAA,EAAAA,MAAAA;EAUwEhB,kBAAAA,CAAAA,EAAAA,MAAAA;EAA+Bc,uBAAAA,CAAAA,EAAAA,MAAAA,EAAAA;;AAAaE,cAvHvGD,MAAAA,SAAed,WAAAA,CAuHwFe;EAS7Fb,QAAAA,UAAAA;EAAwBH,QAAAA,gBAAAA;EAA+Bc,eAAAA,eAAAA;EAAqBC,QAAAA,SAAAA;EAARC,QAAAA,aAAAA;EAQvEb,QAAAA,cAAAA;EAAaa,QAAAA,YAAAA;EAQMb,QAAAA,kBAAAA;EAAaa,UAAAA,EAvI5CJ,MAuI4CI;EASyBb,QAAAA,uBAAAA;EAARa,gBAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EASkBb,WAAAA,CAAAA,UAAAA,EAtJnEH,mBAsJmEG,EAAAA,IAAAA,EAtJxCW,UAsJwCX;EAATa,QAAAA,YAAAA;EAS0Bb,QAAAA,YAAAA;EAATa,QAAAA,gBAAAA;EAQqBb,UAAAA,CAAAA,CAAAA,EAnK1Ga,OAmK0Gb,CAAAA,IAAAA,CAAAA;EAAPI;;;;;EAnLjFN,OAAAA,YAAAA,CAAAA,QAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA;EAAW,OAAA,mBAAA,CAAA,QAAA,EAAA,MAAA,CAAA,EAAA,MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4GA6D+De;;kCAE1EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAkC5BA;;;;;;;;;;;aAWSJ;MACTI;;;;;;;;;;8EAUwEhB,+BAA+Bc,aAAaE,QAAQD;;;;;;;;;6BASrGZ,wBAAwBH,+BAA+Bc,aAAaE,QAAQD;;;;;;;;0BAQ/EZ,aAAaa;;;;;;;;6CAQMb,aAAaa;;;;;;;;;2EASiBA,QAAQb;;;;;;;;;oFASCa,SAASb;;;;;;;;;qGASQa,SAASb;;;;;;;;2GAQHa,QAAQT,OAAOJ;;;;;;;;;;;;;;qDAcrED,wDAAwDc,QAAQb"}