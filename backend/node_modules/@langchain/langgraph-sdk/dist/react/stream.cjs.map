{"version":3,"file":"stream.cjs","names":["useStreamCustom","useStreamLGP"],"sources":["../../src/react/stream.tsx"],"sourcesContent":["import { useState } from \"react\";\nimport { useStreamLGP } from \"./stream.lgp.js\";\nimport { useStreamCustom } from \"./stream.custom.js\";\nimport type { UseStreamOptions } from \"../ui/types.js\";\nimport type { BagTemplate } from \"../types.template.js\";\nimport type { UseStreamCustomOptions } from \"./types.js\";\nimport type {\n  ResolveStreamInterface,\n  ResolveStreamOptions,\n  InferBag,\n  InferStateType,\n} from \"../ui/stream/index.js\";\n\nfunction isCustomOptions<\n  StateType extends Record<string, unknown> = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(\n  options:\n    | UseStreamOptions<StateType, Bag>\n    | UseStreamCustomOptions<StateType, Bag>\n): options is UseStreamCustomOptions<StateType, Bag> {\n  return \"transport\" in options;\n}\n\n/**\n * A React hook that provides seamless integration with LangGraph streaming capabilities.\n *\n * The `useStream` hook handles all the complexities of streaming, state management, and branching logic,\n * letting you focus on building great chat experiences. It provides automatic state management for\n * messages, interrupts, loading states, subagent streams, and errors.\n *\n * ## Usage with ReactAgent (recommended for createAgent users)\n *\n * When using `createAgent` from `@langchain/langgraph`, you can pass `typeof agent` as the\n * type parameter to automatically infer tool call types:\n *\n * @example\n * ```typescript\n * // In your agent file (e.g., agent.ts)\n * import { createAgent, tool } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const getWeather = tool(\n *   async ({ location }) => `Weather in ${location}`,\n *   { name: \"get_weather\", schema: z.object({ location: z.string() }) }\n * );\n *\n * export const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [getWeather],\n * });\n *\n * // In your React component\n * import { agent } from \"./agent\";\n *\n * function Chat() {\n *   // Tool calls are automatically typed from the agent's tools!\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"agent\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.toolCalls[0].call.name is typed as \"get_weather\"\n *   // stream.toolCalls[0].call.args is typed as { location: string }\n * }\n * ```\n *\n * ## Usage with StateGraph (for custom LangGraph applications)\n *\n * When building custom graphs with `StateGraph`, embed your tool call types directly\n * in your state's messages property using `Message<MyToolCalls>`:\n *\n * @example\n * ```typescript\n * import { Message } from \"@langchain/langgraph-sdk\";\n *\n * // Define your tool call types as a discriminated union\n * type MyToolCalls =\n *   | { name: \"search\"; args: { query: string }; id?: string }\n *   | { name: \"calculate\"; args: { expression: string }; id?: string };\n *\n * // Embed tool call types in your state's messages\n * interface MyGraphState {\n *   messages: Message<MyToolCalls>[];\n *   context?: string;\n * }\n *\n * function Chat() {\n *   const stream = useStream<MyGraphState>({\n *     assistantId: \"my-graph\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.values is typed as MyGraphState\n *   // stream.toolCalls[0].call.name is typed as \"search\" | \"calculate\"\n * }\n * ```\n *\n * @example\n * ```typescript\n * // With additional type configuration (interrupts, configurable)\n * interface MyGraphState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * function Chat() {\n *   const stream = useStream<MyGraphState, {\n *     InterruptType: { question: string };\n *     ConfigurableType: { userId: string };\n *   }>({\n *     assistantId: \"my-graph\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.interrupt is typed as { question: string } | undefined\n * }\n * ```\n *\n * ## Usage with Deep Agents (subagent streaming, experimental)\n *\n * For agents that spawn subagents (nested graphs), use `filterSubagentMessages`\n * to keep the main message stream clean while tracking subagent activity separately:\n *\n * @example\n * ```typescript\n * import { useStream, SubagentStream } from \"@langchain/langgraph-sdk/react\";\n * import type { agent } from \"./agent\";\n *\n * function DeepAgentChat() {\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"deepagent\",\n *     apiUrl: \"http://localhost:2024\",\n *     // Filter subagent messages from main stream\n *     filterSubagentMessages: true,\n *   });\n *\n *   const handleSubmit = (content: string) => {\n *     stream.submit(\n *       { messages: [{ content, type: \"human\" }] },\n *       { streamSubgraphs: true } // Enable subgraph streaming\n *     );\n *   };\n *\n *   // Access subagent streams via stream.subagents (Map<string, SubagentStream>)\n *   const subagentList = [...stream.subagents.values()];\n *\n *   return (\n *     <div>\n *       {stream.messages.map((msg) => <Message key={msg.id} message={msg} />)}\n *\n *       {subagentList.map((subagent) => (\n *         <SubagentCard\n *           key={subagent.id}\n *           status={subagent.status} // \"pending\" | \"running\" | \"complete\" | \"error\"\n *           messages={subagent.messages}\n *           toolCalls={subagent.toolCalls}\n *         />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n *\n * @template T Either a ReactAgent type (with `~agentTypes`) or a state type (`Record<string, unknown>`)\n * @template Bag Type configuration bag containing:\n *   - `ConfigurableType`: Type for the `config.configurable` property\n *   - `InterruptType`: Type for interrupt values\n *   - `CustomEventType`: Type for custom events\n *   - `UpdateType`: Type for the submit function updates\n *\n * @see {@link https://docs.langchain.com/langgraph-platform/use-stream-react | LangGraph React Integration Guide}\n */\nexport function useStream<\n  T = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(\n  options: ResolveStreamOptions<T, InferBag<T, Bag>>\n): ResolveStreamInterface<T, InferBag<T, Bag>>;\n\n/**\n * A React hook that provides seamless integration with LangGraph streaming capabilities.\n *\n * The `useStream` hook handles all the complexities of streaming, state management, and branching logic,\n * letting you focus on building great chat experiences. It provides automatic state management for\n * messages, interrupts, loading states, and errors.\n *\n * @template T Either a ReactAgent type (with `~agentTypes`) or a state type (`Record<string, unknown>`)\n * @template Bag Type configuration bag containing:\n *   - `ConfigurableType`: Type for the `config.configurable` property\n *   - `InterruptType`: Type for interrupt values\n *   - `CustomEventType`: Type for custom events\n *   - `UpdateType`: Type for the submit function updates\n *\n * @see {@link https://docs.langchain.com/langgraph-platform/use-stream-react | LangGraph React Integration Guide}\n */\nexport function useStream<\n  T = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(\n  options: UseStreamCustomOptions<InferStateType<T>, InferBag<T, Bag>>\n): ResolveStreamInterface<T, InferBag<T, Bag>>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useStream(options: any): any {\n  // Store this in useState to make sure we're not changing the implementation in re-renders\n  const [isCustom] = useState(isCustomOptions(options));\n\n  if (isCustom) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useStreamCustom(options);\n  }\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useStreamLGP(options);\n}\n"],"mappings":";;;;;;AAaA,SAAS,gBAIP,SAGmD;AACnD,QAAO,eAAe;;AAsLxB,SAAgB,UAAU,SAAmB;CAE3C,MAAM,CAAC,gCAAqB,gBAAgB,QAAQ,CAAC;AAErD,KAAI,SAEF,QAAOA,sCAAgB,QAAQ;AAIjC,QAAOC,gCAAa,QAAQ"}