{"version":3,"file":"router.js","names":["schema: Y","options?: RouterOutputParserInput","text: string"],"sources":["../../src/output_parsers/router.ts"],"sourcesContent":["import { OutputParserException } from \"@langchain/core/output_parsers\";\nimport {\n  type InferInteropZodOutput,\n  type InteropZodType,\n} from \"@langchain/core/utils/types\";\nimport { JsonMarkdownStructuredOutputParser } from \"./structured.js\";\n\n/**\n * Defines the input parameters for the RouterOutputParser class. It can\n * include a default destination and an interpolation depth.\n */\nexport type RouterOutputParserInput = {\n  defaultDestination?: string;\n  interpolationDepth?: number;\n};\n\n/**\n * A type of output parser that extends the\n * JsonMarkdownStructuredOutputParser. It is used to parse the output of a\n * router in LangChain. The class takes a schema and an optional\n * RouterOutputParserInput object as parameters.\n */\nexport class RouterOutputParser<\n  Y extends InteropZodType,\n> extends JsonMarkdownStructuredOutputParser<Y> {\n  defaultDestination = \"DEFAULT\";\n\n  constructor(schema: Y, options?: RouterOutputParserInput) {\n    super(schema);\n    this.defaultDestination =\n      options?.defaultDestination ?? this.defaultDestination;\n  }\n\n  /**\n   * Overrides the parse method from JsonMarkdownStructuredOutputParser.\n   * This method takes a string as input, attempts to parse it, and returns\n   * the parsed text. If the destination of the parsed text matches the\n   * defaultDestination, the destination is set to null. If the parsing\n   * fails, an OutputParserException is thrown.\n   * @param text The text to be parsed.\n   * @returns The parsed text as a Promise.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<Y>> {\n    try {\n      const parsedText = await super.parse(text);\n      if (\n        parsedText.destination?.toLowerCase() ===\n        this.defaultDestination.toLowerCase()\n      ) {\n        parsedText.destination = null;\n      }\n\n      return parsedText;\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;AAsBA,IAAa,qBAAb,cAEU,mCAAsC;CAC9C,qBAAqB;CAErB,YAAYA,QAAWC,SAAmC;EACxD,MAAM,OAAO;EACb,KAAK,qBACH,SAAS,sBAAsB,KAAK;CACvC;;;;;;;;;;CAWD,MAAM,MAAMC,MAAiD;AAC3D,MAAI;GACF,MAAM,aAAa,MAAM,MAAM,MAAM,KAAK;AAC1C,OACE,WAAW,aAAa,aAAa,KACrC,KAAK,mBAAmB,aAAa,EAErC,WAAW,cAAc;AAG3B,UAAO;EACR,SAAQ,GAAG;AACV,SAAM,IAAI,sBACR,CAAC,wBAAwB,EAAE,KAAK,UAAU,EAAE,GAAG,EAC/C;EAEH;CACF;AACF"}