{"version":3,"file":"time_weighted.d.ts","names":["BaseRetriever","BaseRetrieverInput","VectorStoreInterface","DocumentInterface","CallbackManagerForRetrieverRun","TimeWeightedVectorStoreRetrieverFields","LAST_ACCESSED_AT_KEY","BUFFER_IDX","TimeWeightedVectorStoreRetriever","Promise"],"sources":["../../src/retrievers/time_weighted.d.ts"],"sourcesContent":["import { BaseRetriever, BaseRetrieverInput } from \"@langchain/core/retrievers\";\nimport type { VectorStoreInterface } from \"@langchain/core/vectorstores\";\nimport type { DocumentInterface } from \"@langchain/core/documents\";\nimport { CallbackManagerForRetrieverRun } from \"@langchain/core/callbacks/manager\";\n/**\n * Interface for the fields required to initialize a\n * TimeWeightedVectorStoreRetriever instance.\n */\nexport interface TimeWeightedVectorStoreRetrieverFields extends BaseRetrieverInput {\n    vectorStore: VectorStoreInterface;\n    searchKwargs?: number;\n    memoryStream?: DocumentInterface[];\n    decayRate?: number;\n    k?: number;\n    otherScoreKeys?: string[];\n    defaultSalience?: number;\n}\nexport declare const LAST_ACCESSED_AT_KEY = \"last_accessed_at\";\nexport declare const BUFFER_IDX = \"buffer_idx\";\n/**\n * TimeWeightedVectorStoreRetriever retrieves documents based on their time-weighted relevance.\n * ref: https://github.com/langchain-ai/langchain/blob/master/libs/langchain/langchain/retrievers/time_weighted_retriever.py\n * @example\n * ```typescript\n * const retriever = new TimeWeightedVectorStoreRetriever({\n *   vectorStore: new MemoryVectorStore(new OpenAIEmbeddings()),\n *   memoryStream: [],\n *   searchKwargs: 2,\n * });\n * await retriever.addDocuments([\n *   { pageContent: \"My name is John.\", metadata: {} },\n *   { pageContent: \"My favourite food is pizza.\", metadata: {} },\n *\n * ]);\n * const results = await retriever.invoke(\n *   \"What is my favourite food?\",\n * );\n * ```\n */\nexport declare class TimeWeightedVectorStoreRetriever extends BaseRetriever {\n    static lc_name(): string;\n    get lc_namespace(): string[];\n    /**\n     * The vectorstore to store documents and determine salience.\n     */\n    private vectorStore;\n    /**\n     * The number of top K most relevant documents to consider when searching.\n     */\n    private searchKwargs;\n    /**\n     * The memory_stream of documents to search through.\n     */\n    private memoryStream;\n    /**\n     * The exponential decay factor used as (1.0-decay_rate)**(hrs_passed).\n     */\n    private decayRate;\n    /**\n     * The maximum number of documents to retrieve in a given call.\n     */\n    private k;\n    /**\n     * Other keys in the metadata to factor into the score, e.g. 'importance'.\n     */\n    private otherScoreKeys;\n    /**\n     * The salience to assign memories not retrieved from the vector store.\n     */\n    private defaultSalience;\n    /**\n     * Constructor to initialize the required fields\n     * @param fields - The fields required for initializing the TimeWeightedVectorStoreRetriever\n     */\n    constructor(fields: TimeWeightedVectorStoreRetrieverFields);\n    /**\n     * Get the memory stream of documents.\n     * @returns The memory stream of documents.\n     */\n    getMemoryStream(): DocumentInterface[];\n    /**\n     * Set the memory stream of documents.\n     * @param memoryStream The new memory stream of documents.\n     */\n    setMemoryStream(memoryStream: DocumentInterface[]): void;\n    /**\n     * Get relevant documents based on time-weighted relevance\n     * @param query - The query to search for\n     * @returns The relevant documents\n     */\n    _getRelevantDocuments(query: string, runManager?: CallbackManagerForRetrieverRun): Promise<DocumentInterface[]>;\n    /**\n     * NOTE: When adding documents to a vector store, use addDocuments\n     * via retriever instead of directly to the vector store.\n     * This is because it is necessary to process the document\n     * in prepareDocuments.\n     *\n     * @param docs - The documents to add to vector store in the retriever\n     */\n    addDocuments(docs: DocumentInterface[]): Promise<void>;\n    /**\n     * Get memory documents and their scores\n     * @returns An object containing memory documents and their scores\n     */\n    private getMemoryDocsAndScores;\n    private getSalientDocuments;\n    /**\n     * Compute the final result set of documents based on the combined scores\n     * @param docsAndScores - An object containing documents and their scores\n     * @param now - The current timestamp\n     * @returns The final set of documents\n     */\n    private computeResults;\n    /**\n     * Prepare documents with necessary metadata before saving\n     * @param docs - The documents to prepare\n     * @param now - The current timestamp\n     * @returns The prepared documents\n     */\n    private prepareDocuments;\n    /**\n     * Calculate the combined score based on vector relevance and other factors\n     * @param doc - The document to calculate the score for\n     * @param vectorRelevance - The relevance score from the vector store\n     * @param nowMsec - The current timestamp in milliseconds\n     * @returns The combined score for the document\n     */\n    private getCombinedScore;\n    /**\n     * Calculate the hours passed between two time points\n     * @param time - The current time in seconds\n     * @param refTime - The reference time in seconds\n     * @returns The number of hours passed between the two time points\n     */\n    private getHoursPassed;\n}\n//# sourceMappingURL=time_weighted.d.ts.map"],"mappings":";;;;;;;;;AAQA;;AAGmBG,UAHFE,sCAAAA,SAA+CJ,kBAG7CE,CAAAA;EAH6CF,WAAAA,EAC/CC,oBAD+CD;EAAkB,YAAA,CAAA,EAAA,MAAA;EAS7DK,YAAAA,CAAAA,EANFH,iBAMsB,EAAA;EACpBI,SAAAA,CAAAA,EAAAA,MAAU;EAqBVC,CAAAA,CAAAA,EAAAA,MAAAA;EAmCGH,cAAAA,CAAAA,EAAAA,MAAAA,EAAAA;EAKDF,eAAAA,CAAAA,EAAAA,MAAAA;;AAW+BC,cAzEjCE,oBAAAA,GAyEiCF,kBAAAA;AAAyCD,cAxE1EI,UAAAA,GAwE0EJ,YAAAA;;;;;AAnDpB;;;;;;;;;;;;;;;;cAAtDK,gCAAAA,SAAyCR,aAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAmCtCK;;;;;qBAKDF;;;;;gCAKWA;;;;;;oDAMoBC,iCAAiCK,QAAQN;;;;;;;;;qBASxEA,sBAAsBM"}