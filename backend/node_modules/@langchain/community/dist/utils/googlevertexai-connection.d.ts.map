{"version":3,"file":"googlevertexai-connection.d.ts","names":["BaseLanguageModelCallOptions","AsyncCaller","AsyncCallerCallOptions","GoogleVertexAIBaseLLMInput","GoogleVertexAIBasePrediction","GoogleVertexAIConnectionParams","GoogleVertexAILLMPredictions","GoogleVertexAIModelParams","GoogleResponse","GoogleAbstractedClient","GoogleAbstractedClientOpsMethod","GoogleConnection","CallOptions","ResponseType","Promise","GoogleVertexAIConnection","AuthOptions","complexValue","simpleValue","GoogleVertexAILLMConnection","InstanceType","PredictionType","GoogleVertexAILLMResponse","GoogleVertexAIStream"],"sources":["../../src/utils/googlevertexai-connection.d.ts"],"sourcesContent":["import { BaseLanguageModelCallOptions } from \"@langchain/core/language_models/base\";\nimport { AsyncCaller, AsyncCallerCallOptions } from \"@langchain/core/utils/async_caller\";\nimport type { GoogleVertexAIBaseLLMInput, GoogleVertexAIBasePrediction, GoogleVertexAIConnectionParams, GoogleVertexAILLMPredictions, GoogleVertexAIModelParams, GoogleResponse, GoogleAbstractedClient, GoogleAbstractedClientOpsMethod } from \"../types/googlevertexai-types.js\";\nexport declare abstract class GoogleConnection<CallOptions extends AsyncCallerCallOptions, ResponseType extends GoogleResponse> {\n    caller: AsyncCaller;\n    client: GoogleAbstractedClient;\n    streaming: boolean;\n    constructor(caller: AsyncCaller, client: GoogleAbstractedClient, streaming?: boolean);\n    abstract buildUrl(): Promise<string>;\n    abstract buildMethod(): GoogleAbstractedClientOpsMethod;\n    _request(data: unknown | undefined, options: CallOptions): Promise<ResponseType>;\n}\nexport declare abstract class GoogleVertexAIConnection<CallOptions extends AsyncCallerCallOptions, ResponseType extends GoogleResponse, AuthOptions> extends GoogleConnection<CallOptions, ResponseType> implements GoogleVertexAIConnectionParams<AuthOptions> {\n    endpoint: string;\n    location: string;\n    apiVersion: string;\n    constructor(fields: GoogleVertexAIConnectionParams<AuthOptions> | undefined, caller: AsyncCaller, client: GoogleAbstractedClient, streaming?: boolean);\n    buildMethod(): GoogleAbstractedClientOpsMethod;\n}\nexport declare function complexValue(value: unknown): unknown;\nexport declare function simpleValue(val: unknown): unknown;\nexport declare class GoogleVertexAILLMConnection<CallOptions extends BaseLanguageModelCallOptions, InstanceType, PredictionType extends GoogleVertexAIBasePrediction, AuthOptions> extends GoogleVertexAIConnection<CallOptions, GoogleVertexAILLMResponse<PredictionType>, AuthOptions> implements GoogleVertexAIBaseLLMInput<AuthOptions> {\n    model: string;\n    client: GoogleAbstractedClient;\n    customModelURL: string;\n    constructor(fields: GoogleVertexAIBaseLLMInput<AuthOptions> | undefined, caller: AsyncCaller, client: GoogleAbstractedClient, streaming?: boolean);\n    buildUrl(): Promise<string>;\n    formatStreamingData(inputs: InstanceType[], parameters: GoogleVertexAIModelParams): unknown;\n    formatStandardData(instances: InstanceType[], parameters: GoogleVertexAIModelParams): unknown;\n    formatData(instances: InstanceType[], parameters: GoogleVertexAIModelParams): unknown;\n    request(instances: InstanceType[], parameters: GoogleVertexAIModelParams, options: CallOptions): Promise<GoogleVertexAILLMResponse<PredictionType>>;\n}\nexport interface GoogleVertexAILLMResponse<PredictionType extends GoogleVertexAIBasePrediction> extends GoogleResponse {\n    data: GoogleVertexAIStream | GoogleVertexAILLMPredictions<PredictionType>;\n}\nexport declare class GoogleVertexAIStream {\n    _buffer: string;\n    _bufferOpen: boolean;\n    _firstRun: boolean;\n    /**\n     * Add data to the buffer. This may cause chunks to be generated, if available.\n     * @param data\n     */\n    appendBuffer(data: string): void;\n    /**\n     * Indicate there is no more data that will be added to the text buffer.\n     * This should be called when all the data has been read and added to indicate\n     * that we should process everything remaining in the buffer.\n     */\n    closeBuffer(): void;\n    /**\n     * Skip characters in the buffer till we get to the start of an object.\n     * Then attempt to read a full object.\n     * If we do read a full object, turn it into a chunk and send it to the chunk handler.\n     * Repeat this for as much as we can.\n     */\n    _parseBuffer(): void;\n    /**\n     * If the string is present, move the start of the buffer to the first occurrence\n     * of that string. This is useful for skipping over elements or parts that we're not\n     * really interested in parsing. (ie - the opening characters, comma separators, etc.)\n     * @param start The string to start the buffer with\n     */\n    _skipTo(start: string): void;\n    /**\n     * Given what is in the buffer, parse a single object out of it.\n     * If a complete object isn't available, return null.\n     * Assumes that we are at the start of an object to parse.\n     */\n    _getFullObject(): object | null;\n    _simplifyObject(obj: unknown): object;\n    _chunkResolution: (chunk: any) => void;\n    _chunkPending: Promise<any> | null;\n    _chunkQueue: any[];\n    /**\n     * Register that we have another chunk available for consumption.\n     * If we are waiting for a chunk, resolve the promise waiting for it immediately.\n     * If not, then add it to the queue.\n     * @param chunk\n     */\n    _handleChunk(chunk: any): void;\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    nextChunk(): Promise<any>;\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone(): boolean;\n}\n//# sourceMappingURL=googlevertexai-connection.d.ts.map"],"mappings":";;;;;uBAG8BW,qCAAqCT,6CAA6CM;UACpGP;EADkBU,MAAAA,EAElBF,sBAFkCG;EAAqBV,SAAAA,EAAAA,OAAAA;EAA6CM,WAAAA,CAAAA,MAAAA,EAIxFP,WAJwFO,EAAAA,MAAAA,EAInEC,sBAJmED,EAAAA,SAAAA,CAAAA,EAAAA,OAAAA;EACpGP,SAAAA,QAAAA,CAAAA,CAAAA,EAIaa,OAJbb,CAAAA,MAAAA,CAAAA;EACAQ,SAAAA,WAAAA,CAAAA,CAAAA,EAIgBC,+BAJhBD;EAEYR,QAAAA,CAAAA,IAAAA,EAAAA,OAAAA,GAAAA,SAAAA,EAAAA,OAAAA,EAGyBW,WAHzBX,CAAAA,EAGuCa,OAHvCb,CAG+CY,YAH/CZ,CAAAA;;AACCa,uBAIKC,wBAJLD,CAAAA,oBAIkDZ,sBAJlDY,EAAAA,qBAI+FN,cAJ/FM,EAAAA,WAAAA,CAAAA,SAIoIH,gBAJpIG,CAIqJF,WAJrJE,EAIkKD,YAJlKC,CAAAA,YAI2LT,8BAJ3LS,CAI0NE,WAJ1NF,CAAAA,CAAAA;EACGJ,QAAAA,EAAAA,MAAAA;EACqBE,QAAAA,EAAAA,MAAAA;EAAsBC,UAAAA,EAAAA,MAAAA;EAARC,WAAAA,CAAAA,MAAAA,EAMvCT,8BANuCS,CAMRE,WANQF,CAAAA,GAAAA,SAAAA,EAAAA,MAAAA,EAM0Bb,WAN1Ba,EAAAA,MAAAA,EAM+CL,sBAN/CK,EAAAA,SAAAA,CAAAA,EAAAA,OAAAA;EAAO,WAAA,CAAA,CAAA,EAOnDJ,+BAPmD;AAEtE;AAoBiBY,UAAAA,yBAAyBD,CAAAA,uBAAwBjB,4BAAxB,CAAA,SAA8DI,cAA9D,CAAA;EAAwBJ,IAAAA,EACxDmB,oBADwDnB,GACjCE,4BADiCF,CACJiB,cADIjB,CAAAA;;AACJiB,cAEzCE,oBAAAA,CAFyCF;EAA7Bf,OAAAA,EAAAA,MAAAA;EADuEE,WAAAA,EAAAA,OAAAA;EAAc,SAAA,EAAA,OAAA;EAGjGe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAqCFT;;;;;;;;;;;;;eAaFA"}