{"version":3,"file":"fix.d.cts","names":["BaseLanguageModelInterface","Callbacks","BaseOutputParser","OutputParserException","BasePromptTemplate","Runnable","LLMChain","OutputFixingParserRetryInput","OutputFixingParser","T","parser","retryChain","Promise"],"sources":["../../src/output_parsers/fix.d.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { BaseOutputParser, OutputParserException } from \"@langchain/core/output_parsers\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { Runnable } from \"@langchain/core/runnables\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\ninterface OutputFixingParserRetryInput {\n    instructions: string;\n    completion: string;\n    error: OutputParserException;\n}\n/**\n * Class that extends the BaseOutputParser to handle situations where the\n * initial parsing attempt fails. It contains a retryChain for retrying\n * the parsing process in case of a failure.\n */\nexport declare class OutputFixingParser<T> extends BaseOutputParser<T> {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    parser: BaseOutputParser<T>;\n    retryChain: LLMChain | Runnable<OutputFixingParserRetryInput, T>;\n    /**\n     * Static method to create a new instance of OutputFixingParser using a\n     * given language model, parser, and optional fields.\n     * @param llm The language model to be used.\n     * @param parser The parser to be used.\n     * @param fields Optional fields which may contain a prompt.\n     * @returns A new instance of OutputFixingParser.\n     */\n    static fromLLM<T>(llm: BaseLanguageModelInterface, parser: BaseOutputParser<T>, fields?: {\n        prompt?: BasePromptTemplate;\n    }): OutputFixingParser<T>;\n    constructor({ parser, retryChain }: {\n        parser: BaseOutputParser<T>;\n        retryChain: LLMChain | Runnable<OutputFixingParserRetryInput, T>;\n    });\n    /**\n     * Method to parse the completion using the parser. If the initial parsing\n     * fails, it uses the retryChain to attempt to fix the output and retry\n     * the parsing process.\n     * @param completion The completion to be parsed.\n     * @param callbacks Optional callbacks to be used during parsing.\n     * @returns The parsed output.\n     */\n    parse(completion: string, callbacks?: Callbacks): Promise<T>;\n    /**\n     * Method to get the format instructions for the parser.\n     * @returns The format instructions for the parser.\n     */\n    getFormatInstructions(): string;\n}\nexport {};\n//# sourceMappingURL=fix.d.ts.map"],"mappings":";;;;;;;;UAMUO,4BAAAA;;EAAAA,UAAAA,EAAAA,MAAAA;EAUWC,KAAAA,EAPVL,qBAO4BM;;;;;;;AAKZJ,cALNG,kBAKMH,CAAAA,CAAAA,CAAAA,SALwBH,gBAKxBG,CALyCI,CAKzCJ,CAAAA,CAAAA;EASAL,OAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAAqDS,YAAAA,EAAAA,MAAAA,EAAAA;EAAjBP,eAAAA,EAAAA,OAAAA;EAC9CE,MAAAA,EAXLF,gBAWKE,CAXYK,CAWZL,CAAAA;EACUK,UAAAA,EAXXH,QAWWG,GAXAJ,QAWAI,CAXSF,4BAWTE,EAXuCA,CAWvCA,CAAAA;EAAnBD;;;;;;;;EAGuBH,OAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EALJL,0BAKIK,EAAAA,MAAAA,EALgCH,gBAKhCG,CALiDI,CAKjDJ,CAAAA,EAAAA,MAU+BI,CAV/BJ,EAAAA;IAUWJ,MAAAA,CAAAA,EAdzBG,kBAcyBH;EAAoBQ,CAAAA,CAAAA,EAbtDD,kBAasDC,CAbnCA,CAamCA,CAAAA;EAARG,WAAAA,CAAAA;IAAAA,MAAAA;IAAAA;GAAAA,EAAAA;IA7BHV,MAAAA,EAkBnCA,gBAlBmCA,CAkBlBO,CAlBkBP,CAAAA;IAAgB,UAAA,EAmB/CI,QAnB+C,GAmBpCD,QAnBoC,CAmB3BE,4BAnB2B,EAmBGE,CAnBH,CAAA;;;;;;;;;;wCA6BzBR,YAAYW,QAAQH"}